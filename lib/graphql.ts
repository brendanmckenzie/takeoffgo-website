import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
  /** A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone. */
  Datetime: string;
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: any;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form. */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `Account`. */
  accounts?: Maybe<AccountsConnection>;
  /** Reads and enables pagination through a set of `Agency`. */
  agencies?: Maybe<AgenciesConnection>;
  /** Reads and enables pagination through a set of `AgencyMember`. */
  agencyMembers?: Maybe<AgencyMembersConnection>;
  /** Reads and enables pagination through a set of `Airport`. */
  airports?: Maybe<AirportsConnection>;
  /** Reads and enables pagination through a set of `CombinedTransaction`. */
  combinedTransactions?: Maybe<CombinedTransactionsConnection>;
  /** Reads and enables pagination through a set of `Country`. */
  countries?: Maybe<CountriesConnection>;
  /** Reads and enables pagination through a set of `Customer`. */
  customers?: Maybe<CustomersConnection>;
  /** Reads and enables pagination through a set of `CustomerTraveller`. */
  customerTravellers?: Maybe<CustomerTravellersConnection>;
  /** Reads and enables pagination through a set of `DashboardSummary`. */
  dashboardSummaries?: Maybe<DashboardSummariesConnection>;
  /** Reads and enables pagination through a set of `Destination`. */
  destinations?: Maybe<DestinationsConnection>;
  /** Reads and enables pagination through a set of `DestinationFeature`. */
  destinationFeatures?: Maybe<DestinationFeaturesConnection>;
  /** Reads and enables pagination through a set of `DestinationGuide`. */
  destinationGuides?: Maybe<DestinationGuidesConnection>;
  /** Reads and enables pagination through a set of `Email`. */
  emails?: Maybe<EmailsConnection>;
  /** Reads and enables pagination through a set of `Enquiry`. */
  enquiries?: Maybe<EnquiriesConnection>;
  /** Reads and enables pagination through a set of `Expense`. */
  expenses?: Maybe<ExpensesConnection>;
  /** Reads and enables pagination through a set of `Feature`. */
  features?: Maybe<FeaturesConnection>;
  /** Reads and enables pagination through a set of `FinanceCategory`. */
  financeCategories?: Maybe<FinanceCategoriesConnection>;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices?: Maybe<InvoicesConnection>;
  /** Reads and enables pagination through a set of `InvoiceSummary`. */
  invoiceSummaries?: Maybe<InvoiceSummariesConnection>;
  /** Reads and enables pagination through a set of `MapPoint`. */
  mapPoints?: Maybe<MapPointsConnection>;
  /** Reads and enables pagination through a set of `MediaGallery`. */
  mediaGalleries?: Maybe<MediaGalleriesConnection>;
  /** Reads and enables pagination through a set of `MediaGalleryItem`. */
  mediaGalleryItems?: Maybe<MediaGalleryItemsConnection>;
  /** Reads and enables pagination through a set of `MediaItem`. */
  mediaItems?: Maybe<MediaItemsConnection>;
  /** Reads and enables pagination through a set of `Note`. */
  notes?: Maybe<NotesConnection>;
  /** Reads and enables pagination through a set of `Passport`. */
  passports?: Maybe<PassportsConnection>;
  /** Reads and enables pagination through a set of `Payment`. */
  payments?: Maybe<PaymentsConnection>;
  /** Reads and enables pagination through a set of `Property`. */
  properties?: Maybe<PropertiesConnection>;
  /** Reads and enables pagination through a set of `Quote`. */
  quotes?: Maybe<QuotesConnection>;
  /** Reads and enables pagination through a set of `QuoteView`. */
  quoteViews?: Maybe<QuoteViewsConnection>;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetails?: Maybe<QuoteAccommodationDetailsConnection>;
  /** Reads and enables pagination through a set of `QuoteCurrency`. */
  quoteCurrencies?: Maybe<QuoteCurrenciesConnection>;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDays?: Maybe<QuoteDaysConnection>;
  /** Reads and enables pagination through a set of `QuoteDayDestination`. */
  quoteDayDestinations?: Maybe<QuoteDayDestinationsConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItem`. */
  quoteFinanceLineItems?: Maybe<QuoteFinanceLineItemsConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItemSummary`. */
  quoteFinanceLineItemSummaries?: Maybe<QuoteFinanceLineItemSummariesConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceSummary`. */
  quoteFinanceSummaries?: Maybe<QuoteFinanceSummariesConnection>;
  /** Reads and enables pagination through a set of `QuoteHero`. */
  quoteHeroes?: Maybe<QuoteHeroesConnection>;
  /** Reads and enables pagination through a set of `Reminder`. */
  reminders?: Maybe<RemindersConnection>;
  /** Reads and enables pagination through a set of `Supplier`. */
  suppliers?: Maybe<SuppliersConnection>;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices?: Maybe<SupplierInvoicesConnection>;
  /** Reads and enables pagination through a set of `Testimonial`. */
  testimonials?: Maybe<TestimonialsConnection>;
  /** Reads and enables pagination through a set of `Timeline`. */
  timelines?: Maybe<TimelinesConnection>;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactions?: Maybe<TransactionsConnection>;
  /** Reads and enables pagination through a set of `TransactionImportBatch`. */
  transactionImportBatches?: Maybe<TransactionImportBatchesConnection>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks?: Maybe<TransactionLinksConnection>;
  /** Reads and enables pagination through a set of `TransactionNote`. */
  transactionNotes?: Maybe<TransactionNotesConnection>;
  /** Reads and enables pagination through a set of `Traveller`. */
  travellers?: Maybe<TravellersConnection>;
  /** Reads and enables pagination through a set of `Trip`. */
  trips?: Maybe<TripsConnection>;
  /** Reads and enables pagination through a set of `TripTraveller`. */
  tripTravellers?: Maybe<TripTravellersConnection>;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlights?: Maybe<TripFlightsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `VirtualTransaction`. */
  virtualTransactions?: Maybe<VirtualTransactionsConnection>;
  /** Reads and enables pagination through a set of `VisaRequirement`. */
  visaRequirements?: Maybe<VisaRequirementsConnection>;
  account?: Maybe<Account>;
  agency?: Maybe<Agency>;
  agencyMember?: Maybe<AgencyMember>;
  airport?: Maybe<Airport>;
  country?: Maybe<Country>;
  customer?: Maybe<Customer>;
  customerTraveller?: Maybe<CustomerTraveller>;
  destination?: Maybe<Destination>;
  destinationFeature?: Maybe<DestinationFeature>;
  destinationGuide?: Maybe<DestinationGuide>;
  email?: Maybe<Email>;
  enquiry?: Maybe<Enquiry>;
  expense?: Maybe<Expense>;
  feature?: Maybe<Feature>;
  financeCategory?: Maybe<FinanceCategory>;
  invoice?: Maybe<Invoice>;
  invoicePublic?: Maybe<InvoicePublic>;
  mapPoint?: Maybe<MapPoint>;
  mediaGallery?: Maybe<MediaGallery>;
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  mediaItem?: Maybe<MediaItem>;
  note?: Maybe<Note>;
  passport?: Maybe<Passport>;
  payment?: Maybe<Payment>;
  property?: Maybe<Property>;
  quote?: Maybe<Quote>;
  quoteView?: Maybe<QuoteView>;
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  quoteCurrency?: Maybe<QuoteCurrency>;
  quoteDay?: Maybe<QuoteDay>;
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  quoteHero?: Maybe<QuoteHero>;
  quotePublic?: Maybe<QuotePublic>;
  reminder?: Maybe<Reminder>;
  supplier?: Maybe<Supplier>;
  supplierInvoice?: Maybe<SupplierInvoice>;
  testimonial?: Maybe<Testimonial>;
  transaction?: Maybe<Transaction>;
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  transactionLink?: Maybe<TransactionLink>;
  transactionNote?: Maybe<TransactionNote>;
  traveller?: Maybe<Traveller>;
  trip?: Maybe<Trip>;
  tripTraveller?: Maybe<TripTraveller>;
  tripFlight?: Maybe<TripFlight>;
  user?: Maybe<User>;
  visaRequirement?: Maybe<VisaRequirement>;
  currentUserRoles?: Maybe<Scalars['String']>;
  currentUserSub?: Maybe<Scalars['String']>;
  featuredProperty?: Maybe<Property>;
  userCan?: Maybe<Scalars['Boolean']>;
  /** Reads a single `Account` using its globally unique `ID`. */
  accountByNodeId?: Maybe<Account>;
  /** Reads a single `Agency` using its globally unique `ID`. */
  agencyByNodeId?: Maybe<Agency>;
  /** Reads a single `AgencyMember` using its globally unique `ID`. */
  agencyMemberByNodeId?: Maybe<AgencyMember>;
  /** Reads a single `Airport` using its globally unique `ID`. */
  airportByNodeId?: Maybe<Airport>;
  /** Reads a single `Country` using its globally unique `ID`. */
  countryByNodeId?: Maybe<Country>;
  /** Reads a single `Customer` using its globally unique `ID`. */
  customerByNodeId?: Maybe<Customer>;
  /** Reads a single `CustomerTraveller` using its globally unique `ID`. */
  customerTravellerByNodeId?: Maybe<CustomerTraveller>;
  /** Reads a single `Destination` using its globally unique `ID`. */
  destinationByNodeId?: Maybe<Destination>;
  /** Reads a single `DestinationFeature` using its globally unique `ID`. */
  destinationFeatureByNodeId?: Maybe<DestinationFeature>;
  /** Reads a single `DestinationGuide` using its globally unique `ID`. */
  destinationGuideByNodeId?: Maybe<DestinationGuide>;
  /** Reads a single `Email` using its globally unique `ID`. */
  emailByNodeId?: Maybe<Email>;
  /** Reads a single `Enquiry` using its globally unique `ID`. */
  enquiryByNodeId?: Maybe<Enquiry>;
  /** Reads a single `Expense` using its globally unique `ID`. */
  expenseByNodeId?: Maybe<Expense>;
  /** Reads a single `Feature` using its globally unique `ID`. */
  featureByNodeId?: Maybe<Feature>;
  /** Reads a single `FinanceCategory` using its globally unique `ID`. */
  financeCategoryByNodeId?: Maybe<FinanceCategory>;
  /** Reads a single `Invoice` using its globally unique `ID`. */
  invoiceByNodeId?: Maybe<Invoice>;
  /** Reads a single `InvoicePublic` using its globally unique `ID`. */
  invoicePublicByNodeId?: Maybe<InvoicePublic>;
  /** Reads a single `MapPoint` using its globally unique `ID`. */
  mapPointByNodeId?: Maybe<MapPoint>;
  /** Reads a single `MediaGallery` using its globally unique `ID`. */
  mediaGalleryByNodeId?: Maybe<MediaGallery>;
  /** Reads a single `MediaGalleryItem` using its globally unique `ID`. */
  mediaGalleryItemByNodeId?: Maybe<MediaGalleryItem>;
  /** Reads a single `MediaItem` using its globally unique `ID`. */
  mediaItemByNodeId?: Maybe<MediaItem>;
  /** Reads a single `Note` using its globally unique `ID`. */
  noteByNodeId?: Maybe<Note>;
  /** Reads a single `Passport` using its globally unique `ID`. */
  passportByNodeId?: Maybe<Passport>;
  /** Reads a single `Payment` using its globally unique `ID`. */
  paymentByNodeId?: Maybe<Payment>;
  /** Reads a single `Property` using its globally unique `ID`. */
  propertyByNodeId?: Maybe<Property>;
  /** Reads a single `Quote` using its globally unique `ID`. */
  quoteByNodeId?: Maybe<Quote>;
  /** Reads a single `QuoteView` using its globally unique `ID`. */
  quoteViewByNodeId?: Maybe<QuoteView>;
  /** Reads a single `QuoteAccommodationDetail` using its globally unique `ID`. */
  quoteAccommodationDetailByNodeId?: Maybe<QuoteAccommodationDetail>;
  /** Reads a single `QuoteCurrency` using its globally unique `ID`. */
  quoteCurrencyByNodeId?: Maybe<QuoteCurrency>;
  /** Reads a single `QuoteDay` using its globally unique `ID`. */
  quoteDayByNodeId?: Maybe<QuoteDay>;
  /** Reads a single `QuoteDayDestination` using its globally unique `ID`. */
  quoteDayDestinationByNodeId?: Maybe<QuoteDayDestination>;
  /** Reads a single `QuoteFinanceLineItem` using its globally unique `ID`. */
  quoteFinanceLineItemByNodeId?: Maybe<QuoteFinanceLineItem>;
  /** Reads a single `QuoteHero` using its globally unique `ID`. */
  quoteHeroByNodeId?: Maybe<QuoteHero>;
  /** Reads a single `QuotePublic` using its globally unique `ID`. */
  quotePublicByNodeId?: Maybe<QuotePublic>;
  /** Reads a single `Reminder` using its globally unique `ID`. */
  reminderByNodeId?: Maybe<Reminder>;
  /** Reads a single `Supplier` using its globally unique `ID`. */
  supplierByNodeId?: Maybe<Supplier>;
  /** Reads a single `SupplierInvoice` using its globally unique `ID`. */
  supplierInvoiceByNodeId?: Maybe<SupplierInvoice>;
  /** Reads a single `Testimonial` using its globally unique `ID`. */
  testimonialByNodeId?: Maybe<Testimonial>;
  /** Reads a single `Transaction` using its globally unique `ID`. */
  transactionByNodeId?: Maybe<Transaction>;
  /** Reads a single `TransactionImportBatch` using its globally unique `ID`. */
  transactionImportBatchByNodeId?: Maybe<TransactionImportBatch>;
  /** Reads a single `TransactionLink` using its globally unique `ID`. */
  transactionLinkByNodeId?: Maybe<TransactionLink>;
  /** Reads a single `TransactionNote` using its globally unique `ID`. */
  transactionNoteByNodeId?: Maybe<TransactionNote>;
  /** Reads a single `Traveller` using its globally unique `ID`. */
  travellerByNodeId?: Maybe<Traveller>;
  /** Reads a single `Trip` using its globally unique `ID`. */
  tripByNodeId?: Maybe<Trip>;
  /** Reads a single `TripTraveller` using its globally unique `ID`. */
  tripTravellerByNodeId?: Maybe<TripTraveller>;
  /** Reads a single `TripFlight` using its globally unique `ID`. */
  tripFlightByNodeId?: Maybe<TripFlight>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  /** Reads a single `VisaRequirement` using its globally unique `ID`. */
  visaRequirementByNodeId?: Maybe<VisaRequirement>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AccountsOrderBy>>;
  condition?: Maybe<AccountCondition>;
  filter?: Maybe<AccountFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAgenciesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgenciesOrderBy>>;
  condition?: Maybe<AgencyCondition>;
  filter?: Maybe<AgencyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyMembersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgencyMembersOrderBy>>;
  condition?: Maybe<AgencyMemberCondition>;
  filter?: Maybe<AgencyMemberFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAirportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AirportsOrderBy>>;
  condition?: Maybe<AirportCondition>;
  filter?: Maybe<AirportFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCombinedTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CombinedTransactionsOrderBy>>;
  condition?: Maybe<CombinedTransactionCondition>;
  filter?: Maybe<CombinedTransactionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCountriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CountriesOrderBy>>;
  condition?: Maybe<CountryCondition>;
  filter?: Maybe<CountryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerTravellersOrderBy>>;
  condition?: Maybe<CustomerTravellerCondition>;
  filter?: Maybe<CustomerTravellerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDashboardSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DashboardSummariesOrderBy>>;
  condition?: Maybe<DashboardSummaryCondition>;
  filter?: Maybe<DashboardSummaryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
  condition?: Maybe<DestinationCondition>;
  filter?: Maybe<DestinationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationFeaturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationFeaturesOrderBy>>;
  condition?: Maybe<DestinationFeatureCondition>;
  filter?: Maybe<DestinationFeatureFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationGuidesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationGuidesOrderBy>>;
  condition?: Maybe<DestinationGuideCondition>;
  filter?: Maybe<DestinationGuideFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEmailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EmailsOrderBy>>;
  condition?: Maybe<EmailCondition>;
  filter?: Maybe<EmailFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEnquiriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EnquiriesOrderBy>>;
  condition?: Maybe<EnquiryCondition>;
  filter?: Maybe<EnquiryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryExpensesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
  condition?: Maybe<ExpenseCondition>;
  filter?: Maybe<ExpenseFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFeaturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FeaturesOrderBy>>;
  condition?: Maybe<FeatureCondition>;
  filter?: Maybe<FeatureFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFinanceCategoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FinanceCategoriesOrderBy>>;
  condition?: Maybe<FinanceCategoryCondition>;
  filter?: Maybe<FinanceCategoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
  condition?: Maybe<InvoiceCondition>;
  filter?: Maybe<InvoiceFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoiceSummariesOrderBy>>;
  condition?: Maybe<InvoiceSummaryCondition>;
  filter?: Maybe<InvoiceSummaryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMapPointsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MapPointsOrderBy>>;
  condition?: Maybe<MapPointCondition>;
  filter?: Maybe<MapPointFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaGalleriesOrderBy>>;
  condition?: Maybe<MediaGalleryCondition>;
  filter?: Maybe<MediaGalleryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaGalleryItemsOrderBy>>;
  condition?: Maybe<MediaGalleryItemCondition>;
  filter?: Maybe<MediaGalleryItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaItemsOrderBy>>;
  condition?: Maybe<MediaItemCondition>;
  filter?: Maybe<MediaItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotesOrderBy>>;
  condition?: Maybe<NoteCondition>;
  filter?: Maybe<NoteFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPassportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PassportsOrderBy>>;
  condition?: Maybe<PassportCondition>;
  filter?: Maybe<PassportFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
  condition?: Maybe<PaymentCondition>;
  filter?: Maybe<PaymentFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
  condition?: Maybe<PropertyCondition>;
  filter?: Maybe<PropertyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotesOrderBy>>;
  condition?: Maybe<QuoteCondition>;
  filter?: Maybe<QuoteFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteViewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteViewsOrderBy>>;
  condition?: Maybe<QuoteViewCondition>;
  filter?: Maybe<QuoteViewFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteAccommodationDetailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
  condition?: Maybe<QuoteAccommodationDetailCondition>;
  filter?: Maybe<QuoteAccommodationDetailFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteCurrenciesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteCurrenciesOrderBy>>;
  condition?: Maybe<QuoteCurrencyCondition>;
  filter?: Maybe<QuoteCurrencyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDaysArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
  condition?: Maybe<QuoteDayCondition>;
  filter?: Maybe<QuoteDayFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDayDestinationsOrderBy>>;
  condition?: Maybe<QuoteDayDestinationCondition>;
  filter?: Maybe<QuoteDayDestinationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceLineItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceLineItemsOrderBy>>;
  condition?: Maybe<QuoteFinanceLineItemCondition>;
  filter?: Maybe<QuoteFinanceLineItemFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceLineItemSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceLineItemSummariesOrderBy>>;
  condition?: Maybe<QuoteFinanceLineItemSummaryCondition>;
  filter?: Maybe<QuoteFinanceLineItemSummaryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceSummariesOrderBy>>;
  condition?: Maybe<QuoteFinanceSummaryCondition>;
  filter?: Maybe<QuoteFinanceSummaryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteHeroesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteHeroesOrderBy>>;
  condition?: Maybe<QuoteHeroCondition>;
  filter?: Maybe<QuoteHeroFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRemindersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<RemindersOrderBy>>;
  condition?: Maybe<ReminderCondition>;
  filter?: Maybe<ReminderFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySuppliersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SuppliersOrderBy>>;
  condition?: Maybe<SupplierCondition>;
  filter?: Maybe<SupplierFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
  condition?: Maybe<SupplierInvoiceCondition>;
  filter?: Maybe<SupplierInvoiceFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTestimonialsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TestimonialsOrderBy>>;
  condition?: Maybe<TestimonialCondition>;
  filter?: Maybe<TestimonialFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTimelinesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TimelinesOrderBy>>;
  condition?: Maybe<TimelineCondition>;
  filter?: Maybe<TimelineFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
  condition?: Maybe<TransactionCondition>;
  filter?: Maybe<TransactionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionImportBatchesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionImportBatchesOrderBy>>;
  condition?: Maybe<TransactionImportBatchCondition>;
  filter?: Maybe<TransactionImportBatchFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionLinksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
  condition?: Maybe<TransactionLinkCondition>;
  filter?: Maybe<TransactionLinkFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionNotesOrderBy>>;
  condition?: Maybe<TransactionNoteCondition>;
  filter?: Maybe<TransactionNoteFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TravellersOrderBy>>;
  condition?: Maybe<TravellerCondition>;
  filter?: Maybe<TravellerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTripsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTripTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripTravellersOrderBy>>;
  condition?: Maybe<TripTravellerCondition>;
  filter?: Maybe<TripTravellerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTripFlightsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
  condition?: Maybe<TripFlightCondition>;
  filter?: Maybe<TripFlightFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVirtualTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VirtualTransactionsOrderBy>>;
  condition?: Maybe<VirtualTransactionCondition>;
  filter?: Maybe<VirtualTransactionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVisaRequirementsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VisaRequirementsOrderBy>>;
  condition?: Maybe<VisaRequirementCondition>;
  filter?: Maybe<VisaRequirementFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyMemberArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAirportArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountryArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerTravellerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationFeatureArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationGuideArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEmailArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnquiryArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeatureArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFinanceCategoryArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoicePublicArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMapPointArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryItemArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaItemArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNoteArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPassportArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPaymentArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteViewArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteAccommodationDetailArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteCurrencyArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayDestinationArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceLineItemArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteHeroArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuotePublicArgs = {
  key: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReminderArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierInvoiceArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTestimonialArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionImportBatchArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionLinkArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionNoteArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTravellerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripTravellerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripFlightArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVisaRequirementArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserCanArgs = {
  task?: Maybe<Scalars['String']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyMemberByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAirportByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerTravellerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationFeatureByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationGuideByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEmailByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnquiryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeatureByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFinanceCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoicePublicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMapPointByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNoteByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPassportByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPaymentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteViewByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteAccommodationDetailByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteCurrencyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayDestinationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceLineItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteHeroByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuotePublicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReminderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierInvoiceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTestimonialByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionImportBatchByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionLinkByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionNoteByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTravellerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripTravellerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripFlightByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVisaRequirementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};


/** Methods to use when ordering `Account`. */
export enum AccountsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  InstitutionAsc = 'INSTITUTION_ASC',
  InstitutionDesc = 'INSTITUTION_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransactionsByAccountIdCountAsc = 'TRANSACTIONS_BY_ACCOUNT_ID__COUNT_ASC',
  TransactionsByAccountIdCountDesc = 'TRANSACTIONS_BY_ACCOUNT_ID__COUNT_DESC',
  TransactionImportBatchesByAccountIdCountAsc = 'TRANSACTION_IMPORT_BATCHES_BY_ACCOUNT_ID__COUNT_ASC',
  TransactionImportBatchesByAccountIdCountDesc = 'TRANSACTION_IMPORT_BATCHES_BY_ACCOUNT_ID__COUNT_DESC'
}

/** A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AccountCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `institution` field. */
  institution?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `details` field. */
  details?: Maybe<Scalars['String']>;
};



/** A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’ */
export type AccountFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `institution` field. */
  institution?: Maybe<StringFilter>;
  /** Filter by the object’s `details` field. */
  details?: Maybe<StringFilter>;
  /** Filter by the object’s `transactions` relation. */
  transactions?: Maybe<AccountToManyTransactionFilter>;
  /** Some related `transactions` exist. */
  transactionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionImportBatches` relation. */
  transactionImportBatches?: Maybe<AccountToManyTransactionImportBatchFilter>;
  /** Some related `transactionImportBatches` exist. */
  transactionImportBatchesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AccountFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AccountFilter>>;
  /** Negates the expression. */
  not?: Maybe<AccountFilter>;
};

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['UUID']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['UUID']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['UUID']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['UUID']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['UUID']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern using the SQL standard's definition of a regular expression. */
  similarTo?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern using the SQL standard's definition of a regular expression. */
  notSimilarTo?: Maybe<Scalars['String']>;
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type AccountToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionFilter>;
};

/** A filter to be used against `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type TransactionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `accountId` field. */
  accountId?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `externalId` field. */
  externalId?: Maybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `reverseTransactionId` field. */
  reverseTransactionId?: Maybe<UuidFilter>;
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>;
  /** Filter by the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: Maybe<UuidFilter>;
  /** Filter by the object’s `balance` field. */
  balance?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `transactionsByReverseTransactionId` relation. */
  transactionsByReverseTransactionId?: Maybe<TransactionToManyTransactionFilter>;
  /** Some related `transactionsByReverseTransactionId` exist. */
  transactionsByReverseTransactionIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: Maybe<TransactionToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionNotes` relation. */
  transactionNotes?: Maybe<TransactionToManyTransactionNoteFilter>;
  /** Some related `transactionNotes` exist. */
  transactionNotesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `account` relation. */
  account?: Maybe<AccountFilter>;
  /** Filter by the object’s `reverseTransaction` relation. */
  reverseTransaction?: Maybe<TransactionFilter>;
  /** A related `reverseTransaction` exists. */
  reverseTransactionExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionImportBatch` relation. */
  transactionImportBatch?: Maybe<TransactionImportBatchFilter>;
  /** A related `transactionImportBatch` exists. */
  transactionImportBatchExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `category` relation. */
  category?: Maybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TransactionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TransactionFilter>>;
  /** Negates the expression. */
  not?: Maybe<TransactionFilter>;
};

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['BigFloat']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['BigFloat']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['BigFloat']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['BigFloat']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['BigFloat']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['BigFloat']>;
};


/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type TransactionToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type TransactionToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionLinkFilter>;
};

/** A filter to be used against `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type TransactionLinkFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `transactionId` field. */
  transactionId?: Maybe<UuidFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `paymentId` field. */
  paymentId?: Maybe<UuidFilter>;
  /** Filter by the object’s `expenseId` field. */
  expenseId?: Maybe<UuidFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `transaction` relation. */
  transaction?: Maybe<TransactionFilter>;
  /** Filter by the object’s `invoice` relation. */
  invoice?: Maybe<InvoiceFilter>;
  /** A related `invoice` exists. */
  invoiceExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplierInvoice` relation. */
  supplierInvoice?: Maybe<SupplierInvoiceFilter>;
  /** A related `supplierInvoice` exists. */
  supplierInvoiceExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `payment` relation. */
  payment?: Maybe<PaymentFilter>;
  /** A related `payment` exists. */
  paymentExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `expense` relation. */
  expense?: Maybe<ExpenseFilter>;
  /** A related `expense` exists. */
  expenseExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TransactionLinkFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TransactionLinkFilter>>;
  /** Negates the expression. */
  not?: Maybe<TransactionLinkFilter>;
};

/** A filter to be used against `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `due` field. */
  due?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `key` field. */
  key?: Maybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `number` field. */
  number?: Maybe<IntFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `voided` field. */
  voided?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `paid` field. */
  paid?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `note` field. */
  note?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiced` field. */
  invoiced?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: Maybe<InvoiceToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `payments` relation. */
  payments?: Maybe<InvoiceToManyPaymentFilter>;
  /** Some related `payments` exist. */
  paymentsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: Maybe<InvoiceToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quote` relation. */
  quote?: Maybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `category` relation. */
  category?: Maybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InvoiceFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InvoiceFilter>>;
  /** Negates the expression. */
  not?: Maybe<InvoiceFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ExpenseFilter>;
};

/** A filter to be used against `Expense` object types. All fields are combined with a logical ‘and.’ */
export type ExpenseFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `amountActual` field. */
  amountActual?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `paid` field. */
  paid?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `supplierId` field. */
  supplierId?: Maybe<UuidFilter>;
  /** Filter by the object’s `reference` field. */
  reference?: Maybe<StringFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: Maybe<ExpenseToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `invoice` relation. */
  invoice?: Maybe<InvoiceFilter>;
  /** A related `invoice` exists. */
  invoiceExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplier` relation. */
  supplier?: Maybe<SupplierFilter>;
  /** Filter by the object’s `category` relation. */
  category?: Maybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplierInvoice` relation. */
  supplierInvoice?: Maybe<SupplierInvoiceFilter>;
  /** A related `supplierInvoice` exists. */
  supplierInvoiceExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ExpenseFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ExpenseFilter>>;
  /** Negates the expression. */
  not?: Maybe<ExpenseFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type ExpenseToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionLinkFilter>;
};

/** A filter to be used against `Supplier` object types. All fields are combined with a logical ‘and.’ */
export type SupplierFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: Maybe<StringFilter>;
  /** Filter by the object’s `contactNumber` field. */
  contactNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `region` field. */
  region?: Maybe<StringFilter>;
  /** Filter by the object’s `url` field. */
  url?: Maybe<StringFilter>;
  /** Filter by the object’s `bankDetails` field. */
  bankDetails?: Maybe<StringFilter>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: Maybe<SupplierToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplierInvoices` relation. */
  supplierInvoices?: Maybe<SupplierToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoices` exist. */
  supplierInvoicesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteFinanceLineItems` relation. */
  quoteFinanceLineItems?: Maybe<SupplierToManyQuoteFinanceLineItemFilter>;
  /** Some related `quoteFinanceLineItems` exist. */
  quoteFinanceLineItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: Maybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SupplierFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SupplierFilter>>;
  /** Negates the expression. */
  not?: Maybe<SupplierFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type SupplierToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ExpenseFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type SupplierToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<SupplierInvoiceFilter>;
};

/** A filter to be used against `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type SupplierInvoiceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `due` field. */
  due?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `key` field. */
  key?: Maybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `number` field. */
  number?: Maybe<IntFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `supplierId` field. */
  supplierId?: Maybe<UuidFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `voided` field. */
  voided?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `amountActual` field. */
  amountActual?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `paid` field. */
  paid?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `mediaItemId` field. */
  mediaItemId?: Maybe<UuidFilter>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: Maybe<SupplierInvoiceToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: Maybe<SupplierInvoiceToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `category` relation. */
  category?: Maybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplier` relation. */
  supplier?: Maybe<SupplierFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `mediaItem` relation. */
  mediaItem?: Maybe<MediaItemFilter>;
  /** A related `mediaItem` exists. */
  mediaItemExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SupplierInvoiceFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SupplierInvoiceFilter>>;
  /** Negates the expression. */
  not?: Maybe<SupplierInvoiceFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type SupplierInvoiceToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ExpenseFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type SupplierInvoiceToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionLinkFilter>;
};

/** A filter to be used against `FinanceCategory` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<IntFilter>;
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>;
  /** Filter by the object’s `expensesByCategoryId` relation. */
  expensesByCategoryId?: Maybe<FinanceCategoryToManyExpenseFilter>;
  /** Some related `expensesByCategoryId` exist. */
  expensesByCategoryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `invoicesByCategoryId` relation. */
  invoicesByCategoryId?: Maybe<FinanceCategoryToManyInvoiceFilter>;
  /** Some related `invoicesByCategoryId` exist. */
  invoicesByCategoryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `paymentsByCategoryId` relation. */
  paymentsByCategoryId?: Maybe<FinanceCategoryToManyPaymentFilter>;
  /** Some related `paymentsByCategoryId` exist. */
  paymentsByCategoryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplierInvoicesByCategoryId` relation. */
  supplierInvoicesByCategoryId?: Maybe<FinanceCategoryToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoicesByCategoryId` exist. */
  supplierInvoicesByCategoryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionsByCategoryId` relation. */
  transactionsByCategoryId?: Maybe<FinanceCategoryToManyTransactionFilter>;
  /** Some related `transactionsByCategoryId` exist. */
  transactionsByCategoryIdExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FinanceCategoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FinanceCategoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<FinanceCategoryFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ExpenseFilter>;
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<InvoiceFilter>;
};

/** A filter to be used against many `Payment` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyPaymentFilter = {
  /** Every related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PaymentFilter>;
  /** Some related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PaymentFilter>;
  /** No related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PaymentFilter>;
};

/** A filter to be used against `Payment` object types. All fields are combined with a logical ‘and.’ */
export type PaymentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `amountActual` field. */
  amountActual?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `paid` field. */
  paid?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `reference` field. */
  reference?: Maybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<IntFilter>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: Maybe<PaymentToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `invoice` relation. */
  invoice?: Maybe<InvoiceFilter>;
  /** Filter by the object’s `category` relation. */
  category?: Maybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PaymentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PaymentFilter>>;
  /** Negates the expression. */
  not?: Maybe<PaymentFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type PaymentToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionLinkFilter>;
};

/** A filter to be used against `Trip` object types. All fields are combined with a logical ‘and.’ */
export type TripFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `destination` field. */
  destination?: Maybe<StringFilter>;
  /** Filter by the object’s `dates` field. */
  dates?: Maybe<StringFilter>;
  /** Filter by the object’s `archived` field. */
  archived?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `mediaGalleryId` field. */
  mediaGalleryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `activeQuoteId` field. */
  activeQuoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `baseCurrency` field. */
  baseCurrency?: Maybe<StringFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: Maybe<IntFilter>;
  /** Filter by the object’s `start` field. */
  start?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `agencyId` field. */
  agencyId?: Maybe<UuidFilter>;
  /** Filter by the object’s `agencyMemberId` field. */
  agencyMemberId?: Maybe<UuidFilter>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: Maybe<TripToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `invoices` relation. */
  invoices?: Maybe<TripToManyInvoiceFilter>;
  /** Some related `invoices` exist. */
  invoicesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `payments` relation. */
  payments?: Maybe<TripToManyPaymentFilter>;
  /** Some related `payments` exist. */
  paymentsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplierInvoices` relation. */
  supplierInvoices?: Maybe<TripToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoices` exist. */
  supplierInvoicesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `emails` relation. */
  emails?: Maybe<TripToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `enquiries` relation. */
  enquiries?: Maybe<TripToManyEnquiryFilter>;
  /** Some related `enquiries` exist. */
  enquiriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `notes` relation. */
  notes?: Maybe<TripToManyNoteFilter>;
  /** Some related `notes` exist. */
  notesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotes` relation. */
  quotes?: Maybe<TripToManyQuoteFilter>;
  /** Some related `quotes` exist. */
  quotesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `testimonials` relation. */
  testimonials?: Maybe<TripToManyTestimonialFilter>;
  /** Some related `testimonials` exist. */
  testimonialsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `tripTravellers` relation. */
  tripTravellers?: Maybe<TripToManyTripTravellerFilter>;
  /** Some related `tripTravellers` exist. */
  tripTravellersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `tripFlights` relation. */
  tripFlights?: Maybe<TripToManyTripFlightFilter>;
  /** Some related `tripFlights` exist. */
  tripFlightsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotePublics` relation. */
  quotePublics?: Maybe<TripToManyQuotePublicFilter>;
  /** Some related `quotePublics` exist. */
  quotePublicsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `mediaGallery` relation. */
  mediaGallery?: Maybe<MediaGalleryFilter>;
  /** A related `mediaGallery` exists. */
  mediaGalleryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `activeQuote` relation. */
  activeQuote?: Maybe<QuoteFilter>;
  /** A related `activeQuote` exists. */
  activeQuoteExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `agency` relation. */
  agency?: Maybe<AgencyFilter>;
  /** A related `agency` exists. */
  agencyExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `agencyMember` relation. */
  agencyMember?: Maybe<AgencyMemberFilter>;
  /** A related `agencyMember` exists. */
  agencyMemberExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TripFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TripFilter>>;
  /** Negates the expression. */
  not?: Maybe<TripFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ExpenseFilter>;
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<InvoiceFilter>;
};

/** A filter to be used against many `Payment` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyPaymentFilter = {
  /** Every related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PaymentFilter>;
  /** Some related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PaymentFilter>;
  /** No related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PaymentFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type TripToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<SupplierInvoiceFilter>;
};

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<EmailFilter>;
};

/** A filter to be used against `Email` object types. All fields are combined with a logical ‘and.’ */
export type EmailFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `recipients` field. */
  recipients?: Maybe<StringFilter>;
  /** Filter by the object’s `subject` field. */
  subject?: Maybe<StringFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<UuidFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** Filter by the object’s `quote` relation. */
  quote?: Maybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EmailFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EmailFilter>>;
  /** Negates the expression. */
  not?: Maybe<EmailFilter>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `password` field. */
  password?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `skype` field. */
  skype?: Maybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `genderPreposition` field. */
  genderPreposition?: Maybe<StringFilter>;
  /** Filter by the object’s `externalId` field. */
  externalId?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `trips` relation. */
  trips?: Maybe<UserToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `emails` relation. */
  emails?: Maybe<UserToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `notes` relation. */
  notes?: Maybe<UserToManyNoteFilter>;
  /** Some related `notes` exist. */
  notesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotes` relation. */
  quotes?: Maybe<UserToManyQuoteFilter>;
  /** Some related `quotes` exist. */
  quotesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reminders` relation. */
  reminders?: Maybe<UserToManyReminderFilter>;
  /** Some related `reminders` exist. */
  remindersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `transactionNotes` relation. */
  transactionNotes?: Maybe<UserToManyTransactionNoteFilter>;
  /** Some related `transactionNotes` exist. */
  transactionNotesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotePublics` relation. */
  quotePublics?: Maybe<UserToManyQuotePublicFilter>;
  /** Some related `quotePublics` exist. */
  quotePublicsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFilter>;
};

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<EmailFilter>;
};

/** A filter to be used against many `Note` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyNoteFilter = {
  /** Every related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<NoteFilter>;
  /** Some related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<NoteFilter>;
  /** No related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<NoteFilter>;
};

/** A filter to be used against `Note` object types. All fields are combined with a logical ‘and.’ */
export type NoteFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NoteFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NoteFilter>>;
  /** Negates the expression. */
  not?: Maybe<NoteFilter>;
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteFilter>;
};

/** A filter to be used against `Quote` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: Maybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `start` field. */
  start?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `deposit` field. */
  deposit?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `key` field. */
  key?: Maybe<StringFilter>;
  /** Filter by the object’s `expires` field. */
  expires?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `total` field. */
  total?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `adjustment` field. */
  adjustment?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `baseCurrency` field. */
  baseCurrency?: Maybe<StringFilter>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: Maybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `heroImageId` field. */
  heroImageId?: Maybe<UuidFilter>;
  /** Filter by the object’s `exclusions` field. */
  exclusions?: Maybe<StringFilter>;
  /** Filter by the object’s `inclusions` field. */
  inclusions?: Maybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `agentMargin` field. */
  agentMargin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `travellerCount` field. */
  travellerCount?: Maybe<IntFilter>;
  /** Filter by the object’s `archived` field. */
  archived?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `lastViewed` field. */
  lastViewed?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `heroId` field. */
  heroId?: Maybe<UuidFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<UuidFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `invoices` relation. */
  invoices?: Maybe<QuoteToManyInvoiceFilter>;
  /** Some related `invoices` exist. */
  invoicesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `tripsByActiveQuoteId` relation. */
  tripsByActiveQuoteId?: Maybe<QuoteToManyTripFilter>;
  /** Some related `tripsByActiveQuoteId` exist. */
  tripsByActiveQuoteIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `emails` relation. */
  emails?: Maybe<QuoteToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteViews` relation. */
  quoteViews?: Maybe<QuoteToManyQuoteViewFilter>;
  /** Some related `quoteViews` exist. */
  quoteViewsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteAccommodationDetails` relation. */
  quoteAccommodationDetails?: Maybe<QuoteToManyQuoteAccommodationDetailFilter>;
  /** Some related `quoteAccommodationDetails` exist. */
  quoteAccommodationDetailsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteCurrencies` relation. */
  quoteCurrencies?: Maybe<QuoteToManyQuoteCurrencyFilter>;
  /** Some related `quoteCurrencies` exist. */
  quoteCurrenciesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteDays` relation. */
  quoteDays?: Maybe<QuoteToManyQuoteDayFilter>;
  /** Some related `quoteDays` exist. */
  quoteDaysExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteFinanceLineItems` relation. */
  quoteFinanceLineItems?: Maybe<QuoteToManyQuoteFinanceLineItemFilter>;
  /** Some related `quoteFinanceLineItems` exist. */
  quoteFinanceLineItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** Filter by the object’s `heroImage` relation. */
  heroImage?: Maybe<MediaItemFilter>;
  /** A related `heroImage` exists. */
  heroImageExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `hero` relation. */
  hero?: Maybe<QuoteHeroFilter>;
  /** A related `hero` exists. */
  heroExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteFilter>;
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<InvoiceFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFilter>;
};

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<EmailFilter>;
};

/** A filter to be used against many `QuoteView` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteViewFilter = {
  /** Every related `QuoteView` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteViewFilter>;
  /** Some related `QuoteView` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteViewFilter>;
  /** No related `QuoteView` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteViewFilter>;
};

/** A filter to be used against `QuoteView` object types. All fields are combined with a logical ‘and.’ */
export type QuoteViewFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `timezone` field. */
  timezone?: Maybe<StringFilter>;
  /** Filter by the object’s `userIp` field. */
  userIp?: Maybe<StringFilter>;
  /** Filter by the object’s `viewType` field. */
  viewType?: Maybe<StringFilter>;
  /** Filter by the object’s `quote` relation. */
  quote?: Maybe<QuoteFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteViewFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteViewFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteViewFilter>;
};

/** A filter to be used against many `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteAccommodationDetailFilter = {
  /** Every related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteAccommodationDetailFilter>;
  /** Some related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteAccommodationDetailFilter>;
  /** No related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteAccommodationDetailFilter>;
};

/** A filter to be used against `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type QuoteAccommodationDetailFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `order` field. */
  order?: Maybe<IntFilter>;
  /** Filter by the object’s `nights` field. */
  nights?: Maybe<IntFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `propertyId` field. */
  propertyId?: Maybe<UuidFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `basis` field. */
  basis?: Maybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `confirmation` field. */
  confirmation?: Maybe<StringFilter>;
  /** Filter by the object’s `beverageInclusions` field. */
  beverageInclusions?: Maybe<StringListFilter>;
  /** Filter by the object’s `foodInclusions` field. */
  foodInclusions?: Maybe<StringListFilter>;
  /** Filter by the object’s `roomType` field. */
  roomType?: Maybe<StringFilter>;
  /** Filter by the object’s `quoteDaysByAccommodationId` relation. */
  quoteDaysByAccommodationId?: Maybe<QuoteAccommodationDetailToManyQuoteDayFilter>;
  /** Some related `quoteDaysByAccommodationId` exist. */
  quoteDaysByAccommodationIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `property` relation. */
  property?: Maybe<PropertyFilter>;
  /** A related `property` exists. */
  propertyExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quote` relation. */
  quote?: Maybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotePublic` relation. */
  quotePublic?: Maybe<QuotePublicFilter>;
  /** A related `quotePublic` exists. */
  quotePublicExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteAccommodationDetailFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteAccommodationDetailFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteAccommodationDetailFilter>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contains the specified list of values. */
  contains?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contained by the specified list of values. */
  containedBy?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Any array item is equal to the specified value. */
  anyEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: Maybe<Scalars['String']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: Maybe<Scalars['String']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: Maybe<Scalars['String']>;
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuoteAccommodationDetailToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteDayFilter>;
};

/** A filter to be used against `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuoteDayFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `order` field. */
  order?: Maybe<IntFilter>;
  /** Filter by the object’s `date` field. */
  date?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `activitySummary` field. */
  activitySummary?: Maybe<StringFilter>;
  /** Filter by the object’s `activityDetail` field. */
  activityDetail?: Maybe<StringFilter>;
  /** Filter by the object’s `accommodationId` field. */
  accommodationId?: Maybe<UuidFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `propertyId` field. */
  propertyId?: Maybe<UuidFilter>;
  /** Filter by the object’s `quoteDayDestinationsByDayId` relation. */
  quoteDayDestinationsByDayId?: Maybe<QuoteDayToManyQuoteDayDestinationFilter>;
  /** Some related `quoteDayDestinationsByDayId` exist. */
  quoteDayDestinationsByDayIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `accommodation` relation. */
  accommodation?: Maybe<QuoteAccommodationDetailFilter>;
  /** A related `accommodation` exists. */
  accommodationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quote` relation. */
  quote?: Maybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `property` relation. */
  property?: Maybe<PropertyFilter>;
  /** A related `property` exists. */
  propertyExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotePublic` relation. */
  quotePublic?: Maybe<QuotePublicFilter>;
  /** A related `quotePublic` exists. */
  quotePublicExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteDayFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteDayFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteDayFilter>;
};

/** A filter to be used against many `QuoteDayDestination` object types. All fields are combined with a logical ‘and.’ */
export type QuoteDayToManyQuoteDayDestinationFilter = {
  /** Every related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteDayDestinationFilter>;
  /** Some related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteDayDestinationFilter>;
  /** No related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteDayDestinationFilter>;
};

/** A filter to be used against `QuoteDayDestination` object types. All fields are combined with a logical ‘and.’ */
export type QuoteDayDestinationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `destinationId` field. */
  destinationId?: Maybe<UuidFilter>;
  /** Filter by the object’s `dayId` field. */
  dayId?: Maybe<UuidFilter>;
  /** Filter by the object’s `order` field. */
  order?: Maybe<IntFilter>;
  /** Filter by the object’s `destination` relation. */
  destination?: Maybe<DestinationFilter>;
  /** Filter by the object’s `day` relation. */
  day?: Maybe<QuoteDayFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteDayDestinationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteDayDestinationFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteDayDestinationFilter>;
};

/** A filter to be used against `Destination` object types. All fields are combined with a logical ‘and.’ */
export type DestinationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `parentId` field. */
  parentId?: Maybe<UuidFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `heroMediaId` field. */
  heroMediaId?: Maybe<UuidFilter>;
  /** Filter by the object’s `destinationsByParentId` relation. */
  destinationsByParentId?: Maybe<DestinationToManyDestinationFilter>;
  /** Some related `destinationsByParentId` exist. */
  destinationsByParentIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `destinationFeatures` relation. */
  destinationFeatures?: Maybe<DestinationToManyDestinationFeatureFilter>;
  /** Some related `destinationFeatures` exist. */
  destinationFeaturesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `destinationGuides` relation. */
  destinationGuides?: Maybe<DestinationToManyDestinationGuideFilter>;
  /** Some related `destinationGuides` exist. */
  destinationGuidesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteDayDestinations` relation. */
  quoteDayDestinations?: Maybe<DestinationToManyQuoteDayDestinationFilter>;
  /** Some related `quoteDayDestinations` exist. */
  quoteDayDestinationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: Maybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `parent` relation. */
  parent?: Maybe<DestinationFilter>;
  /** A related `parent` exists. */
  parentExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** Filter by the object’s `heroMedia` relation. */
  heroMedia?: Maybe<MediaItemFilter>;
  /** A related `heroMedia` exists. */
  heroMediaExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<DestinationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<DestinationFilter>>;
  /** Negates the expression. */
  not?: Maybe<DestinationFilter>;
};

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Float']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Float']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Float']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Float']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Float']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Float']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Float']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Float']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Float']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Float']>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<DestinationFilter>;
};

/** A filter to be used against many `DestinationFeature` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyDestinationFeatureFilter = {
  /** Every related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<DestinationFeatureFilter>;
  /** Some related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<DestinationFeatureFilter>;
  /** No related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<DestinationFeatureFilter>;
};

/** A filter to be used against `DestinationFeature` object types. All fields are combined with a logical ‘and.’ */
export type DestinationFeatureFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `destinationId` field. */
  destinationId?: Maybe<UuidFilter>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `destination` relation. */
  destination?: Maybe<DestinationFilter>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: Maybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<DestinationFeatureFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<DestinationFeatureFilter>>;
  /** Negates the expression. */
  not?: Maybe<DestinationFeatureFilter>;
};

/** A filter to be used against `MediaGallery` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `parentId` field. */
  parentId?: Maybe<UuidFilter>;
  /** Filter by the object’s `isProtected` field. */
  isProtected?: Maybe<BooleanFilter>;
  /** Filter by the object’s `trips` relation. */
  trips?: Maybe<MediaGalleryToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `destinationsByGalleryId` relation. */
  destinationsByGalleryId?: Maybe<MediaGalleryToManyDestinationFilter>;
  /** Some related `destinationsByGalleryId` exist. */
  destinationsByGalleryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `destinationFeaturesByGalleryId` relation. */
  destinationFeaturesByGalleryId?: Maybe<MediaGalleryToManyDestinationFeatureFilter>;
  /** Some related `destinationFeaturesByGalleryId` exist. */
  destinationFeaturesByGalleryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `featuresByGalleryId` relation. */
  featuresByGalleryId?: Maybe<MediaGalleryToManyFeatureFilter>;
  /** Some related `featuresByGalleryId` exist. */
  featuresByGalleryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `mediaGalleriesByParentId` relation. */
  mediaGalleriesByParentId?: Maybe<MediaGalleryToManyMediaGalleryFilter>;
  /** Some related `mediaGalleriesByParentId` exist. */
  mediaGalleriesByParentIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `mediaGalleryItems` relation. */
  mediaGalleryItems?: Maybe<MediaGalleryToManyMediaGalleryItemFilter>;
  /** Some related `mediaGalleryItems` exist. */
  mediaGalleryItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `propertiesByGalleryId` relation. */
  propertiesByGalleryId?: Maybe<MediaGalleryToManyPropertyFilter>;
  /** Some related `propertiesByGalleryId` exist. */
  propertiesByGalleryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `suppliersByGalleryId` relation. */
  suppliersByGalleryId?: Maybe<MediaGalleryToManySupplierFilter>;
  /** Some related `suppliersByGalleryId` exist. */
  suppliersByGalleryIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `parent` relation. */
  parent?: Maybe<MediaGalleryFilter>;
  /** A related `parent` exists. */
  parentExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MediaGalleryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MediaGalleryFilter>>;
  /** Negates the expression. */
  not?: Maybe<MediaGalleryFilter>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFilter>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<DestinationFilter>;
};

/** A filter to be used against many `DestinationFeature` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyDestinationFeatureFilter = {
  /** Every related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<DestinationFeatureFilter>;
  /** Some related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<DestinationFeatureFilter>;
  /** No related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<DestinationFeatureFilter>;
};

/** A filter to be used against many `Feature` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyFeatureFilter = {
  /** Every related `Feature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<FeatureFilter>;
  /** Some related `Feature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<FeatureFilter>;
  /** No related `Feature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<FeatureFilter>;
};

/** A filter to be used against `Feature` object types. All fields are combined with a logical ‘and.’ */
export type FeatureFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: Maybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FeatureFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FeatureFilter>>;
  /** Negates the expression. */
  not?: Maybe<FeatureFilter>;
};

/** A filter to be used against many `MediaGallery` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyMediaGalleryFilter = {
  /** Every related `MediaGallery` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<MediaGalleryFilter>;
  /** Some related `MediaGallery` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<MediaGalleryFilter>;
  /** No related `MediaGallery` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<MediaGalleryFilter>;
};

/** A filter to be used against many `MediaGalleryItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyMediaGalleryItemFilter = {
  /** Every related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<MediaGalleryItemFilter>;
  /** Some related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<MediaGalleryItemFilter>;
  /** No related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<MediaGalleryItemFilter>;
};

/** A filter to be used against `MediaGalleryItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `mediaGalleryId` field. */
  mediaGalleryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `mediaItemId` field. */
  mediaItemId?: Maybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `isHero` field. */
  isHero?: Maybe<BooleanFilter>;
  /** Filter by the object’s `mediaGallery` relation. */
  mediaGallery?: Maybe<MediaGalleryFilter>;
  /** Filter by the object’s `mediaItem` relation. */
  mediaItem?: Maybe<MediaItemFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MediaGalleryItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MediaGalleryItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<MediaGalleryItemFilter>;
};

/** A filter to be used against `MediaItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `contentType` field. */
  contentType?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `fileName` field. */
  fileName?: Maybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: Maybe<StringFilter>;
  /** Filter by the object’s `agenciesByLogoId` relation. */
  agenciesByLogoId?: Maybe<MediaItemToManyAgencyFilter>;
  /** Some related `agenciesByLogoId` exist. */
  agenciesByLogoIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplierInvoices` relation. */
  supplierInvoices?: Maybe<MediaItemToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoices` exist. */
  supplierInvoicesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `destinationsByHeroMediaId` relation. */
  destinationsByHeroMediaId?: Maybe<MediaItemToManyDestinationFilter>;
  /** Some related `destinationsByHeroMediaId` exist. */
  destinationsByHeroMediaIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `mediaGalleryItems` relation. */
  mediaGalleryItems?: Maybe<MediaItemToManyMediaGalleryItemFilter>;
  /** Some related `mediaGalleryItems` exist. */
  mediaGalleryItemsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `propertiesByHeroMediaId` relation. */
  propertiesByHeroMediaId?: Maybe<MediaItemToManyPropertyFilter>;
  /** Some related `propertiesByHeroMediaId` exist. */
  propertiesByHeroMediaIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotesByHeroImageId` relation. */
  quotesByHeroImageId?: Maybe<MediaItemToManyQuoteFilter>;
  /** Some related `quotesByHeroImageId` exist. */
  quotesByHeroImageIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteHeroesByImageId` relation. */
  quoteHeroesByImageId?: Maybe<MediaItemToManyQuoteHeroFilter>;
  /** Some related `quoteHeroesByImageId` exist. */
  quoteHeroesByImageIdExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MediaItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MediaItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<MediaItemFilter>;
};

/** A filter to be used against many `Agency` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyAgencyFilter = {
  /** Every related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<AgencyFilter>;
  /** Some related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<AgencyFilter>;
  /** No related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<AgencyFilter>;
};

/** A filter to be used against `Agency` object types. All fields are combined with a logical ‘and.’ */
export type AgencyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `logoId` field. */
  logoId?: Maybe<UuidFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `agencyMembers` relation. */
  agencyMembers?: Maybe<AgencyToManyAgencyMemberFilter>;
  /** Some related `agencyMembers` exist. */
  agencyMembersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `trips` relation. */
  trips?: Maybe<AgencyToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `logo` relation. */
  logo?: Maybe<MediaItemFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AgencyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AgencyFilter>>;
  /** Negates the expression. */
  not?: Maybe<AgencyFilter>;
};

/** A filter to be used against many `AgencyMember` object types. All fields are combined with a logical ‘and.’ */
export type AgencyToManyAgencyMemberFilter = {
  /** Every related `AgencyMember` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<AgencyMemberFilter>;
  /** Some related `AgencyMember` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<AgencyMemberFilter>;
  /** No related `AgencyMember` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<AgencyMemberFilter>;
};

/** A filter to be used against `AgencyMember` object types. All fields are combined with a logical ‘and.’ */
export type AgencyMemberFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `skype` field. */
  skype?: Maybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `genderPreposition` field. */
  genderPreposition?: Maybe<StringFilter>;
  /** Filter by the object’s `agencyId` field. */
  agencyId?: Maybe<UuidFilter>;
  /** Filter by the object’s `trips` relation. */
  trips?: Maybe<AgencyMemberToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `agency` relation. */
  agency?: Maybe<AgencyFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AgencyMemberFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AgencyMemberFilter>>;
  /** Negates the expression. */
  not?: Maybe<AgencyMemberFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type AgencyMemberToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type AgencyToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<SupplierInvoiceFilter>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<DestinationFilter>;
};

/** A filter to be used against many `MediaGalleryItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyMediaGalleryItemFilter = {
  /** Every related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<MediaGalleryItemFilter>;
  /** Some related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<MediaGalleryItemFilter>;
  /** No related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<MediaGalleryItemFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PropertyFilter>;
};

/** A filter to be used against `Property` object types. All fields are combined with a logical ‘and.’ */
export type PropertyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: Maybe<StringFilter>;
  /** Filter by the object’s `contactNumber` field. */
  contactNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `nearestAirport` field. */
  nearestAirport?: Maybe<StringFilter>;
  /** Filter by the object’s `region` field. */
  region?: Maybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: Maybe<StringFilter>;
  /** Filter by the object’s `externalReference` field. */
  externalReference?: Maybe<StringFilter>;
  /** Filter by the object’s `url` field. */
  url?: Maybe<StringFilter>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `heroMediaId` field. */
  heroMediaId?: Maybe<UuidFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `archived` field. */
  archived?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `mapPointId` field. */
  mapPointId?: Maybe<UuidFilter>;
  /** Filter by the object’s `plusCode` field. */
  plusCode?: Maybe<StringFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `featured` field. */
  featured?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `featureCopy` field. */
  featureCopy?: Maybe<StringFilter>;
  /** Filter by the object’s `quoteAccommodationDetails` relation. */
  quoteAccommodationDetails?: Maybe<PropertyToManyQuoteAccommodationDetailFilter>;
  /** Some related `quoteAccommodationDetails` exist. */
  quoteAccommodationDetailsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteDays` relation. */
  quoteDays?: Maybe<PropertyToManyQuoteDayFilter>;
  /** Some related `quoteDays` exist. */
  quoteDaysExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: Maybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `heroMedia` relation. */
  heroMedia?: Maybe<MediaItemFilter>;
  /** A related `heroMedia` exists. */
  heroMediaExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `mapPoint` relation. */
  mapPoint?: Maybe<MapPointFilter>;
  /** A related `mapPoint` exists. */
  mapPointExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PropertyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PropertyFilter>>;
  /** Negates the expression. */
  not?: Maybe<PropertyFilter>;
};

/** A filter to be used against many `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type PropertyToManyQuoteAccommodationDetailFilter = {
  /** Every related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteAccommodationDetailFilter>;
  /** Some related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteAccommodationDetailFilter>;
  /** No related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteAccommodationDetailFilter>;
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type PropertyToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteDayFilter>;
};

/** A filter to be used against `MapPoint` object types. All fields are combined with a logical ‘and.’ */
export type MapPointFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `properties` relation. */
  properties?: Maybe<MapPointToManyPropertyFilter>;
  /** Some related `properties` exist. */
  propertiesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<MapPointFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<MapPointFilter>>;
  /** Negates the expression. */
  not?: Maybe<MapPointFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type MapPointToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PropertyFilter>;
};

/** A filter to be used against `Country` object types. All fields are combined with a logical ‘and.’ */
export type CountryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `iso2` field. */
  iso2?: Maybe<StringFilter>;
  /** Filter by the object’s `iso3` field. */
  iso3?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `airports` relation. */
  airports?: Maybe<CountryToManyAirportFilter>;
  /** Some related `airports` exist. */
  airportsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `destinations` relation. */
  destinations?: Maybe<CountryToManyDestinationFilter>;
  /** Some related `destinations` exist. */
  destinationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `passports` relation. */
  passports?: Maybe<CountryToManyPassportFilter>;
  /** Some related `passports` exist. */
  passportsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `properties` relation. */
  properties?: Maybe<CountryToManyPropertyFilter>;
  /** Some related `properties` exist. */
  propertiesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CountryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CountryFilter>>;
  /** Negates the expression. */
  not?: Maybe<CountryFilter>;
};

/** A filter to be used against many `Airport` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyAirportFilter = {
  /** Every related `Airport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<AirportFilter>;
  /** Some related `Airport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<AirportFilter>;
  /** No related `Airport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<AirportFilter>;
};

/** A filter to be used against `Airport` object types. All fields are combined with a logical ‘and.’ */
export type AirportFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `iata` field. */
  iata?: Maybe<StringFilter>;
  /** Filter by the object’s `icao` field. */
  icao?: Maybe<StringFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: Maybe<FloatFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `city` field. */
  city?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `displayName` field. */
  displayName?: Maybe<StringFilter>;
  /** Filter by the object’s `timezone` field. */
  timezone?: Maybe<StringFilter>;
  /** Filter by the object’s `tripFlightsByDepartureAirportId` relation. */
  tripFlightsByDepartureAirportId?: Maybe<AirportToManyTripFlightFilter>;
  /** Some related `tripFlightsByDepartureAirportId` exist. */
  tripFlightsByDepartureAirportIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `tripFlightsByArrivalAirportId` relation. */
  tripFlightsByArrivalAirportId?: Maybe<AirportToManyTripFlightFilter>;
  /** Some related `tripFlightsByArrivalAirportId` exist. */
  tripFlightsByArrivalAirportIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AirportFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AirportFilter>>;
  /** Negates the expression. */
  not?: Maybe<AirportFilter>;
};

/** A filter to be used against many `TripFlight` object types. All fields are combined with a logical ‘and.’ */
export type AirportToManyTripFlightFilter = {
  /** Every related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFlightFilter>;
  /** Some related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFlightFilter>;
  /** No related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFlightFilter>;
};

/** A filter to be used against `TripFlight` object types. All fields are combined with a logical ‘and.’ */
export type TripFlightFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `arrival` field. */
  arrival?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `carrier` field. */
  carrier?: Maybe<StringFilter>;
  /** Filter by the object’s `departure` field. */
  departure?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `number` field. */
  number?: Maybe<StringFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `departureAirportId` field. */
  departureAirportId?: Maybe<UuidFilter>;
  /** Filter by the object’s `arrivalAirportId` field. */
  arrivalAirportId?: Maybe<UuidFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** Filter by the object’s `departureAirport` relation. */
  departureAirport?: Maybe<AirportFilter>;
  /** A related `departureAirport` exists. */
  departureAirportExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `arrivalAirport` relation. */
  arrivalAirport?: Maybe<AirportFilter>;
  /** A related `arrivalAirport` exists. */
  arrivalAirportExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TripFlightFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TripFlightFilter>>;
  /** Negates the expression. */
  not?: Maybe<TripFlightFilter>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<DestinationFilter>;
};

/** A filter to be used against many `Passport` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyPassportFilter = {
  /** Every related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PassportFilter>;
  /** Some related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PassportFilter>;
  /** No related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PassportFilter>;
};

/** A filter to be used against `Passport` object types. All fields are combined with a logical ‘and.’ */
export type PassportFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `countryOfIssue` field. */
  countryOfIssue?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `expiry` field. */
  expiry?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `number` field. */
  number?: Maybe<StringFilter>;
  /** Filter by the object’s `travellerId` field. */
  travellerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: Maybe<UuidFilter>;
  /** Filter by the object’s `traveller` relation. */
  traveller?: Maybe<TravellerFilter>;
  /** Filter by the object’s `country` relation. */
  country?: Maybe<CountryFilter>;
  /** A related `country` exists. */
  countryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PassportFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PassportFilter>>;
  /** Negates the expression. */
  not?: Maybe<PassportFilter>;
};

/** A filter to be used against `Traveller` object types. All fields are combined with a logical ‘and.’ */
export type TravellerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `dietaryRequirements` field. */
  dietaryRequirements?: Maybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `height` field. */
  height?: Maybe<IntFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `medicalConditions` field. */
  medicalConditions?: Maybe<StringFilter>;
  /** Filter by the object’s `middleName` field. */
  middleName?: Maybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `nationality` field. */
  nationality?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `weight` field. */
  weight?: Maybe<IntFilter>;
  /** Filter by the object’s `emergencyContact` field. */
  emergencyContact?: Maybe<StringFilter>;
  /** Filter by the object’s `insuranceDetails` field. */
  insuranceDetails?: Maybe<StringFilter>;
  /** Filter by the object’s `customerTravellers` relation. */
  customerTravellers?: Maybe<TravellerToManyCustomerTravellerFilter>;
  /** Some related `customerTravellers` exist. */
  customerTravellersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `passports` relation. */
  passports?: Maybe<TravellerToManyPassportFilter>;
  /** Some related `passports` exist. */
  passportsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `tripTravellers` relation. */
  tripTravellers?: Maybe<TravellerToManyTripTravellerFilter>;
  /** Some related `tripTravellers` exist. */
  tripTravellersExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TravellerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TravellerFilter>>;
  /** Negates the expression. */
  not?: Maybe<TravellerFilter>;
};

/** A filter to be used against many `CustomerTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TravellerToManyCustomerTravellerFilter = {
  /** Every related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerTravellerFilter>;
  /** Some related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerTravellerFilter>;
  /** No related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerTravellerFilter>;
};

/** A filter to be used against `CustomerTraveller` object types. All fields are combined with a logical ‘and.’ */
export type CustomerTravellerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `travellerId` field. */
  travellerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** Filter by the object’s `traveller` relation. */
  traveller?: Maybe<TravellerFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerTravellerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerTravellerFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerTravellerFilter>;
};

/** A filter to be used against `Customer` object types. All fields are combined with a logical ‘and.’ */
export type CustomerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: Maybe<StringFilter>;
  /** Filter by the object’s `customerTravellers` relation. */
  customerTravellers?: Maybe<CustomerToManyCustomerTravellerFilter>;
  /** Some related `customerTravellers` exist. */
  customerTravellersExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `trips` relation. */
  trips?: Maybe<CustomerToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `emails` relation. */
  emails?: Maybe<CustomerToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `enquiries` relation. */
  enquiries?: Maybe<CustomerToManyEnquiryFilter>;
  /** Some related `enquiries` exist. */
  enquiriesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CustomerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CustomerFilter>>;
  /** Negates the expression. */
  not?: Maybe<CustomerFilter>;
};

/** A filter to be used against many `CustomerTraveller` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyCustomerTravellerFilter = {
  /** Every related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<CustomerTravellerFilter>;
  /** Some related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<CustomerTravellerFilter>;
  /** No related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<CustomerTravellerFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFilter>;
};

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<EmailFilter>;
};

/** A filter to be used against many `Enquiry` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyEnquiryFilter = {
  /** Every related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<EnquiryFilter>;
  /** Some related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<EnquiryFilter>;
  /** No related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<EnquiryFilter>;
};

/** A filter to be used against `Enquiry` object types. All fields are combined with a logical ‘and.’ */
export type EnquiryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `comments` field. */
  comments?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `dates` field. */
  dates?: Maybe<StringFilter>;
  /** Filter by the object’s `destination` field. */
  destination?: Maybe<StringFilter>;
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `travellers` field. */
  travellers?: Maybe<StringFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `archived` field. */
  archived?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: Maybe<CustomerFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EnquiryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EnquiryFilter>>;
  /** Negates the expression. */
  not?: Maybe<EnquiryFilter>;
};

/** A filter to be used against many `Passport` object types. All fields are combined with a logical ‘and.’ */
export type TravellerToManyPassportFilter = {
  /** Every related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PassportFilter>;
  /** Some related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PassportFilter>;
  /** No related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PassportFilter>;
};

/** A filter to be used against many `TripTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TravellerToManyTripTravellerFilter = {
  /** Every related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripTravellerFilter>;
  /** Some related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripTravellerFilter>;
  /** No related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripTravellerFilter>;
};

/** A filter to be used against `TripTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TripTravellerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `travellerId` field. */
  travellerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `traveller` relation. */
  traveller?: Maybe<TravellerFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TripTravellerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TripTravellerFilter>>;
  /** Negates the expression. */
  not?: Maybe<TripTravellerFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PropertyFilter>;
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteFilter>;
};

/** A filter to be used against many `QuoteHero` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyQuoteHeroFilter = {
  /** Every related `QuoteHero` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteHeroFilter>;
  /** Some related `QuoteHero` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteHeroFilter>;
  /** No related `QuoteHero` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteHeroFilter>;
};

/** A filter to be used against `QuoteHero` object types. All fields are combined with a logical ‘and.’ */
export type QuoteHeroFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `subtitle` field. */
  subtitle?: Maybe<StringFilter>;
  /** Filter by the object’s `imageId` field. */
  imageId?: Maybe<UuidFilter>;
  /** Filter by the object’s `style` field. */
  style?: Maybe<StringFilter>;
  /** Filter by the object’s `quotesByHeroId` relation. */
  quotesByHeroId?: Maybe<QuoteHeroToManyQuoteFilter>;
  /** Some related `quotesByHeroId` exist. */
  quotesByHeroIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quotePublicsByHeroId` relation. */
  quotePublicsByHeroId?: Maybe<QuoteHeroToManyQuotePublicFilter>;
  /** Some related `quotePublicsByHeroId` exist. */
  quotePublicsByHeroIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `image` relation. */
  image?: Maybe<MediaItemFilter>;
  /** A related `image` exists. */
  imageExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteHeroFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteHeroFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteHeroFilter>;
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type QuoteHeroToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteFilter>;
};

/** A filter to be used against many `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type QuoteHeroToManyQuotePublicFilter = {
  /** Every related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuotePublicFilter>;
  /** Some related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuotePublicFilter>;
  /** No related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuotePublicFilter>;
};

/** A filter to be used against `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type QuotePublicFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `key` field. */
  key?: Maybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `start` field. */
  start?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: Maybe<IntFilter>;
  /** Filter by the object’s `travellerCount` field. */
  travellerCount?: Maybe<IntFilter>;
  /** Filter by the object’s `total` field. */
  total?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `heroId` field. */
  heroId?: Maybe<UuidFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `baseCurrency` field. */
  baseCurrency?: Maybe<StringFilter>;
  /** Filter by the object’s `inclusions` field. */
  inclusions?: Maybe<StringFilter>;
  /** Filter by the object’s `exclusions` field. */
  exclusions?: Maybe<StringFilter>;
  /** Filter by the object’s `expires` field. */
  expires?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<UuidFilter>;
  /** Filter by the object’s `quoteAccommodationDetailsByQuoteId` relation. */
  quoteAccommodationDetailsByQuoteId?: Maybe<QuotePublicToManyQuoteAccommodationDetailFilter>;
  /** Some related `quoteAccommodationDetailsByQuoteId` exist. */
  quoteAccommodationDetailsByQuoteIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `quoteDaysByQuoteId` relation. */
  quoteDaysByQuoteId?: Maybe<QuotePublicToManyQuoteDayFilter>;
  /** Some related `quoteDaysByQuoteId` exist. */
  quoteDaysByQuoteIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `hero` relation. */
  hero?: Maybe<QuoteHeroFilter>;
  /** A related `hero` exists. */
  heroExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuotePublicFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuotePublicFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuotePublicFilter>;
};

/** A filter to be used against many `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type QuotePublicToManyQuoteAccommodationDetailFilter = {
  /** Every related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteAccommodationDetailFilter>;
  /** Some related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteAccommodationDetailFilter>;
  /** No related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteAccommodationDetailFilter>;
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuotePublicToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteDayFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PropertyFilter>;
};

/** A filter to be used against many `Supplier` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManySupplierFilter = {
  /** Every related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<SupplierFilter>;
  /** Some related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<SupplierFilter>;
  /** No related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<SupplierFilter>;
};

/** A filter to be used against many `DestinationGuide` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyDestinationGuideFilter = {
  /** Every related `DestinationGuide` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<DestinationGuideFilter>;
  /** Some related `DestinationGuide` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<DestinationGuideFilter>;
  /** No related `DestinationGuide` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<DestinationGuideFilter>;
};

/** A filter to be used against `DestinationGuide` object types. All fields are combined with a logical ‘and.’ */
export type DestinationGuideFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `destinationId` field. */
  destinationId?: Maybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `destination` relation. */
  destination?: Maybe<DestinationFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<DestinationGuideFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<DestinationGuideFilter>>;
  /** Negates the expression. */
  not?: Maybe<DestinationGuideFilter>;
};

/** A filter to be used against many `QuoteDayDestination` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyQuoteDayDestinationFilter = {
  /** Every related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteDayDestinationFilter>;
  /** Some related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteDayDestinationFilter>;
  /** No related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteDayDestinationFilter>;
};

/** A filter to be used against many `QuoteCurrency` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteCurrencyFilter = {
  /** Every related `QuoteCurrency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteCurrencyFilter>;
  /** Some related `QuoteCurrency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteCurrencyFilter>;
  /** No related `QuoteCurrency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteCurrencyFilter>;
};

/** A filter to be used against `QuoteCurrency` object types. All fields are combined with a logical ‘and.’ */
export type QuoteCurrencyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `rate` field. */
  rate?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `quote` relation. */
  quote?: Maybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteCurrencyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteCurrencyFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteCurrencyFilter>;
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteDayFilter>;
};

/** A filter to be used against many `QuoteFinanceLineItem` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteFinanceLineItemFilter = {
  /** Every related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteFinanceLineItemFilter>;
  /** Some related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteFinanceLineItemFilter>;
  /** No related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteFinanceLineItemFilter>;
};

/** A filter to be used against `QuoteFinanceLineItem` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFinanceLineItemFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `supplierId` field. */
  supplierId?: Maybe<UuidFilter>;
  /** Filter by the object’s `confirmation` field. */
  confirmation?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `excludeMargin` field. */
  excludeMargin?: Maybe<BooleanFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: Maybe<IntFilter>;
  /** Filter by the object’s `order` field. */
  order?: Maybe<IntFilter>;
  /** Filter by the object’s `marginOverride` field. */
  marginOverride?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `quote` relation. */
  quote?: Maybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `supplier` relation. */
  supplier?: Maybe<SupplierFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteFinanceLineItemFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteFinanceLineItemFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteFinanceLineItemFilter>;
};

/** A filter to be used against many `Reminder` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReminderFilter = {
  /** Every related `Reminder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReminderFilter>;
  /** Some related `Reminder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReminderFilter>;
  /** No related `Reminder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReminderFilter>;
};

/** A filter to be used against `Reminder` object types. All fields are combined with a logical ‘and.’ */
export type ReminderFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReminderFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReminderFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReminderFilter>;
};

/** A filter to be used against many `TransactionNote` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyTransactionNoteFilter = {
  /** Every related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionNoteFilter>;
  /** Some related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionNoteFilter>;
  /** No related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionNoteFilter>;
};

/** A filter to be used against `TransactionNote` object types. All fields are combined with a logical ‘and.’ */
export type TransactionNoteFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<UuidFilter>;
  /** Filter by the object’s `message` field. */
  message?: Maybe<StringFilter>;
  /** Filter by the object’s `transactionId` field. */
  transactionId?: Maybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** Filter by the object’s `transaction` relation. */
  transaction?: Maybe<TransactionFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TransactionNoteFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TransactionNoteFilter>>;
  /** Negates the expression. */
  not?: Maybe<TransactionNoteFilter>;
};

/** A filter to be used against many `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyQuotePublicFilter = {
  /** Every related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuotePublicFilter>;
  /** Some related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuotePublicFilter>;
  /** No related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuotePublicFilter>;
};

/** A filter to be used against many `Enquiry` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyEnquiryFilter = {
  /** Every related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<EnquiryFilter>;
  /** Some related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<EnquiryFilter>;
  /** No related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<EnquiryFilter>;
};

/** A filter to be used against many `Note` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyNoteFilter = {
  /** Every related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<NoteFilter>;
  /** Some related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<NoteFilter>;
  /** No related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<NoteFilter>;
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteFilter>;
};

/** A filter to be used against many `Testimonial` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyTestimonialFilter = {
  /** Every related `Testimonial` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TestimonialFilter>;
  /** Some related `Testimonial` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TestimonialFilter>;
  /** No related `Testimonial` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TestimonialFilter>;
};

/** A filter to be used against `Testimonial` object types. All fields are combined with a logical ‘and.’ */
export type TestimonialFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `body` field. */
  body?: Maybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `guestName` field. */
  guestName?: Maybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: Maybe<UuidFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: Maybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TestimonialFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TestimonialFilter>>;
  /** Negates the expression. */
  not?: Maybe<TestimonialFilter>;
};

/** A filter to be used against many `TripTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyTripTravellerFilter = {
  /** Every related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripTravellerFilter>;
  /** Some related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripTravellerFilter>;
  /** No related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripTravellerFilter>;
};

/** A filter to be used against many `TripFlight` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyTripFlightFilter = {
  /** Every related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TripFlightFilter>;
  /** Some related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TripFlightFilter>;
  /** No related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TripFlightFilter>;
};

/** A filter to be used against many `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyQuotePublicFilter = {
  /** Every related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuotePublicFilter>;
  /** Some related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuotePublicFilter>;
  /** No related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuotePublicFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<SupplierInvoiceFilter>;
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionFilter>;
};

/** A filter to be used against many `QuoteFinanceLineItem` object types. All fields are combined with a logical ‘and.’ */
export type SupplierToManyQuoteFinanceLineItemFilter = {
  /** Every related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<QuoteFinanceLineItemFilter>;
  /** Some related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<QuoteFinanceLineItemFilter>;
  /** No related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<QuoteFinanceLineItemFilter>;
};

/** A filter to be used against many `Payment` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceToManyPaymentFilter = {
  /** Every related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PaymentFilter>;
  /** Some related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PaymentFilter>;
  /** No related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PaymentFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionLinkFilter>;
};

/** A filter to be used against many `TransactionNote` object types. All fields are combined with a logical ‘and.’ */
export type TransactionToManyTransactionNoteFilter = {
  /** Every related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionNoteFilter>;
  /** Some related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionNoteFilter>;
  /** No related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionNoteFilter>;
};

/** A filter to be used against `TransactionImportBatch` object types. All fields are combined with a logical ‘and.’ */
export type TransactionImportBatchFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `accountId` field. */
  accountId?: Maybe<UuidFilter>;
  /** Filter by the object’s `dateRangeMin` field. */
  dateRangeMin?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `dateRangeMax` field. */
  dateRangeMax?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `key` field. */
  key?: Maybe<StringFilter>;
  /** Filter by the object’s `transactions` relation. */
  transactions?: Maybe<TransactionImportBatchToManyTransactionFilter>;
  /** Some related `transactions` exist. */
  transactionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `account` relation. */
  account?: Maybe<AccountFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TransactionImportBatchFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TransactionImportBatchFilter>>;
  /** Negates the expression. */
  not?: Maybe<TransactionImportBatchFilter>;
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type TransactionImportBatchToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionFilter>;
};

/** A filter to be used against many `TransactionImportBatch` object types. All fields are combined with a logical ‘and.’ */
export type AccountToManyTransactionImportBatchFilter = {
  /** Every related `TransactionImportBatch` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TransactionImportBatchFilter>;
  /** Some related `TransactionImportBatch` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TransactionImportBatchFilter>;
  /** No related `TransactionImportBatch` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TransactionImportBatchFilter>;
};

/** A connection to a list of `Account` values. */
export type AccountsConnection = {
  __typename?: 'AccountsConnection';
  /** A list of `Account` objects. */
  nodes: Array<Maybe<Account>>;
  /** A list of edges which contains the `Account` and cursor to aid in pagination. */
  edges: Array<AccountsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Account` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Account = Node & {
  __typename?: 'Account';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  institution?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactions: TransactionsConnection;
  /** Reads and enables pagination through a set of `TransactionImportBatch`. */
  transactionImportBatches: TransactionImportBatchesConnection;
};


export type AccountTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
  condition?: Maybe<TransactionCondition>;
  filter?: Maybe<TransactionFilter>;
};


export type AccountTransactionImportBatchesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionImportBatchesOrderBy>>;
  condition?: Maybe<TransactionImportBatchCondition>;
  filter?: Maybe<TransactionImportBatchFilter>;
};

/** Methods to use when ordering `Transaction`. */
export enum TransactionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  AccountIdAsc = 'ACCOUNT_ID_ASC',
  AccountIdDesc = 'ACCOUNT_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  ReverseTransactionIdAsc = 'REVERSE_TRANSACTION_ID_ASC',
  ReverseTransactionIdDesc = 'REVERSE_TRANSACTION_ID_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC',
  TransactionImportBatchIdAsc = 'TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionImportBatchIdDesc = 'TRANSACTION_IMPORT_BATCH_ID_DESC',
  BalanceAsc = 'BALANCE_ASC',
  BalanceDesc = 'BALANCE_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  AccountByAccountIdIdAsc = 'ACCOUNT_BY_ACCOUNT_ID__ID_ASC',
  AccountByAccountIdIdDesc = 'ACCOUNT_BY_ACCOUNT_ID__ID_DESC',
  AccountByAccountIdCreatedAsc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_ASC',
  AccountByAccountIdCreatedDesc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_DESC',
  AccountByAccountIdModifiedAsc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_ASC',
  AccountByAccountIdModifiedDesc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_DESC',
  AccountByAccountIdNameAsc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_ASC',
  AccountByAccountIdNameDesc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_DESC',
  AccountByAccountIdInstitutionAsc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_ASC',
  AccountByAccountIdInstitutionDesc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_DESC',
  AccountByAccountIdDetailsAsc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_ASC',
  AccountByAccountIdDetailsDesc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_DESC',
  TransactionByReverseTransactionIdIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ID_ASC',
  TransactionByReverseTransactionIdIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ID_DESC',
  TransactionByReverseTransactionIdCreatedAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CREATED_ASC',
  TransactionByReverseTransactionIdCreatedDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CREATED_DESC',
  TransactionByReverseTransactionIdModifiedAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__MODIFIED_ASC',
  TransactionByReverseTransactionIdModifiedDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__MODIFIED_DESC',
  TransactionByReverseTransactionIdAccountIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ACCOUNT_ID_ASC',
  TransactionByReverseTransactionIdAccountIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ACCOUNT_ID_DESC',
  TransactionByReverseTransactionIdAmountAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__AMOUNT_ASC',
  TransactionByReverseTransactionIdAmountDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__AMOUNT_DESC',
  TransactionByReverseTransactionIdExternalIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__EXTERNAL_ID_ASC',
  TransactionByReverseTransactionIdExternalIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__EXTERNAL_ID_DESC',
  TransactionByReverseTransactionIdDateAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DATE_ASC',
  TransactionByReverseTransactionIdDateDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DATE_DESC',
  TransactionByReverseTransactionIdDescriptionAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DESCRIPTION_ASC',
  TransactionByReverseTransactionIdDescriptionDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DESCRIPTION_DESC',
  TransactionByReverseTransactionIdStatusAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__STATUS_ASC',
  TransactionByReverseTransactionIdStatusDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__STATUS_DESC',
  TransactionByReverseTransactionIdReverseTransactionIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__REVERSE_TRANSACTION_ID_ASC',
  TransactionByReverseTransactionIdReverseTransactionIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__REVERSE_TRANSACTION_ID_DESC',
  TransactionByReverseTransactionIdSourceAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__SOURCE_ASC',
  TransactionByReverseTransactionIdSourceDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__SOURCE_DESC',
  TransactionByReverseTransactionIdTransactionImportBatchIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionByReverseTransactionIdTransactionImportBatchIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_DESC',
  TransactionByReverseTransactionIdBalanceAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__BALANCE_ASC',
  TransactionByReverseTransactionIdBalanceDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__BALANCE_DESC',
  TransactionByReverseTransactionIdCurrencyAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CURRENCY_ASC',
  TransactionByReverseTransactionIdCurrencyDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CURRENCY_DESC',
  TransactionByReverseTransactionIdCategoryIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CATEGORY_ID_ASC',
  TransactionByReverseTransactionIdCategoryIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CATEGORY_ID_DESC',
  TransactionImportBatchByTransactionImportBatchIdIdAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ID_ASC',
  TransactionImportBatchByTransactionImportBatchIdIdDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ID_DESC',
  TransactionImportBatchByTransactionImportBatchIdCreatedAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__CREATED_ASC',
  TransactionImportBatchByTransactionImportBatchIdCreatedDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__CREATED_DESC',
  TransactionImportBatchByTransactionImportBatchIdModifiedAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__MODIFIED_ASC',
  TransactionImportBatchByTransactionImportBatchIdModifiedDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__MODIFIED_DESC',
  TransactionImportBatchByTransactionImportBatchIdAccountIdAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ACCOUNT_ID_ASC',
  TransactionImportBatchByTransactionImportBatchIdAccountIdDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ACCOUNT_ID_DESC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMinAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MIN_ASC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMinDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MIN_DESC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMaxAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MAX_ASC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMaxDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MAX_DESC',
  TransactionImportBatchByTransactionImportBatchIdKeyAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__KEY_ASC',
  TransactionImportBatchByTransactionImportBatchIdKeyDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__KEY_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  TransactionsByReverseTransactionIdCountAsc = 'TRANSACTIONS_BY_REVERSE_TRANSACTION_ID__COUNT_ASC',
  TransactionsByReverseTransactionIdCountDesc = 'TRANSACTIONS_BY_REVERSE_TRANSACTION_ID__COUNT_DESC',
  TransactionLinksByTransactionIdCountAsc = 'TRANSACTION_LINKS_BY_TRANSACTION_ID__COUNT_ASC',
  TransactionLinksByTransactionIdCountDesc = 'TRANSACTION_LINKS_BY_TRANSACTION_ID__COUNT_DESC',
  TransactionNotesByTransactionIdCountAsc = 'TRANSACTION_NOTES_BY_TRANSACTION_ID__COUNT_ASC',
  TransactionNotesByTransactionIdCountDesc = 'TRANSACTION_NOTES_BY_TRANSACTION_ID__COUNT_DESC'
}

/** A condition to be used against `Transaction` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TransactionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `accountId` field. */
  accountId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reverseTransactionId` field. */
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `balance` field. */
  balance?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Transaction` values. */
export type TransactionsConnection = {
  __typename?: 'TransactionsConnection';
  /** A list of `Transaction` objects. */
  nodes: Array<Maybe<Transaction>>;
  /** A list of edges which contains the `Transaction` and cursor to aid in pagination. */
  edges: Array<TransactionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Transaction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Transaction = Node & {
  __typename?: 'Transaction';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  accountId: Scalars['UUID'];
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance: Scalars['BigFloat'];
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactionsByReverseTransactionId: TransactionsConnection;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
  /** Reads and enables pagination through a set of `TransactionNote`. */
  transactionNotes: TransactionNotesConnection;
};


export type TransactionTransactionsByReverseTransactionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
  condition?: Maybe<TransactionCondition>;
  filter?: Maybe<TransactionFilter>;
};


export type TransactionTransactionLinksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
  condition?: Maybe<TransactionLinkCondition>;
  filter?: Maybe<TransactionLinkFilter>;
};


export type TransactionTransactionNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionNotesOrderBy>>;
  condition?: Maybe<TransactionNoteCondition>;
  filter?: Maybe<TransactionNoteFilter>;
};

export type TransactionImportBatch = Node & {
  __typename?: 'TransactionImportBatch';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  accountId: Scalars['UUID'];
  dateRangeMin: Scalars['Datetime'];
  dateRangeMax: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactions: TransactionsConnection;
};


export type TransactionImportBatchTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
  condition?: Maybe<TransactionCondition>;
  filter?: Maybe<TransactionFilter>;
};

export type FinanceCategory = Node & {
  __typename?: 'FinanceCategory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type: Scalars['Int'];
  code?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Expense`. */
  expensesByCategoryId: ExpensesConnection;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoicesByCategoryId: InvoicesConnection;
  /** Reads and enables pagination through a set of `Payment`. */
  paymentsByCategoryId: PaymentsConnection;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoicesByCategoryId: SupplierInvoicesConnection;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactionsByCategoryId: TransactionsConnection;
};


export type FinanceCategoryExpensesByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
  condition?: Maybe<ExpenseCondition>;
  filter?: Maybe<ExpenseFilter>;
};


export type FinanceCategoryInvoicesByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
  condition?: Maybe<InvoiceCondition>;
  filter?: Maybe<InvoiceFilter>;
};


export type FinanceCategoryPaymentsByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
  condition?: Maybe<PaymentCondition>;
  filter?: Maybe<PaymentFilter>;
};


export type FinanceCategorySupplierInvoicesByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
  condition?: Maybe<SupplierInvoiceCondition>;
  filter?: Maybe<SupplierInvoiceFilter>;
};


export type FinanceCategoryTransactionsByCategoryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
  condition?: Maybe<TransactionCondition>;
  filter?: Maybe<TransactionFilter>;
};

/** Methods to use when ordering `Expense`. */
export enum ExpensesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AmountActualAsc = 'AMOUNT_ACTUAL_ASC',
  AmountActualDesc = 'AMOUNT_ACTUAL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  SupplierIdAsc = 'SUPPLIER_ID_ASC',
  SupplierIdDesc = 'SUPPLIER_ID_DESC',
  ReferenceAsc = 'REFERENCE_ASC',
  ReferenceDesc = 'REFERENCE_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  SupplierInvoiceIdAsc = 'SUPPLIER_INVOICE_ID_ASC',
  SupplierInvoiceIdDesc = 'SUPPLIER_INVOICE_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  InvoiceByInvoiceIdIdAsc = 'INVOICE_BY_INVOICE_ID__ID_ASC',
  InvoiceByInvoiceIdIdDesc = 'INVOICE_BY_INVOICE_ID__ID_DESC',
  InvoiceByInvoiceIdAmountAsc = 'INVOICE_BY_INVOICE_ID__AMOUNT_ASC',
  InvoiceByInvoiceIdAmountDesc = 'INVOICE_BY_INVOICE_ID__AMOUNT_DESC',
  InvoiceByInvoiceIdCreatedAsc = 'INVOICE_BY_INVOICE_ID__CREATED_ASC',
  InvoiceByInvoiceIdCreatedDesc = 'INVOICE_BY_INVOICE_ID__CREATED_DESC',
  InvoiceByInvoiceIdCurrencyAsc = 'INVOICE_BY_INVOICE_ID__CURRENCY_ASC',
  InvoiceByInvoiceIdCurrencyDesc = 'INVOICE_BY_INVOICE_ID__CURRENCY_DESC',
  InvoiceByInvoiceIdDueAsc = 'INVOICE_BY_INVOICE_ID__DUE_ASC',
  InvoiceByInvoiceIdDueDesc = 'INVOICE_BY_INVOICE_ID__DUE_DESC',
  InvoiceByInvoiceIdKeyAsc = 'INVOICE_BY_INVOICE_ID__KEY_ASC',
  InvoiceByInvoiceIdKeyDesc = 'INVOICE_BY_INVOICE_ID__KEY_DESC',
  InvoiceByInvoiceIdModifiedAsc = 'INVOICE_BY_INVOICE_ID__MODIFIED_ASC',
  InvoiceByInvoiceIdModifiedDesc = 'INVOICE_BY_INVOICE_ID__MODIFIED_DESC',
  InvoiceByInvoiceIdSummaryAsc = 'INVOICE_BY_INVOICE_ID__SUMMARY_ASC',
  InvoiceByInvoiceIdSummaryDesc = 'INVOICE_BY_INVOICE_ID__SUMMARY_DESC',
  InvoiceByInvoiceIdTypeAsc = 'INVOICE_BY_INVOICE_ID__TYPE_ASC',
  InvoiceByInvoiceIdTypeDesc = 'INVOICE_BY_INVOICE_ID__TYPE_DESC',
  InvoiceByInvoiceIdNumberAsc = 'INVOICE_BY_INVOICE_ID__NUMBER_ASC',
  InvoiceByInvoiceIdNumberDesc = 'INVOICE_BY_INVOICE_ID__NUMBER_DESC',
  InvoiceByInvoiceIdQuoteIdAsc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_ASC',
  InvoiceByInvoiceIdQuoteIdDesc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_DESC',
  InvoiceByInvoiceIdVoidedAsc = 'INVOICE_BY_INVOICE_ID__VOIDED_ASC',
  InvoiceByInvoiceIdVoidedDesc = 'INVOICE_BY_INVOICE_ID__VOIDED_DESC',
  InvoiceByInvoiceIdCategoryIdAsc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_ASC',
  InvoiceByInvoiceIdCategoryIdDesc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_DESC',
  InvoiceByInvoiceIdTripIdAsc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_ASC',
  InvoiceByInvoiceIdTripIdDesc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_DESC',
  InvoiceByInvoiceIdPaidAsc = 'INVOICE_BY_INVOICE_ID__PAID_ASC',
  InvoiceByInvoiceIdPaidDesc = 'INVOICE_BY_INVOICE_ID__PAID_DESC',
  InvoiceByInvoiceIdNoteAsc = 'INVOICE_BY_INVOICE_ID__NOTE_ASC',
  InvoiceByInvoiceIdNoteDesc = 'INVOICE_BY_INVOICE_ID__NOTE_DESC',
  InvoiceByInvoiceIdInvoicedAsc = 'INVOICE_BY_INVOICE_ID__INVOICED_ASC',
  InvoiceByInvoiceIdInvoicedDesc = 'INVOICE_BY_INVOICE_ID__INVOICED_DESC',
  InvoiceByInvoiceIdLockedAsc = 'INVOICE_BY_INVOICE_ID__LOCKED_ASC',
  InvoiceByInvoiceIdLockedDesc = 'INVOICE_BY_INVOICE_ID__LOCKED_DESC',
  SupplierBySupplierIdIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__ID_ASC',
  SupplierBySupplierIdIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__ID_DESC',
  SupplierBySupplierIdCreatedAsc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_ASC',
  SupplierBySupplierIdCreatedDesc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_DESC',
  SupplierBySupplierIdModifiedAsc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_ASC',
  SupplierBySupplierIdModifiedDesc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_DESC',
  SupplierBySupplierIdNameAsc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_ASC',
  SupplierBySupplierIdNameDesc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_DESC',
  SupplierBySupplierIdContactEmailAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_ASC',
  SupplierBySupplierIdContactEmailDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_DESC',
  SupplierBySupplierIdContactNumberAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_ASC',
  SupplierBySupplierIdContactNumberDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_DESC',
  SupplierBySupplierIdRegionAsc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_ASC',
  SupplierBySupplierIdRegionDesc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_DESC',
  SupplierBySupplierIdUrlAsc = 'SUPPLIER_BY_SUPPLIER_ID__URL_ASC',
  SupplierBySupplierIdUrlDesc = 'SUPPLIER_BY_SUPPLIER_ID__URL_DESC',
  SupplierBySupplierIdBankDetailsAsc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_ASC',
  SupplierBySupplierIdBankDetailsDesc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_DESC',
  SupplierBySupplierIdGalleryIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_ASC',
  SupplierBySupplierIdGalleryIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  SupplierInvoiceBySupplierInvoiceIdIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_DESC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdCreatedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_ASC',
  SupplierInvoiceBySupplierInvoiceIdCreatedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_DESC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_ASC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_DESC',
  SupplierInvoiceBySupplierInvoiceIdDueAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_ASC',
  SupplierInvoiceBySupplierInvoiceIdDueDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_DESC',
  SupplierInvoiceBySupplierInvoiceIdKeyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_ASC',
  SupplierInvoiceBySupplierInvoiceIdKeyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_DESC',
  SupplierInvoiceBySupplierInvoiceIdModifiedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_ASC',
  SupplierInvoiceBySupplierInvoiceIdModifiedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_DESC',
  SupplierInvoiceBySupplierInvoiceIdNumberAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_ASC',
  SupplierInvoiceBySupplierInvoiceIdNumberDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_DESC',
  SupplierInvoiceBySupplierInvoiceIdSummaryAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_ASC',
  SupplierInvoiceBySupplierInvoiceIdSummaryDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_DESC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTripIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdTripIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTypeAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_ASC',
  SupplierInvoiceBySupplierInvoiceIdTypeDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_DESC',
  SupplierInvoiceBySupplierInvoiceIdVoidedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_ASC',
  SupplierInvoiceBySupplierInvoiceIdVoidedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_DESC',
  SupplierInvoiceBySupplierInvoiceIdPaidAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_ASC',
  SupplierInvoiceBySupplierInvoiceIdPaidDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_DESC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TransactionLinksByExpenseIdCountAsc = 'TRANSACTION_LINKS_BY_EXPENSE_ID__COUNT_ASC',
  TransactionLinksByExpenseIdCountDesc = 'TRANSACTION_LINKS_BY_EXPENSE_ID__COUNT_DESC'
}

/** A condition to be used against `Expense` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ExpenseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `amountActual` field. */
  amountActual?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `supplierId` field. */
  supplierId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `reference` field. */
  reference?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Expense` values. */
export type ExpensesConnection = {
  __typename?: 'ExpensesConnection';
  /** A list of `Expense` objects. */
  nodes: Array<Maybe<Expense>>;
  /** A list of edges which contains the `Expense` and cursor to aid in pagination. */
  edges: Array<ExpensesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Expense` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Expense = Node & {
  __typename?: 'Expense';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created: Scalars['Datetime'];
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified: Scalars['Datetime'];
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  supplierId: Scalars['UUID'];
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
};


export type ExpenseTransactionLinksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
  condition?: Maybe<TransactionLinkCondition>;
  filter?: Maybe<TransactionLinkFilter>;
};

export type Invoice = Node & {
  __typename?: 'Invoice';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  amount: Scalars['BigFloat'];
  created: Scalars['Datetime'];
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number: Scalars['Int'];
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced: Scalars['Datetime'];
  locked?: Maybe<Scalars['Datetime']>;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  /** Reads and enables pagination through a set of `Payment`. */
  payments: PaymentsConnection;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
};


export type InvoiceExpensesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
  condition?: Maybe<ExpenseCondition>;
  filter?: Maybe<ExpenseFilter>;
};


export type InvoicePaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
  condition?: Maybe<PaymentCondition>;
  filter?: Maybe<PaymentFilter>;
};


export type InvoiceTransactionLinksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
  condition?: Maybe<TransactionLinkCondition>;
  filter?: Maybe<TransactionLinkFilter>;
};

export type Quote = Node & {
  __typename?: 'Quote';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  duration: Scalars['Int'];
  modified: Scalars['Datetime'];
  start?: Maybe<Scalars['Datetime']>;
  tripId: Scalars['UUID'];
  deposit: Scalars['BigFloat'];
  margin: Scalars['BigFloat'];
  key?: Maybe<Scalars['String']>;
  expires: Scalars['Datetime'];
  total: Scalars['BigFloat'];
  adjustment: Scalars['BigFloat'];
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  agentMargin: Scalars['BigFloat'];
  travellerCount: Scalars['Int'];
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  /** Reads and enables pagination through a set of `Trip`. */
  tripsByActiveQuoteId: TripsConnection;
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  /** Reads and enables pagination through a set of `QuoteView`. */
  quoteViews: QuoteViewsConnection;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetails: QuoteAccommodationDetailsConnection;
  /** Reads and enables pagination through a set of `QuoteCurrency`. */
  quoteCurrencies: QuoteCurrenciesConnection;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDays: QuoteDaysConnection;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItem`. */
  quoteFinanceLineItems: QuoteFinanceLineItemsConnection;
};


export type QuoteInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
  condition?: Maybe<InvoiceCondition>;
  filter?: Maybe<InvoiceFilter>;
};


export type QuoteTripsByActiveQuoteIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};


export type QuoteEmailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EmailsOrderBy>>;
  condition?: Maybe<EmailCondition>;
  filter?: Maybe<EmailFilter>;
};


export type QuoteQuoteViewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteViewsOrderBy>>;
  condition?: Maybe<QuoteViewCondition>;
  filter?: Maybe<QuoteViewFilter>;
};


export type QuoteQuoteAccommodationDetailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
  condition?: Maybe<QuoteAccommodationDetailCondition>;
  filter?: Maybe<QuoteAccommodationDetailFilter>;
};


export type QuoteQuoteCurrenciesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteCurrenciesOrderBy>>;
  condition?: Maybe<QuoteCurrencyCondition>;
  filter?: Maybe<QuoteCurrencyFilter>;
};


export type QuoteQuoteDaysArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
  condition?: Maybe<QuoteDayCondition>;
  filter?: Maybe<QuoteDayFilter>;
};


export type QuoteQuoteFinanceLineItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceLineItemsOrderBy>>;
  condition?: Maybe<QuoteFinanceLineItemCondition>;
  filter?: Maybe<QuoteFinanceLineItemFilter>;
};

export type Trip = Node & {
  __typename?: 'Trip';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  customerId: Scalars['UUID'];
  userId?: Maybe<Scalars['UUID']>;
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status: Scalars['Int'];
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  /** Reads and enables pagination through a set of `Payment`. */
  payments: PaymentsConnection;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices: SupplierInvoicesConnection;
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  /** Reads and enables pagination through a set of `Enquiry`. */
  enquiries: EnquiriesConnection;
  /** Reads and enables pagination through a set of `Note`. */
  notes: NotesConnection;
  /** Reads and enables pagination through a set of `Quote`. */
  quotes: QuotesConnection;
  /** Reads and enables pagination through a set of `Testimonial`. */
  testimonials: TestimonialsConnection;
  /** Reads and enables pagination through a set of `TripTraveller`. */
  tripTravellers: TripTravellersConnection;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlights: TripFlightsConnection;
  /** Reads and enables pagination through a set of `QuotePublic`. */
  quotePublics: QuotePublicsConnection;
};


export type TripExpensesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
  condition?: Maybe<ExpenseCondition>;
  filter?: Maybe<ExpenseFilter>;
};


export type TripInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
  condition?: Maybe<InvoiceCondition>;
  filter?: Maybe<InvoiceFilter>;
};


export type TripPaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
  condition?: Maybe<PaymentCondition>;
  filter?: Maybe<PaymentFilter>;
};


export type TripSupplierInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
  condition?: Maybe<SupplierInvoiceCondition>;
  filter?: Maybe<SupplierInvoiceFilter>;
};


export type TripEmailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EmailsOrderBy>>;
  condition?: Maybe<EmailCondition>;
  filter?: Maybe<EmailFilter>;
};


export type TripEnquiriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EnquiriesOrderBy>>;
  condition?: Maybe<EnquiryCondition>;
  filter?: Maybe<EnquiryFilter>;
};


export type TripNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotesOrderBy>>;
  condition?: Maybe<NoteCondition>;
  filter?: Maybe<NoteFilter>;
};


export type TripQuotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotesOrderBy>>;
  condition?: Maybe<QuoteCondition>;
  filter?: Maybe<QuoteFilter>;
};


export type TripTestimonialsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TestimonialsOrderBy>>;
  condition?: Maybe<TestimonialCondition>;
  filter?: Maybe<TestimonialFilter>;
};


export type TripTripTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripTravellersOrderBy>>;
  condition?: Maybe<TripTravellerCondition>;
  filter?: Maybe<TripTravellerFilter>;
};


export type TripTripFlightsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
  condition?: Maybe<TripFlightCondition>;
  filter?: Maybe<TripFlightFilter>;
};


export type TripQuotePublicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotePublicsOrderBy>>;
  condition?: Maybe<QuotePublicCondition>;
  filter?: Maybe<QuotePublicFilter>;
};

export type Customer = Node & {
  __typename?: 'Customer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  email?: Maybe<Scalars['String']>;
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CustomerTraveller`. */
  customerTravellers: CustomerTravellersConnection;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  /** Reads and enables pagination through a set of `Enquiry`. */
  enquiries: EnquiriesConnection;
};


export type CustomerCustomerTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerTravellersOrderBy>>;
  condition?: Maybe<CustomerTravellerCondition>;
  filter?: Maybe<CustomerTravellerFilter>;
};


export type CustomerTripsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};


export type CustomerEmailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EmailsOrderBy>>;
  condition?: Maybe<EmailCondition>;
  filter?: Maybe<EmailFilter>;
};


export type CustomerEnquiriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EnquiriesOrderBy>>;
  condition?: Maybe<EnquiryCondition>;
  filter?: Maybe<EnquiryFilter>;
};

/** Methods to use when ordering `CustomerTraveller`. */
export enum CustomerTravellersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  TravellerIdAsc = 'TRAVELLER_ID_ASC',
  TravellerIdDesc = 'TRAVELLER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  TravellerByTravellerIdIdAsc = 'TRAVELLER_BY_TRAVELLER_ID__ID_ASC',
  TravellerByTravellerIdIdDesc = 'TRAVELLER_BY_TRAVELLER_ID__ID_DESC',
  TravellerByTravellerIdCreatedAsc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_ASC',
  TravellerByTravellerIdCreatedDesc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_DESC',
  TravellerByTravellerIdDateOfBirthAsc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_ASC',
  TravellerByTravellerIdDateOfBirthDesc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_DESC',
  TravellerByTravellerIdDietaryRequirementsAsc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_ASC',
  TravellerByTravellerIdDietaryRequirementsDesc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_DESC',
  TravellerByTravellerIdEmailAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_ASC',
  TravellerByTravellerIdEmailDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_DESC',
  TravellerByTravellerIdFirstNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_ASC',
  TravellerByTravellerIdFirstNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_DESC',
  TravellerByTravellerIdHeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_ASC',
  TravellerByTravellerIdHeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_DESC',
  TravellerByTravellerIdLastNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_ASC',
  TravellerByTravellerIdLastNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_DESC',
  TravellerByTravellerIdMedicalConditionsAsc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_ASC',
  TravellerByTravellerIdMedicalConditionsDesc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_DESC',
  TravellerByTravellerIdMiddleNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_ASC',
  TravellerByTravellerIdMiddleNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_DESC',
  TravellerByTravellerIdModifiedAsc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_ASC',
  TravellerByTravellerIdModifiedDesc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_DESC',
  TravellerByTravellerIdNationalityAsc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_ASC',
  TravellerByTravellerIdNationalityDesc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_DESC',
  TravellerByTravellerIdNotesAsc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_ASC',
  TravellerByTravellerIdNotesDesc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_DESC',
  TravellerByTravellerIdPhoneAsc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_ASC',
  TravellerByTravellerIdPhoneDesc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_DESC',
  TravellerByTravellerIdWeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_ASC',
  TravellerByTravellerIdWeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_DESC',
  TravellerByTravellerIdEmergencyContactAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_ASC',
  TravellerByTravellerIdEmergencyContactDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_DESC',
  TravellerByTravellerIdInsuranceDetailsAsc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_ASC',
  TravellerByTravellerIdInsuranceDetailsDesc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_DESC'
}

/** A condition to be used against `CustomerTraveller` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CustomerTravellerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `travellerId` field. */
  travellerId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `CustomerTraveller` values. */
export type CustomerTravellersConnection = {
  __typename?: 'CustomerTravellersConnection';
  /** A list of `CustomerTraveller` objects. */
  nodes: Array<Maybe<CustomerTraveller>>;
  /** A list of edges which contains the `CustomerTraveller` and cursor to aid in pagination. */
  edges: Array<CustomerTravellersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerTraveller` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CustomerTraveller = Node & {
  __typename?: 'CustomerTraveller';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  customerId: Scalars['UUID'];
  modified: Scalars['Datetime'];
  travellerId: Scalars['UUID'];
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
};

export type Traveller = Node & {
  __typename?: 'Traveller';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified: Scalars['Datetime'];
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CustomerTraveller`. */
  customerTravellers: CustomerTravellersConnection;
  /** Reads and enables pagination through a set of `Passport`. */
  passports: PassportsConnection;
  /** Reads and enables pagination through a set of `TripTraveller`. */
  tripTravellers: TripTravellersConnection;
};


export type TravellerCustomerTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerTravellersOrderBy>>;
  condition?: Maybe<CustomerTravellerCondition>;
  filter?: Maybe<CustomerTravellerFilter>;
};


export type TravellerPassportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PassportsOrderBy>>;
  condition?: Maybe<PassportCondition>;
  filter?: Maybe<PassportFilter>;
};


export type TravellerTripTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripTravellersOrderBy>>;
  condition?: Maybe<TripTravellerCondition>;
  filter?: Maybe<TripTravellerFilter>;
};

/** Methods to use when ordering `Passport`. */
export enum PassportsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CountryOfIssueAsc = 'COUNTRY_OF_ISSUE_ASC',
  CountryOfIssueDesc = 'COUNTRY_OF_ISSUE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ExpiryAsc = 'EXPIRY_ASC',
  ExpiryDesc = 'EXPIRY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  TravellerIdAsc = 'TRAVELLER_ID_ASC',
  TravellerIdDesc = 'TRAVELLER_ID_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TravellerByTravellerIdIdAsc = 'TRAVELLER_BY_TRAVELLER_ID__ID_ASC',
  TravellerByTravellerIdIdDesc = 'TRAVELLER_BY_TRAVELLER_ID__ID_DESC',
  TravellerByTravellerIdCreatedAsc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_ASC',
  TravellerByTravellerIdCreatedDesc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_DESC',
  TravellerByTravellerIdDateOfBirthAsc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_ASC',
  TravellerByTravellerIdDateOfBirthDesc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_DESC',
  TravellerByTravellerIdDietaryRequirementsAsc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_ASC',
  TravellerByTravellerIdDietaryRequirementsDesc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_DESC',
  TravellerByTravellerIdEmailAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_ASC',
  TravellerByTravellerIdEmailDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_DESC',
  TravellerByTravellerIdFirstNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_ASC',
  TravellerByTravellerIdFirstNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_DESC',
  TravellerByTravellerIdHeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_ASC',
  TravellerByTravellerIdHeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_DESC',
  TravellerByTravellerIdLastNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_ASC',
  TravellerByTravellerIdLastNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_DESC',
  TravellerByTravellerIdMedicalConditionsAsc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_ASC',
  TravellerByTravellerIdMedicalConditionsDesc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_DESC',
  TravellerByTravellerIdMiddleNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_ASC',
  TravellerByTravellerIdMiddleNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_DESC',
  TravellerByTravellerIdModifiedAsc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_ASC',
  TravellerByTravellerIdModifiedDesc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_DESC',
  TravellerByTravellerIdNationalityAsc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_ASC',
  TravellerByTravellerIdNationalityDesc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_DESC',
  TravellerByTravellerIdNotesAsc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_ASC',
  TravellerByTravellerIdNotesDesc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_DESC',
  TravellerByTravellerIdPhoneAsc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_ASC',
  TravellerByTravellerIdPhoneDesc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_DESC',
  TravellerByTravellerIdWeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_ASC',
  TravellerByTravellerIdWeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_DESC',
  TravellerByTravellerIdEmergencyContactAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_ASC',
  TravellerByTravellerIdEmergencyContactDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_DESC',
  TravellerByTravellerIdInsuranceDetailsAsc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_ASC',
  TravellerByTravellerIdInsuranceDetailsDesc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC'
}

/** A condition to be used against `Passport` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PassportCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `countryOfIssue` field. */
  countryOfIssue?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `expiry` field. */
  expiry?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `number` field. */
  number?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `travellerId` field. */
  travellerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Passport` values. */
export type PassportsConnection = {
  __typename?: 'PassportsConnection';
  /** A list of `Passport` objects. */
  nodes: Array<Maybe<Passport>>;
  /** A list of edges which contains the `Passport` and cursor to aid in pagination. */
  edges: Array<PassportsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Passport` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Passport = Node & {
  __typename?: 'Passport';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  countryOfIssue?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  expiry: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  number?: Maybe<Scalars['String']>;
  travellerId: Scalars['UUID'];
  countryId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
};

export type Country = Node & {
  __typename?: 'Country';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Airport`. */
  airports: AirportsConnection;
  /** Reads and enables pagination through a set of `Destination`. */
  destinations: DestinationsConnection;
  /** Reads and enables pagination through a set of `Passport`. */
  passports: PassportsConnection;
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
};


export type CountryAirportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AirportsOrderBy>>;
  condition?: Maybe<AirportCondition>;
  filter?: Maybe<AirportFilter>;
};


export type CountryDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
  condition?: Maybe<DestinationCondition>;
  filter?: Maybe<DestinationFilter>;
};


export type CountryPassportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PassportsOrderBy>>;
  condition?: Maybe<PassportCondition>;
  filter?: Maybe<PassportFilter>;
};


export type CountryPropertiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
  condition?: Maybe<PropertyCondition>;
  filter?: Maybe<PropertyFilter>;
};

/** Methods to use when ordering `Airport`. */
export enum AirportsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  IataAsc = 'IATA_ASC',
  IataDesc = 'IATA_DESC',
  IcaoAsc = 'ICAO_ASC',
  IcaoDesc = 'ICAO_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  DisplayNameAsc = 'DISPLAY_NAME_ASC',
  DisplayNameDesc = 'DISPLAY_NAME_DESC',
  TimezoneAsc = 'TIMEZONE_ASC',
  TimezoneDesc = 'TIMEZONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC',
  TripFlightsByDepartureAirportIdCountAsc = 'TRIP_FLIGHTS_BY_DEPARTURE_AIRPORT_ID__COUNT_ASC',
  TripFlightsByDepartureAirportIdCountDesc = 'TRIP_FLIGHTS_BY_DEPARTURE_AIRPORT_ID__COUNT_DESC',
  TripFlightsByArrivalAirportIdCountAsc = 'TRIP_FLIGHTS_BY_ARRIVAL_AIRPORT_ID__COUNT_ASC',
  TripFlightsByArrivalAirportIdCountDesc = 'TRIP_FLIGHTS_BY_ARRIVAL_AIRPORT_ID__COUNT_DESC'
}

/** A condition to be used against `Airport` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AirportCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `iata` field. */
  iata?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `icao` field. */
  icao?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `displayName` field. */
  displayName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `timezone` field. */
  timezone?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Airport` values. */
export type AirportsConnection = {
  __typename?: 'AirportsConnection';
  /** A list of `Airport` objects. */
  nodes: Array<Maybe<Airport>>;
  /** A list of edges which contains the `Airport` and cursor to aid in pagination. */
  edges: Array<AirportsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Airport` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Airport = Node & {
  __typename?: 'Airport';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  countryId: Scalars['UUID'];
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlightsByDepartureAirportId: TripFlightsConnection;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlightsByArrivalAirportId: TripFlightsConnection;
};


export type AirportTripFlightsByDepartureAirportIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
  condition?: Maybe<TripFlightCondition>;
  filter?: Maybe<TripFlightFilter>;
};


export type AirportTripFlightsByArrivalAirportIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
  condition?: Maybe<TripFlightCondition>;
  filter?: Maybe<TripFlightFilter>;
};

/** Methods to use when ordering `TripFlight`. */
export enum TripFlightsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  CarrierAsc = 'CARRIER_ASC',
  CarrierDesc = 'CARRIER_DESC',
  DepartureAsc = 'DEPARTURE_ASC',
  DepartureDesc = 'DEPARTURE_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  DepartureAirportIdAsc = 'DEPARTURE_AIRPORT_ID_ASC',
  DepartureAirportIdDesc = 'DEPARTURE_AIRPORT_ID_DESC',
  ArrivalAirportIdAsc = 'ARRIVAL_AIRPORT_ID_ASC',
  ArrivalAirportIdDesc = 'ARRIVAL_AIRPORT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  AirportByDepartureAirportIdIdAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ID_ASC',
  AirportByDepartureAirportIdIdDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ID_DESC',
  AirportByDepartureAirportIdCreatedAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CREATED_ASC',
  AirportByDepartureAirportIdCreatedDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CREATED_DESC',
  AirportByDepartureAirportIdModifiedAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__MODIFIED_ASC',
  AirportByDepartureAirportIdModifiedDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__MODIFIED_DESC',
  AirportByDepartureAirportIdIataAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__IATA_ASC',
  AirportByDepartureAirportIdIataDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__IATA_DESC',
  AirportByDepartureAirportIdIcaoAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ICAO_ASC',
  AirportByDepartureAirportIdIcaoDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ICAO_DESC',
  AirportByDepartureAirportIdLatitudeAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LATITUDE_ASC',
  AirportByDepartureAirportIdLatitudeDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LATITUDE_DESC',
  AirportByDepartureAirportIdLongitudeAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LONGITUDE_ASC',
  AirportByDepartureAirportIdLongitudeDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LONGITUDE_DESC',
  AirportByDepartureAirportIdCountryIdAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__COUNTRY_ID_ASC',
  AirportByDepartureAirportIdCountryIdDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__COUNTRY_ID_DESC',
  AirportByDepartureAirportIdCityAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CITY_ASC',
  AirportByDepartureAirportIdCityDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CITY_DESC',
  AirportByDepartureAirportIdNameAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__NAME_ASC',
  AirportByDepartureAirportIdNameDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__NAME_DESC',
  AirportByDepartureAirportIdDisplayNameAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__DISPLAY_NAME_ASC',
  AirportByDepartureAirportIdDisplayNameDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__DISPLAY_NAME_DESC',
  AirportByDepartureAirportIdTimezoneAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__TIMEZONE_ASC',
  AirportByDepartureAirportIdTimezoneDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__TIMEZONE_DESC',
  AirportByArrivalAirportIdIdAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ID_ASC',
  AirportByArrivalAirportIdIdDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ID_DESC',
  AirportByArrivalAirportIdCreatedAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CREATED_ASC',
  AirportByArrivalAirportIdCreatedDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CREATED_DESC',
  AirportByArrivalAirportIdModifiedAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__MODIFIED_ASC',
  AirportByArrivalAirportIdModifiedDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__MODIFIED_DESC',
  AirportByArrivalAirportIdIataAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__IATA_ASC',
  AirportByArrivalAirportIdIataDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__IATA_DESC',
  AirportByArrivalAirportIdIcaoAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ICAO_ASC',
  AirportByArrivalAirportIdIcaoDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ICAO_DESC',
  AirportByArrivalAirportIdLatitudeAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LATITUDE_ASC',
  AirportByArrivalAirportIdLatitudeDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LATITUDE_DESC',
  AirportByArrivalAirportIdLongitudeAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LONGITUDE_ASC',
  AirportByArrivalAirportIdLongitudeDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LONGITUDE_DESC',
  AirportByArrivalAirportIdCountryIdAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__COUNTRY_ID_ASC',
  AirportByArrivalAirportIdCountryIdDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__COUNTRY_ID_DESC',
  AirportByArrivalAirportIdCityAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CITY_ASC',
  AirportByArrivalAirportIdCityDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CITY_DESC',
  AirportByArrivalAirportIdNameAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__NAME_ASC',
  AirportByArrivalAirportIdNameDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__NAME_DESC',
  AirportByArrivalAirportIdDisplayNameAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__DISPLAY_NAME_ASC',
  AirportByArrivalAirportIdDisplayNameDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__DISPLAY_NAME_DESC',
  AirportByArrivalAirportIdTimezoneAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__TIMEZONE_ASC',
  AirportByArrivalAirportIdTimezoneDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__TIMEZONE_DESC'
}

/** A condition to be used against `TripFlight` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TripFlightCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `carrier` field. */
  carrier?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `departure` field. */
  departure?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `number` field. */
  number?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `departureAirportId` field. */
  departureAirportId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `arrivalAirportId` field. */
  arrivalAirportId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `TripFlight` values. */
export type TripFlightsConnection = {
  __typename?: 'TripFlightsConnection';
  /** A list of `TripFlight` objects. */
  nodes: Array<Maybe<TripFlight>>;
  /** A list of edges which contains the `TripFlight` and cursor to aid in pagination. */
  edges: Array<TripFlightsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TripFlight` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TripFlight = Node & {
  __typename?: 'TripFlight';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  arrival: Scalars['Datetime'];
  carrier?: Maybe<Scalars['String']>;
  departure: Scalars['Datetime'];
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  tripId: Scalars['UUID'];
  departureAirportId?: Maybe<Scalars['UUID']>;
  arrivalAirportId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
};

/** A `TripFlight` edge in the connection. */
export type TripFlightsEdge = {
  __typename?: 'TripFlightsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TripFlight` at the end of the edge. */
  node?: Maybe<TripFlight>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

/** A `Airport` edge in the connection. */
export type AirportsEdge = {
  __typename?: 'AirportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Airport` at the end of the edge. */
  node?: Maybe<Airport>;
};

/** Methods to use when ordering `Destination`. */
export enum DestinationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  HeroMediaIdAsc = 'HERO_MEDIA_ID_ASC',
  HeroMediaIdDesc = 'HERO_MEDIA_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  DestinationByParentIdIdAsc = 'DESTINATION_BY_PARENT_ID__ID_ASC',
  DestinationByParentIdIdDesc = 'DESTINATION_BY_PARENT_ID__ID_DESC',
  DestinationByParentIdCreatedAsc = 'DESTINATION_BY_PARENT_ID__CREATED_ASC',
  DestinationByParentIdCreatedDesc = 'DESTINATION_BY_PARENT_ID__CREATED_DESC',
  DestinationByParentIdModifiedAsc = 'DESTINATION_BY_PARENT_ID__MODIFIED_ASC',
  DestinationByParentIdModifiedDesc = 'DESTINATION_BY_PARENT_ID__MODIFIED_DESC',
  DestinationByParentIdNameAsc = 'DESTINATION_BY_PARENT_ID__NAME_ASC',
  DestinationByParentIdNameDesc = 'DESTINATION_BY_PARENT_ID__NAME_DESC',
  DestinationByParentIdBodyAsc = 'DESTINATION_BY_PARENT_ID__BODY_ASC',
  DestinationByParentIdBodyDesc = 'DESTINATION_BY_PARENT_ID__BODY_DESC',
  DestinationByParentIdGalleryIdAsc = 'DESTINATION_BY_PARENT_ID__GALLERY_ID_ASC',
  DestinationByParentIdGalleryIdDesc = 'DESTINATION_BY_PARENT_ID__GALLERY_ID_DESC',
  DestinationByParentIdParentIdAsc = 'DESTINATION_BY_PARENT_ID__PARENT_ID_ASC',
  DestinationByParentIdParentIdDesc = 'DESTINATION_BY_PARENT_ID__PARENT_ID_DESC',
  DestinationByParentIdCountryIdAsc = 'DESTINATION_BY_PARENT_ID__COUNTRY_ID_ASC',
  DestinationByParentIdCountryIdDesc = 'DESTINATION_BY_PARENT_ID__COUNTRY_ID_DESC',
  DestinationByParentIdLatitudeAsc = 'DESTINATION_BY_PARENT_ID__LATITUDE_ASC',
  DestinationByParentIdLatitudeDesc = 'DESTINATION_BY_PARENT_ID__LATITUDE_DESC',
  DestinationByParentIdLongitudeAsc = 'DESTINATION_BY_PARENT_ID__LONGITUDE_ASC',
  DestinationByParentIdLongitudeDesc = 'DESTINATION_BY_PARENT_ID__LONGITUDE_DESC',
  DestinationByParentIdHeroMediaIdAsc = 'DESTINATION_BY_PARENT_ID__HERO_MEDIA_ID_ASC',
  DestinationByParentIdHeroMediaIdDesc = 'DESTINATION_BY_PARENT_ID__HERO_MEDIA_ID_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC',
  MediaItemByHeroMediaIdIdAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_ASC',
  MediaItemByHeroMediaIdIdDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_DESC',
  MediaItemByHeroMediaIdContentTypeAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_ASC',
  MediaItemByHeroMediaIdContentTypeDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_DESC',
  MediaItemByHeroMediaIdCreatedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_ASC',
  MediaItemByHeroMediaIdCreatedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_DESC',
  MediaItemByHeroMediaIdModifiedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_ASC',
  MediaItemByHeroMediaIdModifiedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_DESC',
  MediaItemByHeroMediaIdNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_ASC',
  MediaItemByHeroMediaIdNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_DESC',
  MediaItemByHeroMediaIdFileNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_ASC',
  MediaItemByHeroMediaIdFileNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_DESC',
  MediaItemByHeroMediaIdSummaryAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_ASC',
  MediaItemByHeroMediaIdSummaryDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_DESC',
  MediaItemByHeroMediaIdHashAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_ASC',
  MediaItemByHeroMediaIdHashDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_DESC',
  DestinationsByParentIdCountAsc = 'DESTINATIONS_BY_PARENT_ID__COUNT_ASC',
  DestinationsByParentIdCountDesc = 'DESTINATIONS_BY_PARENT_ID__COUNT_DESC',
  DestinationFeaturesByDestinationIdCountAsc = 'DESTINATION_FEATURES_BY_DESTINATION_ID__COUNT_ASC',
  DestinationFeaturesByDestinationIdCountDesc = 'DESTINATION_FEATURES_BY_DESTINATION_ID__COUNT_DESC',
  DestinationGuidesByDestinationIdCountAsc = 'DESTINATION_GUIDES_BY_DESTINATION_ID__COUNT_ASC',
  DestinationGuidesByDestinationIdCountDesc = 'DESTINATION_GUIDES_BY_DESTINATION_ID__COUNT_DESC',
  QuoteDayDestinationsByDestinationIdCountAsc = 'QUOTE_DAY_DESTINATIONS_BY_DESTINATION_ID__COUNT_ASC',
  QuoteDayDestinationsByDestinationIdCountDesc = 'QUOTE_DAY_DESTINATIONS_BY_DESTINATION_ID__COUNT_DESC'
}

/** A condition to be used against `Destination` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DestinationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `heroMediaId` field. */
  heroMediaId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Destination` values. */
export type DestinationsConnection = {
  __typename?: 'DestinationsConnection';
  /** A list of `Destination` objects. */
  nodes: Array<Maybe<Destination>>;
  /** A list of edges which contains the `Destination` and cursor to aid in pagination. */
  edges: Array<DestinationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Destination` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Destination = Node & {
  __typename?: 'Destination';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId: Scalars['UUID'];
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads and enables pagination through a set of `Destination`. */
  destinationsByParentId: DestinationsConnection;
  /** Reads and enables pagination through a set of `DestinationFeature`. */
  destinationFeatures: DestinationFeaturesConnection;
  /** Reads and enables pagination through a set of `DestinationGuide`. */
  destinationGuides: DestinationGuidesConnection;
  /** Reads and enables pagination through a set of `QuoteDayDestination`. */
  quoteDayDestinations: QuoteDayDestinationsConnection;
};


export type DestinationDestinationsByParentIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
  condition?: Maybe<DestinationCondition>;
  filter?: Maybe<DestinationFilter>;
};


export type DestinationDestinationFeaturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationFeaturesOrderBy>>;
  condition?: Maybe<DestinationFeatureCondition>;
  filter?: Maybe<DestinationFeatureFilter>;
};


export type DestinationDestinationGuidesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationGuidesOrderBy>>;
  condition?: Maybe<DestinationGuideCondition>;
  filter?: Maybe<DestinationGuideFilter>;
};


export type DestinationQuoteDayDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDayDestinationsOrderBy>>;
  condition?: Maybe<QuoteDayDestinationCondition>;
  filter?: Maybe<QuoteDayDestinationFilter>;
};

export type MediaGallery = Node & {
  __typename?: 'MediaGallery';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected: Scalars['Boolean'];
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
  /** Reads and enables pagination through a set of `Destination`. */
  destinationsByGalleryId: DestinationsConnection;
  /** Reads and enables pagination through a set of `DestinationFeature`. */
  destinationFeaturesByGalleryId: DestinationFeaturesConnection;
  /** Reads and enables pagination through a set of `Feature`. */
  featuresByGalleryId: FeaturesConnection;
  /** Reads and enables pagination through a set of `MediaGallery`. */
  mediaGalleriesByParentId: MediaGalleriesConnection;
  /** Reads and enables pagination through a set of `MediaGalleryItem`. */
  mediaGalleryItems: MediaGalleryItemsConnection;
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByGalleryId: PropertiesConnection;
  /** Reads and enables pagination through a set of `Supplier`. */
  suppliersByGalleryId: SuppliersConnection;
};


export type MediaGalleryTripsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};


export type MediaGalleryDestinationsByGalleryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
  condition?: Maybe<DestinationCondition>;
  filter?: Maybe<DestinationFilter>;
};


export type MediaGalleryDestinationFeaturesByGalleryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationFeaturesOrderBy>>;
  condition?: Maybe<DestinationFeatureCondition>;
  filter?: Maybe<DestinationFeatureFilter>;
};


export type MediaGalleryFeaturesByGalleryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FeaturesOrderBy>>;
  condition?: Maybe<FeatureCondition>;
  filter?: Maybe<FeatureFilter>;
};


export type MediaGalleryMediaGalleriesByParentIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaGalleriesOrderBy>>;
  condition?: Maybe<MediaGalleryCondition>;
  filter?: Maybe<MediaGalleryFilter>;
};


export type MediaGalleryMediaGalleryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaGalleryItemsOrderBy>>;
  condition?: Maybe<MediaGalleryItemCondition>;
  filter?: Maybe<MediaGalleryItemFilter>;
};


export type MediaGalleryPropertiesByGalleryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
  condition?: Maybe<PropertyCondition>;
  filter?: Maybe<PropertyFilter>;
};


export type MediaGallerySuppliersByGalleryIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SuppliersOrderBy>>;
  condition?: Maybe<SupplierCondition>;
  filter?: Maybe<SupplierFilter>;
};

/** Methods to use when ordering `Trip`. */
export enum TripsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  DestinationAsc = 'DESTINATION_ASC',
  DestinationDesc = 'DESTINATION_DESC',
  DatesAsc = 'DATES_ASC',
  DatesDesc = 'DATES_DESC',
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  MediaGalleryIdAsc = 'MEDIA_GALLERY_ID_ASC',
  MediaGalleryIdDesc = 'MEDIA_GALLERY_ID_DESC',
  ActiveQuoteIdAsc = 'ACTIVE_QUOTE_ID_ASC',
  ActiveQuoteIdDesc = 'ACTIVE_QUOTE_ID_DESC',
  BaseCurrencyAsc = 'BASE_CURRENCY_ASC',
  BaseCurrencyDesc = 'BASE_CURRENCY_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  AgencyIdAsc = 'AGENCY_ID_ASC',
  AgencyIdDesc = 'AGENCY_ID_DESC',
  AgencyMemberIdAsc = 'AGENCY_MEMBER_ID_ASC',
  AgencyMemberIdDesc = 'AGENCY_MEMBER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  MediaGalleryByMediaGalleryIdIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_ASC',
  MediaGalleryByMediaGalleryIdIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_DESC',
  MediaGalleryByMediaGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_ASC',
  MediaGalleryByMediaGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_DESC',
  MediaGalleryByMediaGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByMediaGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByMediaGalleryIdNameAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_ASC',
  MediaGalleryByMediaGalleryIdNameDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_DESC',
  MediaGalleryByMediaGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByMediaGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryByMediaGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByMediaGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_DESC',
  QuoteByActiveQuoteIdIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ID_ASC',
  QuoteByActiveQuoteIdIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ID_DESC',
  QuoteByActiveQuoteIdCreatedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__CREATED_ASC',
  QuoteByActiveQuoteIdCreatedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__CREATED_DESC',
  QuoteByActiveQuoteIdDurationAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DURATION_ASC',
  QuoteByActiveQuoteIdDurationDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DURATION_DESC',
  QuoteByActiveQuoteIdModifiedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MODIFIED_ASC',
  QuoteByActiveQuoteIdModifiedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MODIFIED_DESC',
  QuoteByActiveQuoteIdStartAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__START_ASC',
  QuoteByActiveQuoteIdStartDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__START_DESC',
  QuoteByActiveQuoteIdTripIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRIP_ID_ASC',
  QuoteByActiveQuoteIdTripIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRIP_ID_DESC',
  QuoteByActiveQuoteIdDepositAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DEPOSIT_ASC',
  QuoteByActiveQuoteIdDepositDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DEPOSIT_DESC',
  QuoteByActiveQuoteIdMarginAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MARGIN_ASC',
  QuoteByActiveQuoteIdMarginDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MARGIN_DESC',
  QuoteByActiveQuoteIdKeyAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__KEY_ASC',
  QuoteByActiveQuoteIdKeyDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__KEY_DESC',
  QuoteByActiveQuoteIdExpiresAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXPIRES_ASC',
  QuoteByActiveQuoteIdExpiresDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXPIRES_DESC',
  QuoteByActiveQuoteIdTotalAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TOTAL_ASC',
  QuoteByActiveQuoteIdTotalDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TOTAL_DESC',
  QuoteByActiveQuoteIdAdjustmentAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByActiveQuoteIdAdjustmentDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByActiveQuoteIdBaseCurrencyAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByActiveQuoteIdBaseCurrencyDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByActiveQuoteIdShortDescriptionAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByActiveQuoteIdShortDescriptionDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByActiveQuoteIdSummaryAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SUMMARY_ASC',
  QuoteByActiveQuoteIdSummaryDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SUMMARY_DESC',
  QuoteByActiveQuoteIdHeroImageIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByActiveQuoteIdHeroImageIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByActiveQuoteIdExclusionsAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByActiveQuoteIdExclusionsDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByActiveQuoteIdInclusionsAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByActiveQuoteIdInclusionsDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByActiveQuoteIdStatusAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__STATUS_ASC',
  QuoteByActiveQuoteIdStatusDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__STATUS_DESC',
  QuoteByActiveQuoteIdAgentMarginAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByActiveQuoteIdAgentMarginDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByActiveQuoteIdTravellerCountAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByActiveQuoteIdTravellerCountDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByActiveQuoteIdArchivedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ARCHIVED_ASC',
  QuoteByActiveQuoteIdArchivedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ARCHIVED_DESC',
  QuoteByActiveQuoteIdLastViewedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByActiveQuoteIdLastViewedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByActiveQuoteIdHeroIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_ID_ASC',
  QuoteByActiveQuoteIdHeroIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_ID_DESC',
  QuoteByActiveQuoteIdUserIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__USER_ID_ASC',
  QuoteByActiveQuoteIdUserIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__USER_ID_DESC',
  QuoteByActiveQuoteIdLockedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__LOCKED_ASC',
  QuoteByActiveQuoteIdLockedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__LOCKED_DESC',
  AgencyByAgencyIdIdAsc = 'AGENCY_BY_AGENCY_ID__ID_ASC',
  AgencyByAgencyIdIdDesc = 'AGENCY_BY_AGENCY_ID__ID_DESC',
  AgencyByAgencyIdCreatedAsc = 'AGENCY_BY_AGENCY_ID__CREATED_ASC',
  AgencyByAgencyIdCreatedDesc = 'AGENCY_BY_AGENCY_ID__CREATED_DESC',
  AgencyByAgencyIdModifiedAsc = 'AGENCY_BY_AGENCY_ID__MODIFIED_ASC',
  AgencyByAgencyIdModifiedDesc = 'AGENCY_BY_AGENCY_ID__MODIFIED_DESC',
  AgencyByAgencyIdLogoIdAsc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_ASC',
  AgencyByAgencyIdLogoIdDesc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_DESC',
  AgencyByAgencyIdNameAsc = 'AGENCY_BY_AGENCY_ID__NAME_ASC',
  AgencyByAgencyIdNameDesc = 'AGENCY_BY_AGENCY_ID__NAME_DESC',
  AgencyMemberByAgencyMemberIdIdAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__ID_ASC',
  AgencyMemberByAgencyMemberIdIdDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__ID_DESC',
  AgencyMemberByAgencyMemberIdCreatedAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__CREATED_ASC',
  AgencyMemberByAgencyMemberIdCreatedDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__CREATED_DESC',
  AgencyMemberByAgencyMemberIdModifiedAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__MODIFIED_ASC',
  AgencyMemberByAgencyMemberIdModifiedDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__MODIFIED_DESC',
  AgencyMemberByAgencyMemberIdFirstNameAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__FIRST_NAME_ASC',
  AgencyMemberByAgencyMemberIdFirstNameDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__FIRST_NAME_DESC',
  AgencyMemberByAgencyMemberIdLastNameAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__LAST_NAME_ASC',
  AgencyMemberByAgencyMemberIdLastNameDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__LAST_NAME_DESC',
  AgencyMemberByAgencyMemberIdEmailAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__EMAIL_ASC',
  AgencyMemberByAgencyMemberIdEmailDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__EMAIL_DESC',
  AgencyMemberByAgencyMemberIdPhoneAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__PHONE_ASC',
  AgencyMemberByAgencyMemberIdPhoneDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__PHONE_DESC',
  AgencyMemberByAgencyMemberIdSkypeAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__SKYPE_ASC',
  AgencyMemberByAgencyMemberIdSkypeDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__SKYPE_DESC',
  AgencyMemberByAgencyMemberIdTitleAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__TITLE_ASC',
  AgencyMemberByAgencyMemberIdTitleDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__TITLE_DESC',
  AgencyMemberByAgencyMemberIdGenderPrepositionAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__GENDER_PREPOSITION_ASC',
  AgencyMemberByAgencyMemberIdGenderPrepositionDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__GENDER_PREPOSITION_DESC',
  AgencyMemberByAgencyMemberIdAgencyIdAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__AGENCY_ID_ASC',
  AgencyMemberByAgencyMemberIdAgencyIdDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__AGENCY_ID_DESC',
  ExpensesByTripIdCountAsc = 'EXPENSES_BY_TRIP_ID__COUNT_ASC',
  ExpensesByTripIdCountDesc = 'EXPENSES_BY_TRIP_ID__COUNT_DESC',
  InvoicesByTripIdCountAsc = 'INVOICES_BY_TRIP_ID__COUNT_ASC',
  InvoicesByTripIdCountDesc = 'INVOICES_BY_TRIP_ID__COUNT_DESC',
  PaymentsByTripIdCountAsc = 'PAYMENTS_BY_TRIP_ID__COUNT_ASC',
  PaymentsByTripIdCountDesc = 'PAYMENTS_BY_TRIP_ID__COUNT_DESC',
  SupplierInvoicesByTripIdCountAsc = 'SUPPLIER_INVOICES_BY_TRIP_ID__COUNT_ASC',
  SupplierInvoicesByTripIdCountDesc = 'SUPPLIER_INVOICES_BY_TRIP_ID__COUNT_DESC',
  EmailsByTripIdCountAsc = 'EMAILS_BY_TRIP_ID__COUNT_ASC',
  EmailsByTripIdCountDesc = 'EMAILS_BY_TRIP_ID__COUNT_DESC',
  EnquiriesByTripIdCountAsc = 'ENQUIRIES_BY_TRIP_ID__COUNT_ASC',
  EnquiriesByTripIdCountDesc = 'ENQUIRIES_BY_TRIP_ID__COUNT_DESC',
  NotesByTripIdCountAsc = 'NOTES_BY_TRIP_ID__COUNT_ASC',
  NotesByTripIdCountDesc = 'NOTES_BY_TRIP_ID__COUNT_DESC',
  QuotesByTripIdCountAsc = 'QUOTES_BY_TRIP_ID__COUNT_ASC',
  QuotesByTripIdCountDesc = 'QUOTES_BY_TRIP_ID__COUNT_DESC',
  TestimonialsByTripIdCountAsc = 'TESTIMONIALS_BY_TRIP_ID__COUNT_ASC',
  TestimonialsByTripIdCountDesc = 'TESTIMONIALS_BY_TRIP_ID__COUNT_DESC',
  TripTravellersByTripIdCountAsc = 'TRIP_TRAVELLERS_BY_TRIP_ID__COUNT_ASC',
  TripTravellersByTripIdCountDesc = 'TRIP_TRAVELLERS_BY_TRIP_ID__COUNT_DESC',
  TripFlightsByTripIdCountAsc = 'TRIP_FLIGHTS_BY_TRIP_ID__COUNT_ASC',
  TripFlightsByTripIdCountDesc = 'TRIP_FLIGHTS_BY_TRIP_ID__COUNT_DESC',
  QuotePublicsByTripIdCountAsc = 'QUOTE_PUBLICS_BY_TRIP_ID__COUNT_ASC',
  QuotePublicsByTripIdCountDesc = 'QUOTE_PUBLICS_BY_TRIP_ID__COUNT_DESC'
}

/** A condition to be used against `Trip` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TripCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destination` field. */
  destination?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dates` field. */
  dates?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `archived` field. */
  archived?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `mediaGalleryId` field. */
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `activeQuoteId` field. */
  activeQuoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `baseCurrency` field. */
  baseCurrency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `start` field. */
  start?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `agencyId` field. */
  agencyId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `agencyMemberId` field. */
  agencyMemberId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Trip` values. */
export type TripsConnection = {
  __typename?: 'TripsConnection';
  /** A list of `Trip` objects. */
  nodes: Array<Maybe<Trip>>;
  /** A list of edges which contains the `Trip` and cursor to aid in pagination. */
  edges: Array<TripsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Trip` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Trip` edge in the connection. */
export type TripsEdge = {
  __typename?: 'TripsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Trip` at the end of the edge. */
  node?: Maybe<Trip>;
};

/** Methods to use when ordering `DestinationFeature`. */
export enum DestinationFeaturesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationIdAsc = 'DESTINATION_ID_ASC',
  DestinationIdDesc = 'DESTINATION_ID_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  DestinationByDestinationIdIdAsc = 'DESTINATION_BY_DESTINATION_ID__ID_ASC',
  DestinationByDestinationIdIdDesc = 'DESTINATION_BY_DESTINATION_ID__ID_DESC',
  DestinationByDestinationIdCreatedAsc = 'DESTINATION_BY_DESTINATION_ID__CREATED_ASC',
  DestinationByDestinationIdCreatedDesc = 'DESTINATION_BY_DESTINATION_ID__CREATED_DESC',
  DestinationByDestinationIdModifiedAsc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_ASC',
  DestinationByDestinationIdModifiedDesc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_DESC',
  DestinationByDestinationIdNameAsc = 'DESTINATION_BY_DESTINATION_ID__NAME_ASC',
  DestinationByDestinationIdNameDesc = 'DESTINATION_BY_DESTINATION_ID__NAME_DESC',
  DestinationByDestinationIdBodyAsc = 'DESTINATION_BY_DESTINATION_ID__BODY_ASC',
  DestinationByDestinationIdBodyDesc = 'DESTINATION_BY_DESTINATION_ID__BODY_DESC',
  DestinationByDestinationIdGalleryIdAsc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_ASC',
  DestinationByDestinationIdGalleryIdDesc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_DESC',
  DestinationByDestinationIdParentIdAsc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_ASC',
  DestinationByDestinationIdParentIdDesc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_DESC',
  DestinationByDestinationIdCountryIdAsc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_ASC',
  DestinationByDestinationIdCountryIdDesc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_DESC',
  DestinationByDestinationIdLatitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_ASC',
  DestinationByDestinationIdLatitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_DESC',
  DestinationByDestinationIdLongitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_ASC',
  DestinationByDestinationIdLongitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_DESC',
  DestinationByDestinationIdHeroMediaIdAsc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_ASC',
  DestinationByDestinationIdHeroMediaIdDesc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC'
}

/** A condition to be used against `DestinationFeature` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DestinationFeatureCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `destinationId` field. */
  destinationId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A connection to a list of `DestinationFeature` values. */
export type DestinationFeaturesConnection = {
  __typename?: 'DestinationFeaturesConnection';
  /** A list of `DestinationFeature` objects. */
  nodes: Array<Maybe<DestinationFeature>>;
  /** A list of edges which contains the `DestinationFeature` and cursor to aid in pagination. */
  edges: Array<DestinationFeaturesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DestinationFeature` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type DestinationFeature = Node & {
  __typename?: 'DestinationFeature';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  body?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  destinationId: Scalars['UUID'];
  galleryId?: Maybe<Scalars['UUID']>;
  modified: Scalars['Datetime'];
  title?: Maybe<Scalars['String']>;
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
};

/** A `DestinationFeature` edge in the connection. */
export type DestinationFeaturesEdge = {
  __typename?: 'DestinationFeaturesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `DestinationFeature` at the end of the edge. */
  node?: Maybe<DestinationFeature>;
};

/** Methods to use when ordering `Feature`. */
export enum FeaturesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC'
}

/** A condition to be used against `Feature` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FeatureCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Feature` values. */
export type FeaturesConnection = {
  __typename?: 'FeaturesConnection';
  /** A list of `Feature` objects. */
  nodes: Array<Maybe<Feature>>;
  /** A list of edges which contains the `Feature` and cursor to aid in pagination. */
  edges: Array<FeaturesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Feature` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Feature = Node & {
  __typename?: 'Feature';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  body?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
};

/** A `Feature` edge in the connection. */
export type FeaturesEdge = {
  __typename?: 'FeaturesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Feature` at the end of the edge. */
  node?: Maybe<Feature>;
};

/** Methods to use when ordering `MediaGallery`. */
export enum MediaGalleriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  IsProtectedAsc = 'IS_PROTECTED_ASC',
  IsProtectedDesc = 'IS_PROTECTED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaGalleryByParentIdIdAsc = 'MEDIA_GALLERY_BY_PARENT_ID__ID_ASC',
  MediaGalleryByParentIdIdDesc = 'MEDIA_GALLERY_BY_PARENT_ID__ID_DESC',
  MediaGalleryByParentIdCreatedAsc = 'MEDIA_GALLERY_BY_PARENT_ID__CREATED_ASC',
  MediaGalleryByParentIdCreatedDesc = 'MEDIA_GALLERY_BY_PARENT_ID__CREATED_DESC',
  MediaGalleryByParentIdModifiedAsc = 'MEDIA_GALLERY_BY_PARENT_ID__MODIFIED_ASC',
  MediaGalleryByParentIdModifiedDesc = 'MEDIA_GALLERY_BY_PARENT_ID__MODIFIED_DESC',
  MediaGalleryByParentIdNameAsc = 'MEDIA_GALLERY_BY_PARENT_ID__NAME_ASC',
  MediaGalleryByParentIdNameDesc = 'MEDIA_GALLERY_BY_PARENT_ID__NAME_DESC',
  MediaGalleryByParentIdParentIdAsc = 'MEDIA_GALLERY_BY_PARENT_ID__PARENT_ID_ASC',
  MediaGalleryByParentIdParentIdDesc = 'MEDIA_GALLERY_BY_PARENT_ID__PARENT_ID_DESC',
  MediaGalleryByParentIdIsProtectedAsc = 'MEDIA_GALLERY_BY_PARENT_ID__IS_PROTECTED_ASC',
  MediaGalleryByParentIdIsProtectedDesc = 'MEDIA_GALLERY_BY_PARENT_ID__IS_PROTECTED_DESC',
  TripsByMediaGalleryIdCountAsc = 'TRIPS_BY_MEDIA_GALLERY_ID__COUNT_ASC',
  TripsByMediaGalleryIdCountDesc = 'TRIPS_BY_MEDIA_GALLERY_ID__COUNT_DESC',
  DestinationsByGalleryIdCountAsc = 'DESTINATIONS_BY_GALLERY_ID__COUNT_ASC',
  DestinationsByGalleryIdCountDesc = 'DESTINATIONS_BY_GALLERY_ID__COUNT_DESC',
  DestinationFeaturesByGalleryIdCountAsc = 'DESTINATION_FEATURES_BY_GALLERY_ID__COUNT_ASC',
  DestinationFeaturesByGalleryIdCountDesc = 'DESTINATION_FEATURES_BY_GALLERY_ID__COUNT_DESC',
  FeaturesByGalleryIdCountAsc = 'FEATURES_BY_GALLERY_ID__COUNT_ASC',
  FeaturesByGalleryIdCountDesc = 'FEATURES_BY_GALLERY_ID__COUNT_DESC',
  MediaGalleriesByParentIdCountAsc = 'MEDIA_GALLERIES_BY_PARENT_ID__COUNT_ASC',
  MediaGalleriesByParentIdCountDesc = 'MEDIA_GALLERIES_BY_PARENT_ID__COUNT_DESC',
  MediaGalleryItemsByMediaGalleryIdCountAsc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_GALLERY_ID__COUNT_ASC',
  MediaGalleryItemsByMediaGalleryIdCountDesc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_GALLERY_ID__COUNT_DESC',
  PropertiesByGalleryIdCountAsc = 'PROPERTIES_BY_GALLERY_ID__COUNT_ASC',
  PropertiesByGalleryIdCountDesc = 'PROPERTIES_BY_GALLERY_ID__COUNT_DESC',
  SuppliersByGalleryIdCountAsc = 'SUPPLIERS_BY_GALLERY_ID__COUNT_ASC',
  SuppliersByGalleryIdCountDesc = 'SUPPLIERS_BY_GALLERY_ID__COUNT_DESC'
}

/** A condition to be used against `MediaGallery` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MediaGalleryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `isProtected` field. */
  isProtected?: Maybe<Scalars['Boolean']>;
};

/** A connection to a list of `MediaGallery` values. */
export type MediaGalleriesConnection = {
  __typename?: 'MediaGalleriesConnection';
  /** A list of `MediaGallery` objects. */
  nodes: Array<Maybe<MediaGallery>>;
  /** A list of edges which contains the `MediaGallery` and cursor to aid in pagination. */
  edges: Array<MediaGalleriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MediaGallery` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `MediaGallery` edge in the connection. */
export type MediaGalleriesEdge = {
  __typename?: 'MediaGalleriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `MediaGallery` at the end of the edge. */
  node?: Maybe<MediaGallery>;
};

/** Methods to use when ordering `MediaGalleryItem`. */
export enum MediaGalleryItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  MediaGalleryIdAsc = 'MEDIA_GALLERY_ID_ASC',
  MediaGalleryIdDesc = 'MEDIA_GALLERY_ID_DESC',
  MediaItemIdAsc = 'MEDIA_ITEM_ID_ASC',
  MediaItemIdDesc = 'MEDIA_ITEM_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  IsHeroAsc = 'IS_HERO_ASC',
  IsHeroDesc = 'IS_HERO_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaGalleryByMediaGalleryIdIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_ASC',
  MediaGalleryByMediaGalleryIdIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_DESC',
  MediaGalleryByMediaGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_ASC',
  MediaGalleryByMediaGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_DESC',
  MediaGalleryByMediaGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByMediaGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByMediaGalleryIdNameAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_ASC',
  MediaGalleryByMediaGalleryIdNameDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_DESC',
  MediaGalleryByMediaGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByMediaGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryByMediaGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByMediaGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_DESC',
  MediaItemByMediaItemIdIdAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_ASC',
  MediaItemByMediaItemIdIdDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_DESC',
  MediaItemByMediaItemIdContentTypeAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_ASC',
  MediaItemByMediaItemIdContentTypeDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_DESC',
  MediaItemByMediaItemIdCreatedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_ASC',
  MediaItemByMediaItemIdCreatedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_DESC',
  MediaItemByMediaItemIdModifiedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_ASC',
  MediaItemByMediaItemIdModifiedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_DESC',
  MediaItemByMediaItemIdNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_ASC',
  MediaItemByMediaItemIdNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_DESC',
  MediaItemByMediaItemIdFileNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_ASC',
  MediaItemByMediaItemIdFileNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_DESC',
  MediaItemByMediaItemIdSummaryAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_ASC',
  MediaItemByMediaItemIdSummaryDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_DESC',
  MediaItemByMediaItemIdHashAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_ASC',
  MediaItemByMediaItemIdHashDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_DESC'
}

/** A condition to be used against `MediaGalleryItem` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MediaGalleryItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `mediaGalleryId` field. */
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `mediaItemId` field. */
  mediaItemId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `isHero` field. */
  isHero?: Maybe<Scalars['Boolean']>;
};

/** A connection to a list of `MediaGalleryItem` values. */
export type MediaGalleryItemsConnection = {
  __typename?: 'MediaGalleryItemsConnection';
  /** A list of `MediaGalleryItem` objects. */
  nodes: Array<Maybe<MediaGalleryItem>>;
  /** A list of edges which contains the `MediaGalleryItem` and cursor to aid in pagination. */
  edges: Array<MediaGalleryItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MediaGalleryItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type MediaGalleryItem = Node & {
  __typename?: 'MediaGalleryItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  mediaGalleryId: Scalars['UUID'];
  mediaItemId: Scalars['UUID'];
  modified: Scalars['Datetime'];
  isHero: Scalars['Boolean'];
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
};

export type MediaItem = Node & {
  __typename?: 'MediaItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  contentType?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Agency`. */
  agenciesByLogoId: AgenciesConnection;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices: SupplierInvoicesConnection;
  /** Reads and enables pagination through a set of `Destination`. */
  destinationsByHeroMediaId: DestinationsConnection;
  /** Reads and enables pagination through a set of `MediaGalleryItem`. */
  mediaGalleryItems: MediaGalleryItemsConnection;
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByHeroMediaId: PropertiesConnection;
  /** Reads and enables pagination through a set of `Quote`. */
  quotesByHeroImageId: QuotesConnection;
  /** Reads and enables pagination through a set of `QuoteHero`. */
  quoteHeroesByImageId: QuoteHeroesConnection;
};


export type MediaItemAgenciesByLogoIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgenciesOrderBy>>;
  condition?: Maybe<AgencyCondition>;
  filter?: Maybe<AgencyFilter>;
};


export type MediaItemSupplierInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
  condition?: Maybe<SupplierInvoiceCondition>;
  filter?: Maybe<SupplierInvoiceFilter>;
};


export type MediaItemDestinationsByHeroMediaIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
  condition?: Maybe<DestinationCondition>;
  filter?: Maybe<DestinationFilter>;
};


export type MediaItemMediaGalleryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaGalleryItemsOrderBy>>;
  condition?: Maybe<MediaGalleryItemCondition>;
  filter?: Maybe<MediaGalleryItemFilter>;
};


export type MediaItemPropertiesByHeroMediaIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
  condition?: Maybe<PropertyCondition>;
  filter?: Maybe<PropertyFilter>;
};


export type MediaItemQuotesByHeroImageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotesOrderBy>>;
  condition?: Maybe<QuoteCondition>;
  filter?: Maybe<QuoteFilter>;
};


export type MediaItemQuoteHeroesByImageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteHeroesOrderBy>>;
  condition?: Maybe<QuoteHeroCondition>;
  filter?: Maybe<QuoteHeroFilter>;
};

/** Methods to use when ordering `Agency`. */
export enum AgenciesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  LogoIdAsc = 'LOGO_ID_ASC',
  LogoIdDesc = 'LOGO_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaItemByLogoIdIdAsc = 'MEDIA_ITEM_BY_LOGO_ID__ID_ASC',
  MediaItemByLogoIdIdDesc = 'MEDIA_ITEM_BY_LOGO_ID__ID_DESC',
  MediaItemByLogoIdContentTypeAsc = 'MEDIA_ITEM_BY_LOGO_ID__CONTENT_TYPE_ASC',
  MediaItemByLogoIdContentTypeDesc = 'MEDIA_ITEM_BY_LOGO_ID__CONTENT_TYPE_DESC',
  MediaItemByLogoIdCreatedAsc = 'MEDIA_ITEM_BY_LOGO_ID__CREATED_ASC',
  MediaItemByLogoIdCreatedDesc = 'MEDIA_ITEM_BY_LOGO_ID__CREATED_DESC',
  MediaItemByLogoIdModifiedAsc = 'MEDIA_ITEM_BY_LOGO_ID__MODIFIED_ASC',
  MediaItemByLogoIdModifiedDesc = 'MEDIA_ITEM_BY_LOGO_ID__MODIFIED_DESC',
  MediaItemByLogoIdNameAsc = 'MEDIA_ITEM_BY_LOGO_ID__NAME_ASC',
  MediaItemByLogoIdNameDesc = 'MEDIA_ITEM_BY_LOGO_ID__NAME_DESC',
  MediaItemByLogoIdFileNameAsc = 'MEDIA_ITEM_BY_LOGO_ID__FILE_NAME_ASC',
  MediaItemByLogoIdFileNameDesc = 'MEDIA_ITEM_BY_LOGO_ID__FILE_NAME_DESC',
  MediaItemByLogoIdSummaryAsc = 'MEDIA_ITEM_BY_LOGO_ID__SUMMARY_ASC',
  MediaItemByLogoIdSummaryDesc = 'MEDIA_ITEM_BY_LOGO_ID__SUMMARY_DESC',
  MediaItemByLogoIdHashAsc = 'MEDIA_ITEM_BY_LOGO_ID__HASH_ASC',
  MediaItemByLogoIdHashDesc = 'MEDIA_ITEM_BY_LOGO_ID__HASH_DESC',
  AgencyMembersByAgencyIdCountAsc = 'AGENCY_MEMBERS_BY_AGENCY_ID__COUNT_ASC',
  AgencyMembersByAgencyIdCountDesc = 'AGENCY_MEMBERS_BY_AGENCY_ID__COUNT_DESC',
  TripsByAgencyIdCountAsc = 'TRIPS_BY_AGENCY_ID__COUNT_ASC',
  TripsByAgencyIdCountDesc = 'TRIPS_BY_AGENCY_ID__COUNT_DESC'
}

/** A condition to be used against `Agency` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AgencyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `logoId` field. */
  logoId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Agency` values. */
export type AgenciesConnection = {
  __typename?: 'AgenciesConnection';
  /** A list of `Agency` objects. */
  nodes: Array<Maybe<Agency>>;
  /** A list of edges which contains the `Agency` and cursor to aid in pagination. */
  edges: Array<AgenciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Agency` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Agency = Node & {
  __typename?: 'Agency';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  logoId: Scalars['UUID'];
  name?: Maybe<Scalars['String']>;
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  /** Reads and enables pagination through a set of `AgencyMember`. */
  agencyMembers: AgencyMembersConnection;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
};


export type AgencyAgencyMembersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgencyMembersOrderBy>>;
  condition?: Maybe<AgencyMemberCondition>;
  filter?: Maybe<AgencyMemberFilter>;
};


export type AgencyTripsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};

/** Methods to use when ordering `AgencyMember`. */
export enum AgencyMembersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  SkypeAsc = 'SKYPE_ASC',
  SkypeDesc = 'SKYPE_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  GenderPrepositionAsc = 'GENDER_PREPOSITION_ASC',
  GenderPrepositionDesc = 'GENDER_PREPOSITION_DESC',
  AgencyIdAsc = 'AGENCY_ID_ASC',
  AgencyIdDesc = 'AGENCY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  AgencyByAgencyIdIdAsc = 'AGENCY_BY_AGENCY_ID__ID_ASC',
  AgencyByAgencyIdIdDesc = 'AGENCY_BY_AGENCY_ID__ID_DESC',
  AgencyByAgencyIdCreatedAsc = 'AGENCY_BY_AGENCY_ID__CREATED_ASC',
  AgencyByAgencyIdCreatedDesc = 'AGENCY_BY_AGENCY_ID__CREATED_DESC',
  AgencyByAgencyIdModifiedAsc = 'AGENCY_BY_AGENCY_ID__MODIFIED_ASC',
  AgencyByAgencyIdModifiedDesc = 'AGENCY_BY_AGENCY_ID__MODIFIED_DESC',
  AgencyByAgencyIdLogoIdAsc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_ASC',
  AgencyByAgencyIdLogoIdDesc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_DESC',
  AgencyByAgencyIdNameAsc = 'AGENCY_BY_AGENCY_ID__NAME_ASC',
  AgencyByAgencyIdNameDesc = 'AGENCY_BY_AGENCY_ID__NAME_DESC',
  TripsByAgencyMemberIdCountAsc = 'TRIPS_BY_AGENCY_MEMBER_ID__COUNT_ASC',
  TripsByAgencyMemberIdCountDesc = 'TRIPS_BY_AGENCY_MEMBER_ID__COUNT_DESC'
}

/** A condition to be used against `AgencyMember` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AgencyMemberCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skype` field. */
  skype?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `genderPreposition` field. */
  genderPreposition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `agencyId` field. */
  agencyId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `AgencyMember` values. */
export type AgencyMembersConnection = {
  __typename?: 'AgencyMembersConnection';
  /** A list of `AgencyMember` objects. */
  nodes: Array<Maybe<AgencyMember>>;
  /** A list of edges which contains the `AgencyMember` and cursor to aid in pagination. */
  edges: Array<AgencyMembersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgencyMember` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type AgencyMember = Node & {
  __typename?: 'AgencyMember';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  genderPreposition?: Maybe<Scalars['String']>;
  agencyId: Scalars['UUID'];
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
};


export type AgencyMemberTripsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};

/** A `AgencyMember` edge in the connection. */
export type AgencyMembersEdge = {
  __typename?: 'AgencyMembersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AgencyMember` at the end of the edge. */
  node?: Maybe<AgencyMember>;
};

/** A `Agency` edge in the connection. */
export type AgenciesEdge = {
  __typename?: 'AgenciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Agency` at the end of the edge. */
  node?: Maybe<Agency>;
};

/** Methods to use when ordering `SupplierInvoice`. */
export enum SupplierInvoicesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DueAsc = 'DUE_ASC',
  DueDesc = 'DUE_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  SupplierIdAsc = 'SUPPLIER_ID_ASC',
  SupplierIdDesc = 'SUPPLIER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  VoidedAsc = 'VOIDED_ASC',
  VoidedDesc = 'VOIDED_DESC',
  AmountActualAsc = 'AMOUNT_ACTUAL_ASC',
  AmountActualDesc = 'AMOUNT_ACTUAL_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  MediaItemIdAsc = 'MEDIA_ITEM_ID_ASC',
  MediaItemIdDesc = 'MEDIA_ITEM_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  SupplierBySupplierIdIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__ID_ASC',
  SupplierBySupplierIdIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__ID_DESC',
  SupplierBySupplierIdCreatedAsc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_ASC',
  SupplierBySupplierIdCreatedDesc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_DESC',
  SupplierBySupplierIdModifiedAsc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_ASC',
  SupplierBySupplierIdModifiedDesc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_DESC',
  SupplierBySupplierIdNameAsc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_ASC',
  SupplierBySupplierIdNameDesc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_DESC',
  SupplierBySupplierIdContactEmailAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_ASC',
  SupplierBySupplierIdContactEmailDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_DESC',
  SupplierBySupplierIdContactNumberAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_ASC',
  SupplierBySupplierIdContactNumberDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_DESC',
  SupplierBySupplierIdRegionAsc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_ASC',
  SupplierBySupplierIdRegionDesc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_DESC',
  SupplierBySupplierIdUrlAsc = 'SUPPLIER_BY_SUPPLIER_ID__URL_ASC',
  SupplierBySupplierIdUrlDesc = 'SUPPLIER_BY_SUPPLIER_ID__URL_DESC',
  SupplierBySupplierIdBankDetailsAsc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_ASC',
  SupplierBySupplierIdBankDetailsDesc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_DESC',
  SupplierBySupplierIdGalleryIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_ASC',
  SupplierBySupplierIdGalleryIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  MediaItemByMediaItemIdIdAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_ASC',
  MediaItemByMediaItemIdIdDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_DESC',
  MediaItemByMediaItemIdContentTypeAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_ASC',
  MediaItemByMediaItemIdContentTypeDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_DESC',
  MediaItemByMediaItemIdCreatedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_ASC',
  MediaItemByMediaItemIdCreatedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_DESC',
  MediaItemByMediaItemIdModifiedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_ASC',
  MediaItemByMediaItemIdModifiedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_DESC',
  MediaItemByMediaItemIdNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_ASC',
  MediaItemByMediaItemIdNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_DESC',
  MediaItemByMediaItemIdFileNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_ASC',
  MediaItemByMediaItemIdFileNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_DESC',
  MediaItemByMediaItemIdSummaryAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_ASC',
  MediaItemByMediaItemIdSummaryDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_DESC',
  MediaItemByMediaItemIdHashAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_ASC',
  MediaItemByMediaItemIdHashDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_DESC',
  ExpensesBySupplierInvoiceIdCountAsc = 'EXPENSES_BY_SUPPLIER_INVOICE_ID__COUNT_ASC',
  ExpensesBySupplierInvoiceIdCountDesc = 'EXPENSES_BY_SUPPLIER_INVOICE_ID__COUNT_DESC',
  TransactionLinksBySupplierInvoiceIdCountAsc = 'TRANSACTION_LINKS_BY_SUPPLIER_INVOICE_ID__COUNT_ASC',
  TransactionLinksBySupplierInvoiceIdCountDesc = 'TRANSACTION_LINKS_BY_SUPPLIER_INVOICE_ID__COUNT_DESC'
}

/** A condition to be used against `SupplierInvoice` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SupplierInvoiceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `due` field. */
  due?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `key` field. */
  key?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `number` field. */
  number?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `supplierId` field. */
  supplierId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `voided` field. */
  voided?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `amountActual` field. */
  amountActual?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `mediaItemId` field. */
  mediaItemId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `SupplierInvoice` values. */
export type SupplierInvoicesConnection = {
  __typename?: 'SupplierInvoicesConnection';
  /** A list of `SupplierInvoice` objects. */
  nodes: Array<Maybe<SupplierInvoice>>;
  /** A list of edges which contains the `SupplierInvoice` and cursor to aid in pagination. */
  edges: Array<SupplierInvoicesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SupplierInvoice` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type SupplierInvoice = Node & {
  __typename?: 'SupplierInvoice';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  amount: Scalars['BigFloat'];
  categoryId?: Maybe<Scalars['UUID']>;
  created: Scalars['Datetime'];
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified: Scalars['Datetime'];
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId: Scalars['UUID'];
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual: Scalars['BigFloat'];
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
};


export type SupplierInvoiceExpensesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
  condition?: Maybe<ExpenseCondition>;
  filter?: Maybe<ExpenseFilter>;
};


export type SupplierInvoiceTransactionLinksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
  condition?: Maybe<TransactionLinkCondition>;
  filter?: Maybe<TransactionLinkFilter>;
};

export type Supplier = Node & {
  __typename?: 'Supplier';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices: SupplierInvoicesConnection;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItem`. */
  quoteFinanceLineItems: QuoteFinanceLineItemsConnection;
};


export type SupplierExpensesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
  condition?: Maybe<ExpenseCondition>;
  filter?: Maybe<ExpenseFilter>;
};


export type SupplierSupplierInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
  condition?: Maybe<SupplierInvoiceCondition>;
  filter?: Maybe<SupplierInvoiceFilter>;
};


export type SupplierQuoteFinanceLineItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceLineItemsOrderBy>>;
  condition?: Maybe<QuoteFinanceLineItemCondition>;
  filter?: Maybe<QuoteFinanceLineItemFilter>;
};

/** Methods to use when ordering `QuoteFinanceLineItem`. */
export enum QuoteFinanceLineItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  SupplierIdAsc = 'SUPPLIER_ID_ASC',
  SupplierIdDesc = 'SUPPLIER_ID_DESC',
  ConfirmationAsc = 'CONFIRMATION_ASC',
  ConfirmationDesc = 'CONFIRMATION_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  ExcludeMarginAsc = 'EXCLUDE_MARGIN_ASC',
  ExcludeMarginDesc = 'EXCLUDE_MARGIN_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  OrderAsc = 'ORDER_ASC',
  OrderDesc = 'ORDER_DESC',
  MarginOverrideAsc = 'MARGIN_OVERRIDE_ASC',
  MarginOverrideDesc = 'MARGIN_OVERRIDE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdTotalAsc = 'QUOTE_BY_QUOTE_ID__TOTAL_ASC',
  QuoteByQuoteIdTotalDesc = 'QUOTE_BY_QUOTE_ID__TOTAL_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdLastViewedAsc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByQuoteIdLastViewedDesc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  SupplierBySupplierIdIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__ID_ASC',
  SupplierBySupplierIdIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__ID_DESC',
  SupplierBySupplierIdCreatedAsc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_ASC',
  SupplierBySupplierIdCreatedDesc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_DESC',
  SupplierBySupplierIdModifiedAsc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_ASC',
  SupplierBySupplierIdModifiedDesc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_DESC',
  SupplierBySupplierIdNameAsc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_ASC',
  SupplierBySupplierIdNameDesc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_DESC',
  SupplierBySupplierIdContactEmailAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_ASC',
  SupplierBySupplierIdContactEmailDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_DESC',
  SupplierBySupplierIdContactNumberAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_ASC',
  SupplierBySupplierIdContactNumberDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_DESC',
  SupplierBySupplierIdRegionAsc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_ASC',
  SupplierBySupplierIdRegionDesc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_DESC',
  SupplierBySupplierIdUrlAsc = 'SUPPLIER_BY_SUPPLIER_ID__URL_ASC',
  SupplierBySupplierIdUrlDesc = 'SUPPLIER_BY_SUPPLIER_ID__URL_DESC',
  SupplierBySupplierIdBankDetailsAsc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_ASC',
  SupplierBySupplierIdBankDetailsDesc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_DESC',
  SupplierBySupplierIdGalleryIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_ASC',
  SupplierBySupplierIdGalleryIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_DESC'
}

/** A condition to be used against `QuoteFinanceLineItem` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteFinanceLineItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `supplierId` field. */
  supplierId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `confirmation` field. */
  confirmation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `excludeMargin` field. */
  excludeMargin?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `order` field. */
  order?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `marginOverride` field. */
  marginOverride?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `QuoteFinanceLineItem` values. */
export type QuoteFinanceLineItemsConnection = {
  __typename?: 'QuoteFinanceLineItemsConnection';
  /** A list of `QuoteFinanceLineItem` objects. */
  nodes: Array<Maybe<QuoteFinanceLineItem>>;
  /** A list of edges which contains the `QuoteFinanceLineItem` and cursor to aid in pagination. */
  edges: Array<QuoteFinanceLineItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteFinanceLineItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteFinanceLineItem = Node & {
  __typename?: 'QuoteFinanceLineItem';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  amount: Scalars['BigFloat'];
  currency?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  supplierId: Scalars['UUID'];
  confirmation?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  excludeMargin: Scalars['Boolean'];
  notes?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  order: Scalars['Int'];
  marginOverride?: Maybe<Scalars['BigFloat']>;
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
};

/** A `QuoteFinanceLineItem` edge in the connection. */
export type QuoteFinanceLineItemsEdge = {
  __typename?: 'QuoteFinanceLineItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteFinanceLineItem` at the end of the edge. */
  node?: Maybe<QuoteFinanceLineItem>;
};

/** Methods to use when ordering `TransactionLink`. */
export enum TransactionLinksOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  TransactionIdAsc = 'TRANSACTION_ID_ASC',
  TransactionIdDesc = 'TRANSACTION_ID_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  SupplierInvoiceIdAsc = 'SUPPLIER_INVOICE_ID_ASC',
  SupplierInvoiceIdDesc = 'SUPPLIER_INVOICE_ID_DESC',
  PaymentIdAsc = 'PAYMENT_ID_ASC',
  PaymentIdDesc = 'PAYMENT_ID_DESC',
  ExpenseIdAsc = 'EXPENSE_ID_ASC',
  ExpenseIdDesc = 'EXPENSE_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransactionByTransactionIdIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ID_ASC',
  TransactionByTransactionIdIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ID_DESC',
  TransactionByTransactionIdCreatedAsc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_ASC',
  TransactionByTransactionIdCreatedDesc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_DESC',
  TransactionByTransactionIdModifiedAsc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_ASC',
  TransactionByTransactionIdModifiedDesc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_DESC',
  TransactionByTransactionIdAccountIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_ASC',
  TransactionByTransactionIdAccountIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_DESC',
  TransactionByTransactionIdAmountAsc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_ASC',
  TransactionByTransactionIdAmountDesc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_DESC',
  TransactionByTransactionIdExternalIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_ASC',
  TransactionByTransactionIdExternalIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_DESC',
  TransactionByTransactionIdDateAsc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_ASC',
  TransactionByTransactionIdDateDesc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_DESC',
  TransactionByTransactionIdDescriptionAsc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_ASC',
  TransactionByTransactionIdDescriptionDesc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_DESC',
  TransactionByTransactionIdStatusAsc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_ASC',
  TransactionByTransactionIdStatusDesc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_DESC',
  TransactionByTransactionIdReverseTransactionIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_ASC',
  TransactionByTransactionIdReverseTransactionIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_DESC',
  TransactionByTransactionIdSourceAsc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_ASC',
  TransactionByTransactionIdSourceDesc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_DESC',
  TransactionByTransactionIdTransactionImportBatchIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionByTransactionIdTransactionImportBatchIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_DESC',
  TransactionByTransactionIdBalanceAsc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_ASC',
  TransactionByTransactionIdBalanceDesc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_DESC',
  TransactionByTransactionIdCurrencyAsc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_ASC',
  TransactionByTransactionIdCurrencyDesc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_DESC',
  TransactionByTransactionIdCategoryIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_ASC',
  TransactionByTransactionIdCategoryIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_DESC',
  InvoiceByInvoiceIdIdAsc = 'INVOICE_BY_INVOICE_ID__ID_ASC',
  InvoiceByInvoiceIdIdDesc = 'INVOICE_BY_INVOICE_ID__ID_DESC',
  InvoiceByInvoiceIdAmountAsc = 'INVOICE_BY_INVOICE_ID__AMOUNT_ASC',
  InvoiceByInvoiceIdAmountDesc = 'INVOICE_BY_INVOICE_ID__AMOUNT_DESC',
  InvoiceByInvoiceIdCreatedAsc = 'INVOICE_BY_INVOICE_ID__CREATED_ASC',
  InvoiceByInvoiceIdCreatedDesc = 'INVOICE_BY_INVOICE_ID__CREATED_DESC',
  InvoiceByInvoiceIdCurrencyAsc = 'INVOICE_BY_INVOICE_ID__CURRENCY_ASC',
  InvoiceByInvoiceIdCurrencyDesc = 'INVOICE_BY_INVOICE_ID__CURRENCY_DESC',
  InvoiceByInvoiceIdDueAsc = 'INVOICE_BY_INVOICE_ID__DUE_ASC',
  InvoiceByInvoiceIdDueDesc = 'INVOICE_BY_INVOICE_ID__DUE_DESC',
  InvoiceByInvoiceIdKeyAsc = 'INVOICE_BY_INVOICE_ID__KEY_ASC',
  InvoiceByInvoiceIdKeyDesc = 'INVOICE_BY_INVOICE_ID__KEY_DESC',
  InvoiceByInvoiceIdModifiedAsc = 'INVOICE_BY_INVOICE_ID__MODIFIED_ASC',
  InvoiceByInvoiceIdModifiedDesc = 'INVOICE_BY_INVOICE_ID__MODIFIED_DESC',
  InvoiceByInvoiceIdSummaryAsc = 'INVOICE_BY_INVOICE_ID__SUMMARY_ASC',
  InvoiceByInvoiceIdSummaryDesc = 'INVOICE_BY_INVOICE_ID__SUMMARY_DESC',
  InvoiceByInvoiceIdTypeAsc = 'INVOICE_BY_INVOICE_ID__TYPE_ASC',
  InvoiceByInvoiceIdTypeDesc = 'INVOICE_BY_INVOICE_ID__TYPE_DESC',
  InvoiceByInvoiceIdNumberAsc = 'INVOICE_BY_INVOICE_ID__NUMBER_ASC',
  InvoiceByInvoiceIdNumberDesc = 'INVOICE_BY_INVOICE_ID__NUMBER_DESC',
  InvoiceByInvoiceIdQuoteIdAsc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_ASC',
  InvoiceByInvoiceIdQuoteIdDesc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_DESC',
  InvoiceByInvoiceIdVoidedAsc = 'INVOICE_BY_INVOICE_ID__VOIDED_ASC',
  InvoiceByInvoiceIdVoidedDesc = 'INVOICE_BY_INVOICE_ID__VOIDED_DESC',
  InvoiceByInvoiceIdCategoryIdAsc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_ASC',
  InvoiceByInvoiceIdCategoryIdDesc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_DESC',
  InvoiceByInvoiceIdTripIdAsc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_ASC',
  InvoiceByInvoiceIdTripIdDesc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_DESC',
  InvoiceByInvoiceIdPaidAsc = 'INVOICE_BY_INVOICE_ID__PAID_ASC',
  InvoiceByInvoiceIdPaidDesc = 'INVOICE_BY_INVOICE_ID__PAID_DESC',
  InvoiceByInvoiceIdNoteAsc = 'INVOICE_BY_INVOICE_ID__NOTE_ASC',
  InvoiceByInvoiceIdNoteDesc = 'INVOICE_BY_INVOICE_ID__NOTE_DESC',
  InvoiceByInvoiceIdInvoicedAsc = 'INVOICE_BY_INVOICE_ID__INVOICED_ASC',
  InvoiceByInvoiceIdInvoicedDesc = 'INVOICE_BY_INVOICE_ID__INVOICED_DESC',
  InvoiceByInvoiceIdLockedAsc = 'INVOICE_BY_INVOICE_ID__LOCKED_ASC',
  InvoiceByInvoiceIdLockedDesc = 'INVOICE_BY_INVOICE_ID__LOCKED_DESC',
  SupplierInvoiceBySupplierInvoiceIdIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_DESC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdCreatedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_ASC',
  SupplierInvoiceBySupplierInvoiceIdCreatedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_DESC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_ASC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_DESC',
  SupplierInvoiceBySupplierInvoiceIdDueAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_ASC',
  SupplierInvoiceBySupplierInvoiceIdDueDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_DESC',
  SupplierInvoiceBySupplierInvoiceIdKeyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_ASC',
  SupplierInvoiceBySupplierInvoiceIdKeyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_DESC',
  SupplierInvoiceBySupplierInvoiceIdModifiedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_ASC',
  SupplierInvoiceBySupplierInvoiceIdModifiedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_DESC',
  SupplierInvoiceBySupplierInvoiceIdNumberAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_ASC',
  SupplierInvoiceBySupplierInvoiceIdNumberDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_DESC',
  SupplierInvoiceBySupplierInvoiceIdSummaryAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_ASC',
  SupplierInvoiceBySupplierInvoiceIdSummaryDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_DESC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTripIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdTripIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTypeAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_ASC',
  SupplierInvoiceBySupplierInvoiceIdTypeDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_DESC',
  SupplierInvoiceBySupplierInvoiceIdVoidedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_ASC',
  SupplierInvoiceBySupplierInvoiceIdVoidedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_DESC',
  SupplierInvoiceBySupplierInvoiceIdPaidAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_ASC',
  SupplierInvoiceBySupplierInvoiceIdPaidDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_DESC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_DESC',
  PaymentByPaymentIdIdAsc = 'PAYMENT_BY_PAYMENT_ID__ID_ASC',
  PaymentByPaymentIdIdDesc = 'PAYMENT_BY_PAYMENT_ID__ID_DESC',
  PaymentByPaymentIdAmountAsc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_ASC',
  PaymentByPaymentIdAmountDesc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_DESC',
  PaymentByPaymentIdAmountActualAsc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_ACTUAL_ASC',
  PaymentByPaymentIdAmountActualDesc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_ACTUAL_DESC',
  PaymentByPaymentIdCreatedAsc = 'PAYMENT_BY_PAYMENT_ID__CREATED_ASC',
  PaymentByPaymentIdCreatedDesc = 'PAYMENT_BY_PAYMENT_ID__CREATED_DESC',
  PaymentByPaymentIdCurrencyAsc = 'PAYMENT_BY_PAYMENT_ID__CURRENCY_ASC',
  PaymentByPaymentIdCurrencyDesc = 'PAYMENT_BY_PAYMENT_ID__CURRENCY_DESC',
  PaymentByPaymentIdInvoiceIdAsc = 'PAYMENT_BY_PAYMENT_ID__INVOICE_ID_ASC',
  PaymentByPaymentIdInvoiceIdDesc = 'PAYMENT_BY_PAYMENT_ID__INVOICE_ID_DESC',
  PaymentByPaymentIdModifiedAsc = 'PAYMENT_BY_PAYMENT_ID__MODIFIED_ASC',
  PaymentByPaymentIdModifiedDesc = 'PAYMENT_BY_PAYMENT_ID__MODIFIED_DESC',
  PaymentByPaymentIdPaidAsc = 'PAYMENT_BY_PAYMENT_ID__PAID_ASC',
  PaymentByPaymentIdPaidDesc = 'PAYMENT_BY_PAYMENT_ID__PAID_DESC',
  PaymentByPaymentIdReferenceAsc = 'PAYMENT_BY_PAYMENT_ID__REFERENCE_ASC',
  PaymentByPaymentIdReferenceDesc = 'PAYMENT_BY_PAYMENT_ID__REFERENCE_DESC',
  PaymentByPaymentIdSummaryAsc = 'PAYMENT_BY_PAYMENT_ID__SUMMARY_ASC',
  PaymentByPaymentIdSummaryDesc = 'PAYMENT_BY_PAYMENT_ID__SUMMARY_DESC',
  PaymentByPaymentIdCategoryIdAsc = 'PAYMENT_BY_PAYMENT_ID__CATEGORY_ID_ASC',
  PaymentByPaymentIdCategoryIdDesc = 'PAYMENT_BY_PAYMENT_ID__CATEGORY_ID_DESC',
  PaymentByPaymentIdTripIdAsc = 'PAYMENT_BY_PAYMENT_ID__TRIP_ID_ASC',
  PaymentByPaymentIdTripIdDesc = 'PAYMENT_BY_PAYMENT_ID__TRIP_ID_DESC',
  PaymentByPaymentIdTypeAsc = 'PAYMENT_BY_PAYMENT_ID__TYPE_ASC',
  PaymentByPaymentIdTypeDesc = 'PAYMENT_BY_PAYMENT_ID__TYPE_DESC',
  ExpenseByExpenseIdIdAsc = 'EXPENSE_BY_EXPENSE_ID__ID_ASC',
  ExpenseByExpenseIdIdDesc = 'EXPENSE_BY_EXPENSE_ID__ID_DESC',
  ExpenseByExpenseIdAmountAsc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_ASC',
  ExpenseByExpenseIdAmountDesc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_DESC',
  ExpenseByExpenseIdAmountActualAsc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_ACTUAL_ASC',
  ExpenseByExpenseIdAmountActualDesc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_ACTUAL_DESC',
  ExpenseByExpenseIdCreatedAsc = 'EXPENSE_BY_EXPENSE_ID__CREATED_ASC',
  ExpenseByExpenseIdCreatedDesc = 'EXPENSE_BY_EXPENSE_ID__CREATED_DESC',
  ExpenseByExpenseIdCurrencyAsc = 'EXPENSE_BY_EXPENSE_ID__CURRENCY_ASC',
  ExpenseByExpenseIdCurrencyDesc = 'EXPENSE_BY_EXPENSE_ID__CURRENCY_DESC',
  ExpenseByExpenseIdInvoiceIdAsc = 'EXPENSE_BY_EXPENSE_ID__INVOICE_ID_ASC',
  ExpenseByExpenseIdInvoiceIdDesc = 'EXPENSE_BY_EXPENSE_ID__INVOICE_ID_DESC',
  ExpenseByExpenseIdModifiedAsc = 'EXPENSE_BY_EXPENSE_ID__MODIFIED_ASC',
  ExpenseByExpenseIdModifiedDesc = 'EXPENSE_BY_EXPENSE_ID__MODIFIED_DESC',
  ExpenseByExpenseIdPaidAsc = 'EXPENSE_BY_EXPENSE_ID__PAID_ASC',
  ExpenseByExpenseIdPaidDesc = 'EXPENSE_BY_EXPENSE_ID__PAID_DESC',
  ExpenseByExpenseIdSummaryAsc = 'EXPENSE_BY_EXPENSE_ID__SUMMARY_ASC',
  ExpenseByExpenseIdSummaryDesc = 'EXPENSE_BY_EXPENSE_ID__SUMMARY_DESC',
  ExpenseByExpenseIdSupplierIdAsc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_ID_ASC',
  ExpenseByExpenseIdSupplierIdDesc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_ID_DESC',
  ExpenseByExpenseIdReferenceAsc = 'EXPENSE_BY_EXPENSE_ID__REFERENCE_ASC',
  ExpenseByExpenseIdReferenceDesc = 'EXPENSE_BY_EXPENSE_ID__REFERENCE_DESC',
  ExpenseByExpenseIdCategoryIdAsc = 'EXPENSE_BY_EXPENSE_ID__CATEGORY_ID_ASC',
  ExpenseByExpenseIdCategoryIdDesc = 'EXPENSE_BY_EXPENSE_ID__CATEGORY_ID_DESC',
  ExpenseByExpenseIdSupplierInvoiceIdAsc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_INVOICE_ID_ASC',
  ExpenseByExpenseIdSupplierInvoiceIdDesc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_INVOICE_ID_DESC',
  ExpenseByExpenseIdTripIdAsc = 'EXPENSE_BY_EXPENSE_ID__TRIP_ID_ASC',
  ExpenseByExpenseIdTripIdDesc = 'EXPENSE_BY_EXPENSE_ID__TRIP_ID_DESC'
}

/** A condition to be used against `TransactionLink` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TransactionLinkCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `transactionId` field. */
  transactionId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `paymentId` field. */
  paymentId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `expenseId` field. */
  expenseId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `TransactionLink` values. */
export type TransactionLinksConnection = {
  __typename?: 'TransactionLinksConnection';
  /** A list of `TransactionLink` objects. */
  nodes: Array<Maybe<TransactionLink>>;
  /** A list of edges which contains the `TransactionLink` and cursor to aid in pagination. */
  edges: Array<TransactionLinksEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransactionLink` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TransactionLink = Node & {
  __typename?: 'TransactionLink';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  transactionId: Scalars['UUID'];
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status: Scalars['Int'];
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
};

export type Payment = Node & {
  __typename?: 'Payment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created: Scalars['Datetime'];
  currency?: Maybe<Scalars['String']>;
  invoiceId: Scalars['UUID'];
  modified: Scalars['Datetime'];
  paid: Scalars['Datetime'];
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type: Scalars['Int'];
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
};


export type PaymentTransactionLinksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
  condition?: Maybe<TransactionLinkCondition>;
  filter?: Maybe<TransactionLinkFilter>;
};

/** A `TransactionLink` edge in the connection. */
export type TransactionLinksEdge = {
  __typename?: 'TransactionLinksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TransactionLink` at the end of the edge. */
  node?: Maybe<TransactionLink>;
};

/** A `SupplierInvoice` edge in the connection. */
export type SupplierInvoicesEdge = {
  __typename?: 'SupplierInvoicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SupplierInvoice` at the end of the edge. */
  node?: Maybe<SupplierInvoice>;
};

/** Methods to use when ordering `Property`. */
export enum PropertiesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNumberAsc = 'CONTACT_NUMBER_ASC',
  ContactNumberDesc = 'CONTACT_NUMBER_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  NearestAirportAsc = 'NEAREST_AIRPORT_ASC',
  NearestAirportDesc = 'NEAREST_AIRPORT_DESC',
  RegionAsc = 'REGION_ASC',
  RegionDesc = 'REGION_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  ExternalReferenceAsc = 'EXTERNAL_REFERENCE_ASC',
  ExternalReferenceDesc = 'EXTERNAL_REFERENCE_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  HeroMediaIdAsc = 'HERO_MEDIA_ID_ASC',
  HeroMediaIdDesc = 'HERO_MEDIA_ID_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  MapPointIdAsc = 'MAP_POINT_ID_ASC',
  MapPointIdDesc = 'MAP_POINT_ID_DESC',
  PlusCodeAsc = 'PLUS_CODE_ASC',
  PlusCodeDesc = 'PLUS_CODE_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  FeaturedAsc = 'FEATURED_ASC',
  FeaturedDesc = 'FEATURED_DESC',
  FeatureCopyAsc = 'FEATURE_COPY_ASC',
  FeatureCopyDesc = 'FEATURE_COPY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  MediaItemByHeroMediaIdIdAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_ASC',
  MediaItemByHeroMediaIdIdDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_DESC',
  MediaItemByHeroMediaIdContentTypeAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_ASC',
  MediaItemByHeroMediaIdContentTypeDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_DESC',
  MediaItemByHeroMediaIdCreatedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_ASC',
  MediaItemByHeroMediaIdCreatedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_DESC',
  MediaItemByHeroMediaIdModifiedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_ASC',
  MediaItemByHeroMediaIdModifiedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_DESC',
  MediaItemByHeroMediaIdNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_ASC',
  MediaItemByHeroMediaIdNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_DESC',
  MediaItemByHeroMediaIdFileNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_ASC',
  MediaItemByHeroMediaIdFileNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_DESC',
  MediaItemByHeroMediaIdSummaryAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_ASC',
  MediaItemByHeroMediaIdSummaryDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_DESC',
  MediaItemByHeroMediaIdHashAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_ASC',
  MediaItemByHeroMediaIdHashDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_DESC',
  MapPointByMapPointIdIdAsc = 'MAP_POINT_BY_MAP_POINT_ID__ID_ASC',
  MapPointByMapPointIdIdDesc = 'MAP_POINT_BY_MAP_POINT_ID__ID_DESC',
  MapPointByMapPointIdCreatedAsc = 'MAP_POINT_BY_MAP_POINT_ID__CREATED_ASC',
  MapPointByMapPointIdCreatedDesc = 'MAP_POINT_BY_MAP_POINT_ID__CREATED_DESC',
  MapPointByMapPointIdModifiedAsc = 'MAP_POINT_BY_MAP_POINT_ID__MODIFIED_ASC',
  MapPointByMapPointIdModifiedDesc = 'MAP_POINT_BY_MAP_POINT_ID__MODIFIED_DESC',
  MapPointByMapPointIdNameAsc = 'MAP_POINT_BY_MAP_POINT_ID__NAME_ASC',
  MapPointByMapPointIdNameDesc = 'MAP_POINT_BY_MAP_POINT_ID__NAME_DESC',
  MapPointByMapPointIdLatitudeAsc = 'MAP_POINT_BY_MAP_POINT_ID__LATITUDE_ASC',
  MapPointByMapPointIdLatitudeDesc = 'MAP_POINT_BY_MAP_POINT_ID__LATITUDE_DESC',
  MapPointByMapPointIdLongitudeAsc = 'MAP_POINT_BY_MAP_POINT_ID__LONGITUDE_ASC',
  MapPointByMapPointIdLongitudeDesc = 'MAP_POINT_BY_MAP_POINT_ID__LONGITUDE_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC',
  QuoteAccommodationDetailsByPropertyIdCountAsc = 'QUOTE_ACCOMMODATION_DETAILS_BY_PROPERTY_ID__COUNT_ASC',
  QuoteAccommodationDetailsByPropertyIdCountDesc = 'QUOTE_ACCOMMODATION_DETAILS_BY_PROPERTY_ID__COUNT_DESC',
  QuoteDaysByPropertyIdCountAsc = 'QUOTE_DAYS_BY_PROPERTY_ID__COUNT_ASC',
  QuoteDaysByPropertyIdCountDesc = 'QUOTE_DAYS_BY_PROPERTY_ID__COUNT_DESC'
}

/** A condition to be used against `Property` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PropertyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contactNumber` field. */
  contactNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `nearestAirport` field. */
  nearestAirport?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `region` field. */
  region?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `externalReference` field. */
  externalReference?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `heroMediaId` field. */
  heroMediaId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `archived` field. */
  archived?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `mapPointId` field. */
  mapPointId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `plusCode` field. */
  plusCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `featured` field. */
  featured?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `featureCopy` field. */
  featureCopy?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Property` values. */
export type PropertiesConnection = {
  __typename?: 'PropertiesConnection';
  /** A list of `Property` objects. */
  nodes: Array<Maybe<Property>>;
  /** A list of edges which contains the `Property` and cursor to aid in pagination. */
  edges: Array<PropertiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Property` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Property = Node & {
  __typename?: 'Property';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId: Scalars['UUID'];
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetails: QuoteAccommodationDetailsConnection;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDays: QuoteDaysConnection;
};


export type PropertyQuoteAccommodationDetailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
  condition?: Maybe<QuoteAccommodationDetailCondition>;
  filter?: Maybe<QuoteAccommodationDetailFilter>;
};


export type PropertyQuoteDaysArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
  condition?: Maybe<QuoteDayCondition>;
  filter?: Maybe<QuoteDayFilter>;
};

export type MapPoint = Node & {
  __typename?: 'MapPoint';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  name?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
};


export type MapPointPropertiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
  condition?: Maybe<PropertyCondition>;
  filter?: Maybe<PropertyFilter>;
};

/** Methods to use when ordering `QuoteAccommodationDetail`. */
export enum QuoteAccommodationDetailsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderAsc = 'ORDER_ASC',
  OrderDesc = 'ORDER_DESC',
  NightsAsc = 'NIGHTS_ASC',
  NightsDesc = 'NIGHTS_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PropertyIdAsc = 'PROPERTY_ID_ASC',
  PropertyIdDesc = 'PROPERTY_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  BasisAsc = 'BASIS_ASC',
  BasisDesc = 'BASIS_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  ConfirmationAsc = 'CONFIRMATION_ASC',
  ConfirmationDesc = 'CONFIRMATION_DESC',
  BeverageInclusionsAsc = 'BEVERAGE_INCLUSIONS_ASC',
  BeverageInclusionsDesc = 'BEVERAGE_INCLUSIONS_DESC',
  FoodInclusionsAsc = 'FOOD_INCLUSIONS_ASC',
  FoodInclusionsDesc = 'FOOD_INCLUSIONS_DESC',
  RoomTypeAsc = 'ROOM_TYPE_ASC',
  RoomTypeDesc = 'ROOM_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertyByPropertyIdIdAsc = 'PROPERTY_BY_PROPERTY_ID__ID_ASC',
  PropertyByPropertyIdIdDesc = 'PROPERTY_BY_PROPERTY_ID__ID_DESC',
  PropertyByPropertyIdCreatedAsc = 'PROPERTY_BY_PROPERTY_ID__CREATED_ASC',
  PropertyByPropertyIdCreatedDesc = 'PROPERTY_BY_PROPERTY_ID__CREATED_DESC',
  PropertyByPropertyIdModifiedAsc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_ASC',
  PropertyByPropertyIdModifiedDesc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_DESC',
  PropertyByPropertyIdNameAsc = 'PROPERTY_BY_PROPERTY_ID__NAME_ASC',
  PropertyByPropertyIdNameDesc = 'PROPERTY_BY_PROPERTY_ID__NAME_DESC',
  PropertyByPropertyIdCityAsc = 'PROPERTY_BY_PROPERTY_ID__CITY_ASC',
  PropertyByPropertyIdCityDesc = 'PROPERTY_BY_PROPERTY_ID__CITY_DESC',
  PropertyByPropertyIdContactEmailAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_ASC',
  PropertyByPropertyIdContactEmailDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_DESC',
  PropertyByPropertyIdContactNumberAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_ASC',
  PropertyByPropertyIdContactNumberDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_DESC',
  PropertyByPropertyIdLatitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_ASC',
  PropertyByPropertyIdLatitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_DESC',
  PropertyByPropertyIdLongitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_ASC',
  PropertyByPropertyIdLongitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_DESC',
  PropertyByPropertyIdNearestAirportAsc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_ASC',
  PropertyByPropertyIdNearestAirportDesc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_DESC',
  PropertyByPropertyIdRegionAsc = 'PROPERTY_BY_PROPERTY_ID__REGION_ASC',
  PropertyByPropertyIdRegionDesc = 'PROPERTY_BY_PROPERTY_ID__REGION_DESC',
  PropertyByPropertyIdSummaryAsc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_ASC',
  PropertyByPropertyIdSummaryDesc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_DESC',
  PropertyByPropertyIdExternalReferenceAsc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_ASC',
  PropertyByPropertyIdExternalReferenceDesc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_DESC',
  PropertyByPropertyIdUrlAsc = 'PROPERTY_BY_PROPERTY_ID__URL_ASC',
  PropertyByPropertyIdUrlDesc = 'PROPERTY_BY_PROPERTY_ID__URL_DESC',
  PropertyByPropertyIdGalleryIdAsc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_ASC',
  PropertyByPropertyIdGalleryIdDesc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_DESC',
  PropertyByPropertyIdHeroMediaIdAsc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_ASC',
  PropertyByPropertyIdHeroMediaIdDesc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_DESC',
  PropertyByPropertyIdNotesAsc = 'PROPERTY_BY_PROPERTY_ID__NOTES_ASC',
  PropertyByPropertyIdNotesDesc = 'PROPERTY_BY_PROPERTY_ID__NOTES_DESC',
  PropertyByPropertyIdArchivedAsc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_ASC',
  PropertyByPropertyIdArchivedDesc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_DESC',
  PropertyByPropertyIdMapPointIdAsc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_ASC',
  PropertyByPropertyIdMapPointIdDesc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_DESC',
  PropertyByPropertyIdPlusCodeAsc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_ASC',
  PropertyByPropertyIdPlusCodeDesc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_DESC',
  PropertyByPropertyIdCountryIdAsc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_ASC',
  PropertyByPropertyIdCountryIdDesc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_DESC',
  PropertyByPropertyIdFeaturedAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_ASC',
  PropertyByPropertyIdFeaturedDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_DESC',
  PropertyByPropertyIdFeatureCopyAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_ASC',
  PropertyByPropertyIdFeatureCopyDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdTotalAsc = 'QUOTE_BY_QUOTE_ID__TOTAL_ASC',
  QuoteByQuoteIdTotalDesc = 'QUOTE_BY_QUOTE_ID__TOTAL_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdLastViewedAsc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByQuoteIdLastViewedDesc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuotePublicByQuoteIdIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_ASC',
  QuotePublicByQuoteIdIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_DESC',
  QuotePublicByQuoteIdKeyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_ASC',
  QuotePublicByQuoteIdKeyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_DESC',
  QuotePublicByQuoteIdStatusAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_ASC',
  QuotePublicByQuoteIdStatusDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_DESC',
  QuotePublicByQuoteIdStartAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_ASC',
  QuotePublicByQuoteIdStartDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_DESC',
  QuotePublicByQuoteIdDurationAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_ASC',
  QuotePublicByQuoteIdDurationDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_DESC',
  QuotePublicByQuoteIdTravellerCountAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuotePublicByQuoteIdTravellerCountDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuotePublicByQuoteIdTotalAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_ASC',
  QuotePublicByQuoteIdTotalDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_DESC',
  QuotePublicByQuoteIdHeroIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_ASC',
  QuotePublicByQuoteIdHeroIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_DESC',
  QuotePublicByQuoteIdTripIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_ASC',
  QuotePublicByQuoteIdTripIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_DESC',
  QuotePublicByQuoteIdLockedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_ASC',
  QuotePublicByQuoteIdLockedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_DESC',
  QuotePublicByQuoteIdBaseCurrencyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuotePublicByQuoteIdBaseCurrencyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuotePublicByQuoteIdInclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuotePublicByQuoteIdInclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuotePublicByQuoteIdExclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuotePublicByQuoteIdExclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuotePublicByQuoteIdExpiresAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_ASC',
  QuotePublicByQuoteIdExpiresDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_DESC',
  QuotePublicByQuoteIdUserIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_ASC',
  QuotePublicByQuoteIdUserIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_DESC',
  QuoteDaysByAccommodationIdCountAsc = 'QUOTE_DAYS_BY_ACCOMMODATION_ID__COUNT_ASC',
  QuoteDaysByAccommodationIdCountDesc = 'QUOTE_DAYS_BY_ACCOMMODATION_ID__COUNT_DESC'
}

/** A condition to be used against `QuoteAccommodationDetail` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteAccommodationDetailCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `order` field. */
  order?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `nights` field. */
  nights?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `propertyId` field. */
  propertyId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `basis` field. */
  basis?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `confirmation` field. */
  confirmation?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `beverageInclusions` field. */
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `foodInclusions` field. */
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `roomType` field. */
  roomType?: Maybe<Scalars['String']>;
};

/** A connection to a list of `QuoteAccommodationDetail` values. */
export type QuoteAccommodationDetailsConnection = {
  __typename?: 'QuoteAccommodationDetailsConnection';
  /** A list of `QuoteAccommodationDetail` objects. */
  nodes: Array<Maybe<QuoteAccommodationDetail>>;
  /** A list of edges which contains the `QuoteAccommodationDetail` and cursor to aid in pagination. */
  edges: Array<QuoteAccommodationDetailsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteAccommodationDetail` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteAccommodationDetail = Node & {
  __typename?: 'QuoteAccommodationDetail';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  order: Scalars['Int'];
  nights: Scalars['Int'];
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDaysByAccommodationId: QuoteDaysConnection;
};


export type QuoteAccommodationDetailQuoteDaysByAccommodationIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
  condition?: Maybe<QuoteDayCondition>;
  filter?: Maybe<QuoteDayFilter>;
};

export type QuotePublic = Node & {
  __typename?: 'QuotePublic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id?: Maybe<Scalars['UUID']>;
  key: Scalars['String'];
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetailsByQuoteId: QuoteAccommodationDetailsConnection;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDaysByQuoteId: QuoteDaysConnection;
};


export type QuotePublicQuoteAccommodationDetailsByQuoteIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
  condition?: Maybe<QuoteAccommodationDetailCondition>;
  filter?: Maybe<QuoteAccommodationDetailFilter>;
};


export type QuotePublicQuoteDaysByQuoteIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
  condition?: Maybe<QuoteDayCondition>;
  filter?: Maybe<QuoteDayFilter>;
};

export type QuoteHero = Node & {
  __typename?: 'QuoteHero';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  imageId?: Maybe<Scalars['UUID']>;
  style?: Maybe<Scalars['String']>;
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  /** Reads and enables pagination through a set of `Quote`. */
  quotesByHeroId: QuotesConnection;
  /** Reads and enables pagination through a set of `QuotePublic`. */
  quotePublicsByHeroId: QuotePublicsConnection;
};


export type QuoteHeroQuotesByHeroIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotesOrderBy>>;
  condition?: Maybe<QuoteCondition>;
  filter?: Maybe<QuoteFilter>;
};


export type QuoteHeroQuotePublicsByHeroIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotePublicsOrderBy>>;
  condition?: Maybe<QuotePublicCondition>;
  filter?: Maybe<QuotePublicFilter>;
};

/** Methods to use when ordering `Quote`. */
export enum QuotesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  DepositAsc = 'DEPOSIT_ASC',
  DepositDesc = 'DEPOSIT_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  ExpiresAsc = 'EXPIRES_ASC',
  ExpiresDesc = 'EXPIRES_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC',
  AdjustmentAsc = 'ADJUSTMENT_ASC',
  AdjustmentDesc = 'ADJUSTMENT_DESC',
  BaseCurrencyAsc = 'BASE_CURRENCY_ASC',
  BaseCurrencyDesc = 'BASE_CURRENCY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  HeroImageIdAsc = 'HERO_IMAGE_ID_ASC',
  HeroImageIdDesc = 'HERO_IMAGE_ID_DESC',
  ExclusionsAsc = 'EXCLUSIONS_ASC',
  ExclusionsDesc = 'EXCLUSIONS_DESC',
  InclusionsAsc = 'INCLUSIONS_ASC',
  InclusionsDesc = 'INCLUSIONS_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  AgentMarginAsc = 'AGENT_MARGIN_ASC',
  AgentMarginDesc = 'AGENT_MARGIN_DESC',
  TravellerCountAsc = 'TRAVELLER_COUNT_ASC',
  TravellerCountDesc = 'TRAVELLER_COUNT_DESC',
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  LastViewedAsc = 'LAST_VIEWED_ASC',
  LastViewedDesc = 'LAST_VIEWED_DESC',
  HeroIdAsc = 'HERO_ID_ASC',
  HeroIdDesc = 'HERO_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  MediaItemByHeroImageIdIdAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__ID_ASC',
  MediaItemByHeroImageIdIdDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__ID_DESC',
  MediaItemByHeroImageIdContentTypeAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CONTENT_TYPE_ASC',
  MediaItemByHeroImageIdContentTypeDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CONTENT_TYPE_DESC',
  MediaItemByHeroImageIdCreatedAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CREATED_ASC',
  MediaItemByHeroImageIdCreatedDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CREATED_DESC',
  MediaItemByHeroImageIdModifiedAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__MODIFIED_ASC',
  MediaItemByHeroImageIdModifiedDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__MODIFIED_DESC',
  MediaItemByHeroImageIdNameAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__NAME_ASC',
  MediaItemByHeroImageIdNameDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__NAME_DESC',
  MediaItemByHeroImageIdFileNameAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__FILE_NAME_ASC',
  MediaItemByHeroImageIdFileNameDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__FILE_NAME_DESC',
  MediaItemByHeroImageIdSummaryAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__SUMMARY_ASC',
  MediaItemByHeroImageIdSummaryDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__SUMMARY_DESC',
  MediaItemByHeroImageIdHashAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__HASH_ASC',
  MediaItemByHeroImageIdHashDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__HASH_DESC',
  QuoteHeroByHeroIdIdAsc = 'QUOTE_HERO_BY_HERO_ID__ID_ASC',
  QuoteHeroByHeroIdIdDesc = 'QUOTE_HERO_BY_HERO_ID__ID_DESC',
  QuoteHeroByHeroIdTitleAsc = 'QUOTE_HERO_BY_HERO_ID__TITLE_ASC',
  QuoteHeroByHeroIdTitleDesc = 'QUOTE_HERO_BY_HERO_ID__TITLE_DESC',
  QuoteHeroByHeroIdSubtitleAsc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_ASC',
  QuoteHeroByHeroIdSubtitleDesc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_DESC',
  QuoteHeroByHeroIdImageIdAsc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_ASC',
  QuoteHeroByHeroIdImageIdDesc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_DESC',
  QuoteHeroByHeroIdStyleAsc = 'QUOTE_HERO_BY_HERO_ID__STYLE_ASC',
  QuoteHeroByHeroIdStyleDesc = 'QUOTE_HERO_BY_HERO_ID__STYLE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  InvoicesByQuoteIdCountAsc = 'INVOICES_BY_QUOTE_ID__COUNT_ASC',
  InvoicesByQuoteIdCountDesc = 'INVOICES_BY_QUOTE_ID__COUNT_DESC',
  TripsByActiveQuoteIdCountAsc = 'TRIPS_BY_ACTIVE_QUOTE_ID__COUNT_ASC',
  TripsByActiveQuoteIdCountDesc = 'TRIPS_BY_ACTIVE_QUOTE_ID__COUNT_DESC',
  EmailsByQuoteIdCountAsc = 'EMAILS_BY_QUOTE_ID__COUNT_ASC',
  EmailsByQuoteIdCountDesc = 'EMAILS_BY_QUOTE_ID__COUNT_DESC',
  QuoteViewsByQuoteIdCountAsc = 'QUOTE_VIEWS_BY_QUOTE_ID__COUNT_ASC',
  QuoteViewsByQuoteIdCountDesc = 'QUOTE_VIEWS_BY_QUOTE_ID__COUNT_DESC',
  QuoteAccommodationDetailsByQuoteIdCountAsc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_ASC',
  QuoteAccommodationDetailsByQuoteIdCountDesc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_DESC',
  QuoteCurrenciesByQuoteIdCountAsc = 'QUOTE_CURRENCIES_BY_QUOTE_ID__COUNT_ASC',
  QuoteCurrenciesByQuoteIdCountDesc = 'QUOTE_CURRENCIES_BY_QUOTE_ID__COUNT_DESC',
  QuoteDaysByQuoteIdCountAsc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_ASC',
  QuoteDaysByQuoteIdCountDesc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_DESC',
  QuoteFinanceLineItemsByQuoteIdCountAsc = 'QUOTE_FINANCE_LINE_ITEMS_BY_QUOTE_ID__COUNT_ASC',
  QuoteFinanceLineItemsByQuoteIdCountDesc = 'QUOTE_FINANCE_LINE_ITEMS_BY_QUOTE_ID__COUNT_DESC'
}

/** A condition to be used against `Quote` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `start` field. */
  start?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `deposit` field. */
  deposit?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `key` field. */
  key?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `expires` field. */
  expires?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `total` field. */
  total?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `adjustment` field. */
  adjustment?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `baseCurrency` field. */
  baseCurrency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `heroImageId` field. */
  heroImageId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `exclusions` field. */
  exclusions?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inclusions` field. */
  inclusions?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `agentMargin` field. */
  agentMargin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `travellerCount` field. */
  travellerCount?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `archived` field. */
  archived?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `lastViewed` field. */
  lastViewed?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `heroId` field. */
  heroId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `Quote` values. */
export type QuotesConnection = {
  __typename?: 'QuotesConnection';
  /** A list of `Quote` objects. */
  nodes: Array<Maybe<Quote>>;
  /** A list of edges which contains the `Quote` and cursor to aid in pagination. */
  edges: Array<QuotesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Quote` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Quote` edge in the connection. */
export type QuotesEdge = {
  __typename?: 'QuotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Quote` at the end of the edge. */
  node?: Maybe<Quote>;
};

/** Methods to use when ordering `QuotePublic`. */
export enum QuotePublicsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  TravellerCountAsc = 'TRAVELLER_COUNT_ASC',
  TravellerCountDesc = 'TRAVELLER_COUNT_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC',
  HeroIdAsc = 'HERO_ID_ASC',
  HeroIdDesc = 'HERO_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  BaseCurrencyAsc = 'BASE_CURRENCY_ASC',
  BaseCurrencyDesc = 'BASE_CURRENCY_DESC',
  InclusionsAsc = 'INCLUSIONS_ASC',
  InclusionsDesc = 'INCLUSIONS_DESC',
  ExclusionsAsc = 'EXCLUSIONS_ASC',
  ExclusionsDesc = 'EXCLUSIONS_DESC',
  ExpiresAsc = 'EXPIRES_ASC',
  ExpiresDesc = 'EXPIRES_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  QuoteHeroByHeroIdIdAsc = 'QUOTE_HERO_BY_HERO_ID__ID_ASC',
  QuoteHeroByHeroIdIdDesc = 'QUOTE_HERO_BY_HERO_ID__ID_DESC',
  QuoteHeroByHeroIdTitleAsc = 'QUOTE_HERO_BY_HERO_ID__TITLE_ASC',
  QuoteHeroByHeroIdTitleDesc = 'QUOTE_HERO_BY_HERO_ID__TITLE_DESC',
  QuoteHeroByHeroIdSubtitleAsc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_ASC',
  QuoteHeroByHeroIdSubtitleDesc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_DESC',
  QuoteHeroByHeroIdImageIdAsc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_ASC',
  QuoteHeroByHeroIdImageIdDesc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_DESC',
  QuoteHeroByHeroIdStyleAsc = 'QUOTE_HERO_BY_HERO_ID__STYLE_ASC',
  QuoteHeroByHeroIdStyleDesc = 'QUOTE_HERO_BY_HERO_ID__STYLE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  QuoteAccommodationDetailsByQuoteIdCountAsc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_ASC',
  QuoteAccommodationDetailsByQuoteIdCountDesc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_DESC',
  QuoteDaysByQuoteIdCountAsc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_ASC',
  QuoteDaysByQuoteIdCountDesc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_DESC'
}

/** A condition to be used against `QuotePublic` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuotePublicCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `key` field. */
  key?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `start` field. */
  start?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `travellerCount` field. */
  travellerCount?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `total` field. */
  total?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `heroId` field. */
  heroId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `baseCurrency` field. */
  baseCurrency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `inclusions` field. */
  inclusions?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `exclusions` field. */
  exclusions?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `expires` field. */
  expires?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `QuotePublic` values. */
export type QuotePublicsConnection = {
  __typename?: 'QuotePublicsConnection';
  /** A list of `QuotePublic` objects. */
  nodes: Array<Maybe<QuotePublic>>;
  /** A list of edges which contains the `QuotePublic` and cursor to aid in pagination. */
  edges: Array<QuotePublicsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuotePublic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `QuotePublic` edge in the connection. */
export type QuotePublicsEdge = {
  __typename?: 'QuotePublicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuotePublic` at the end of the edge. */
  node?: Maybe<QuotePublic>;
};

export type User = Node & {
  __typename?: 'User';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  /** Reads and enables pagination through a set of `Note`. */
  notes: NotesConnection;
  /** Reads and enables pagination through a set of `Quote`. */
  quotes: QuotesConnection;
  /** Reads and enables pagination through a set of `Reminder`. */
  reminders: RemindersConnection;
  /** Reads and enables pagination through a set of `TransactionNote`. */
  transactionNotes: TransactionNotesConnection;
  /** Reads and enables pagination through a set of `QuotePublic`. */
  quotePublics: QuotePublicsConnection;
};


export type UserTripsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};


export type UserEmailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EmailsOrderBy>>;
  condition?: Maybe<EmailCondition>;
  filter?: Maybe<EmailFilter>;
};


export type UserNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotesOrderBy>>;
  condition?: Maybe<NoteCondition>;
  filter?: Maybe<NoteFilter>;
};


export type UserQuotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotesOrderBy>>;
  condition?: Maybe<QuoteCondition>;
  filter?: Maybe<QuoteFilter>;
};


export type UserRemindersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<RemindersOrderBy>>;
  condition?: Maybe<ReminderCondition>;
  filter?: Maybe<ReminderFilter>;
};


export type UserTransactionNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionNotesOrderBy>>;
  condition?: Maybe<TransactionNoteCondition>;
  filter?: Maybe<TransactionNoteFilter>;
};


export type UserQuotePublicsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotePublicsOrderBy>>;
  condition?: Maybe<QuotePublicCondition>;
  filter?: Maybe<QuotePublicFilter>;
};

/** Methods to use when ordering `Email`. */
export enum EmailsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  RecipientsAsc = 'RECIPIENTS_ASC',
  RecipientsDesc = 'RECIPIENTS_DESC',
  SubjectAsc = 'SUBJECT_ASC',
  SubjectDesc = 'SUBJECT_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdTotalAsc = 'QUOTE_BY_QUOTE_ID__TOTAL_ASC',
  QuoteByQuoteIdTotalDesc = 'QUOTE_BY_QUOTE_ID__TOTAL_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdLastViewedAsc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByQuoteIdLastViewedDesc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC'
}

/** A condition to be used against `Email` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EmailCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recipients` field. */
  recipients?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Email` values. */
export type EmailsConnection = {
  __typename?: 'EmailsConnection';
  /** A list of `Email` objects. */
  nodes: Array<Maybe<Email>>;
  /** A list of edges which contains the `Email` and cursor to aid in pagination. */
  edges: Array<EmailsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Email` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Email = Node & {
  __typename?: 'Email';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  body?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId: Scalars['UUID'];
  customerId: Scalars['UUID'];
  quoteId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
};

/** A `Email` edge in the connection. */
export type EmailsEdge = {
  __typename?: 'EmailsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Email` at the end of the edge. */
  node?: Maybe<Email>;
};

/** Methods to use when ordering `Note`. */
export enum NotesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC'
}

/** A condition to be used against `Note` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NoteCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Note` values. */
export type NotesConnection = {
  __typename?: 'NotesConnection';
  /** A list of `Note` objects. */
  nodes: Array<Maybe<Note>>;
  /** A list of edges which contains the `Note` and cursor to aid in pagination. */
  edges: Array<NotesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Note` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Note = Node & {
  __typename?: 'Note';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  body?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  tripId?: Maybe<Scalars['UUID']>;
  userId: Scalars['UUID'];
  modified: Scalars['Datetime'];
  title?: Maybe<Scalars['String']>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
};

/** A `Note` edge in the connection. */
export type NotesEdge = {
  __typename?: 'NotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Note` at the end of the edge. */
  node?: Maybe<Note>;
};

/** Methods to use when ordering `Reminder`. */
export enum RemindersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC'
}

/** A condition to be used against `Reminder` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReminderCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Reminder` values. */
export type RemindersConnection = {
  __typename?: 'RemindersConnection';
  /** A list of `Reminder` objects. */
  nodes: Array<Maybe<Reminder>>;
  /** A list of edges which contains the `Reminder` and cursor to aid in pagination. */
  edges: Array<RemindersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Reminder` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Reminder = Node & {
  __typename?: 'Reminder';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  body?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  userId: Scalars['UUID'];
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
};

/** A `Reminder` edge in the connection. */
export type RemindersEdge = {
  __typename?: 'RemindersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Reminder` at the end of the edge. */
  node?: Maybe<Reminder>;
};

/** Methods to use when ordering `TransactionNote`. */
export enum TransactionNotesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  TransactionIdAsc = 'TRANSACTION_ID_ASC',
  TransactionIdDesc = 'TRANSACTION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  TransactionByTransactionIdIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ID_ASC',
  TransactionByTransactionIdIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ID_DESC',
  TransactionByTransactionIdCreatedAsc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_ASC',
  TransactionByTransactionIdCreatedDesc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_DESC',
  TransactionByTransactionIdModifiedAsc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_ASC',
  TransactionByTransactionIdModifiedDesc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_DESC',
  TransactionByTransactionIdAccountIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_ASC',
  TransactionByTransactionIdAccountIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_DESC',
  TransactionByTransactionIdAmountAsc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_ASC',
  TransactionByTransactionIdAmountDesc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_DESC',
  TransactionByTransactionIdExternalIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_ASC',
  TransactionByTransactionIdExternalIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_DESC',
  TransactionByTransactionIdDateAsc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_ASC',
  TransactionByTransactionIdDateDesc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_DESC',
  TransactionByTransactionIdDescriptionAsc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_ASC',
  TransactionByTransactionIdDescriptionDesc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_DESC',
  TransactionByTransactionIdStatusAsc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_ASC',
  TransactionByTransactionIdStatusDesc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_DESC',
  TransactionByTransactionIdReverseTransactionIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_ASC',
  TransactionByTransactionIdReverseTransactionIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_DESC',
  TransactionByTransactionIdSourceAsc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_ASC',
  TransactionByTransactionIdSourceDesc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_DESC',
  TransactionByTransactionIdTransactionImportBatchIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionByTransactionIdTransactionImportBatchIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_DESC',
  TransactionByTransactionIdBalanceAsc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_ASC',
  TransactionByTransactionIdBalanceDesc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_DESC',
  TransactionByTransactionIdCurrencyAsc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_ASC',
  TransactionByTransactionIdCurrencyDesc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_DESC',
  TransactionByTransactionIdCategoryIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_ASC',
  TransactionByTransactionIdCategoryIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_DESC'
}

/** A condition to be used against `TransactionNote` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TransactionNoteCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `transactionId` field. */
  transactionId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `TransactionNote` values. */
export type TransactionNotesConnection = {
  __typename?: 'TransactionNotesConnection';
  /** A list of `TransactionNote` objects. */
  nodes: Array<Maybe<TransactionNote>>;
  /** A list of edges which contains the `TransactionNote` and cursor to aid in pagination. */
  edges: Array<TransactionNotesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransactionNote` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TransactionNote = Node & {
  __typename?: 'TransactionNote';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  userId: Scalars['UUID'];
  message?: Maybe<Scalars['String']>;
  transactionId: Scalars['UUID'];
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
};

/** A `TransactionNote` edge in the connection. */
export type TransactionNotesEdge = {
  __typename?: 'TransactionNotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TransactionNote` at the end of the edge. */
  node?: Maybe<TransactionNote>;
};

/** Methods to use when ordering `QuoteDay`. */
export enum QuoteDaysOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  OrderAsc = 'ORDER_ASC',
  OrderDesc = 'ORDER_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  ActivitySummaryAsc = 'ACTIVITY_SUMMARY_ASC',
  ActivitySummaryDesc = 'ACTIVITY_SUMMARY_DESC',
  ActivityDetailAsc = 'ACTIVITY_DETAIL_ASC',
  ActivityDetailDesc = 'ACTIVITY_DETAIL_DESC',
  AccommodationIdAsc = 'ACCOMMODATION_ID_ASC',
  AccommodationIdDesc = 'ACCOMMODATION_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  PropertyIdAsc = 'PROPERTY_ID_ASC',
  PropertyIdDesc = 'PROPERTY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteAccommodationDetailByAccommodationIdIdAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ID_ASC',
  QuoteAccommodationDetailByAccommodationIdIdDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ID_DESC',
  QuoteAccommodationDetailByAccommodationIdOrderAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ORDER_ASC',
  QuoteAccommodationDetailByAccommodationIdOrderDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ORDER_DESC',
  QuoteAccommodationDetailByAccommodationIdNightsAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NIGHTS_ASC',
  QuoteAccommodationDetailByAccommodationIdNightsDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NIGHTS_DESC',
  QuoteAccommodationDetailByAccommodationIdNotesAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NOTES_ASC',
  QuoteAccommodationDetailByAccommodationIdNotesDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NOTES_DESC',
  QuoteAccommodationDetailByAccommodationIdPropertyIdAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__PROPERTY_ID_ASC',
  QuoteAccommodationDetailByAccommodationIdPropertyIdDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__PROPERTY_ID_DESC',
  QuoteAccommodationDetailByAccommodationIdQuoteIdAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__QUOTE_ID_ASC',
  QuoteAccommodationDetailByAccommodationIdQuoteIdDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__QUOTE_ID_DESC',
  QuoteAccommodationDetailByAccommodationIdBasisAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BASIS_ASC',
  QuoteAccommodationDetailByAccommodationIdBasisDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BASIS_DESC',
  QuoteAccommodationDetailByAccommodationIdSummaryAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__SUMMARY_ASC',
  QuoteAccommodationDetailByAccommodationIdSummaryDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__SUMMARY_DESC',
  QuoteAccommodationDetailByAccommodationIdConfirmationAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__CONFIRMATION_ASC',
  QuoteAccommodationDetailByAccommodationIdConfirmationDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__CONFIRMATION_DESC',
  QuoteAccommodationDetailByAccommodationIdBeverageInclusionsAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BEVERAGE_INCLUSIONS_ASC',
  QuoteAccommodationDetailByAccommodationIdBeverageInclusionsDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BEVERAGE_INCLUSIONS_DESC',
  QuoteAccommodationDetailByAccommodationIdFoodInclusionsAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__FOOD_INCLUSIONS_ASC',
  QuoteAccommodationDetailByAccommodationIdFoodInclusionsDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__FOOD_INCLUSIONS_DESC',
  QuoteAccommodationDetailByAccommodationIdRoomTypeAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ROOM_TYPE_ASC',
  QuoteAccommodationDetailByAccommodationIdRoomTypeDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ROOM_TYPE_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdTotalAsc = 'QUOTE_BY_QUOTE_ID__TOTAL_ASC',
  QuoteByQuoteIdTotalDesc = 'QUOTE_BY_QUOTE_ID__TOTAL_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdLastViewedAsc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByQuoteIdLastViewedDesc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  PropertyByPropertyIdIdAsc = 'PROPERTY_BY_PROPERTY_ID__ID_ASC',
  PropertyByPropertyIdIdDesc = 'PROPERTY_BY_PROPERTY_ID__ID_DESC',
  PropertyByPropertyIdCreatedAsc = 'PROPERTY_BY_PROPERTY_ID__CREATED_ASC',
  PropertyByPropertyIdCreatedDesc = 'PROPERTY_BY_PROPERTY_ID__CREATED_DESC',
  PropertyByPropertyIdModifiedAsc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_ASC',
  PropertyByPropertyIdModifiedDesc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_DESC',
  PropertyByPropertyIdNameAsc = 'PROPERTY_BY_PROPERTY_ID__NAME_ASC',
  PropertyByPropertyIdNameDesc = 'PROPERTY_BY_PROPERTY_ID__NAME_DESC',
  PropertyByPropertyIdCityAsc = 'PROPERTY_BY_PROPERTY_ID__CITY_ASC',
  PropertyByPropertyIdCityDesc = 'PROPERTY_BY_PROPERTY_ID__CITY_DESC',
  PropertyByPropertyIdContactEmailAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_ASC',
  PropertyByPropertyIdContactEmailDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_DESC',
  PropertyByPropertyIdContactNumberAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_ASC',
  PropertyByPropertyIdContactNumberDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_DESC',
  PropertyByPropertyIdLatitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_ASC',
  PropertyByPropertyIdLatitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_DESC',
  PropertyByPropertyIdLongitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_ASC',
  PropertyByPropertyIdLongitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_DESC',
  PropertyByPropertyIdNearestAirportAsc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_ASC',
  PropertyByPropertyIdNearestAirportDesc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_DESC',
  PropertyByPropertyIdRegionAsc = 'PROPERTY_BY_PROPERTY_ID__REGION_ASC',
  PropertyByPropertyIdRegionDesc = 'PROPERTY_BY_PROPERTY_ID__REGION_DESC',
  PropertyByPropertyIdSummaryAsc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_ASC',
  PropertyByPropertyIdSummaryDesc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_DESC',
  PropertyByPropertyIdExternalReferenceAsc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_ASC',
  PropertyByPropertyIdExternalReferenceDesc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_DESC',
  PropertyByPropertyIdUrlAsc = 'PROPERTY_BY_PROPERTY_ID__URL_ASC',
  PropertyByPropertyIdUrlDesc = 'PROPERTY_BY_PROPERTY_ID__URL_DESC',
  PropertyByPropertyIdGalleryIdAsc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_ASC',
  PropertyByPropertyIdGalleryIdDesc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_DESC',
  PropertyByPropertyIdHeroMediaIdAsc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_ASC',
  PropertyByPropertyIdHeroMediaIdDesc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_DESC',
  PropertyByPropertyIdNotesAsc = 'PROPERTY_BY_PROPERTY_ID__NOTES_ASC',
  PropertyByPropertyIdNotesDesc = 'PROPERTY_BY_PROPERTY_ID__NOTES_DESC',
  PropertyByPropertyIdArchivedAsc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_ASC',
  PropertyByPropertyIdArchivedDesc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_DESC',
  PropertyByPropertyIdMapPointIdAsc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_ASC',
  PropertyByPropertyIdMapPointIdDesc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_DESC',
  PropertyByPropertyIdPlusCodeAsc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_ASC',
  PropertyByPropertyIdPlusCodeDesc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_DESC',
  PropertyByPropertyIdCountryIdAsc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_ASC',
  PropertyByPropertyIdCountryIdDesc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_DESC',
  PropertyByPropertyIdFeaturedAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_ASC',
  PropertyByPropertyIdFeaturedDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_DESC',
  PropertyByPropertyIdFeatureCopyAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_ASC',
  PropertyByPropertyIdFeatureCopyDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_DESC',
  QuotePublicByQuoteIdIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_ASC',
  QuotePublicByQuoteIdIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_DESC',
  QuotePublicByQuoteIdKeyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_ASC',
  QuotePublicByQuoteIdKeyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_DESC',
  QuotePublicByQuoteIdStatusAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_ASC',
  QuotePublicByQuoteIdStatusDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_DESC',
  QuotePublicByQuoteIdStartAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_ASC',
  QuotePublicByQuoteIdStartDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_DESC',
  QuotePublicByQuoteIdDurationAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_ASC',
  QuotePublicByQuoteIdDurationDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_DESC',
  QuotePublicByQuoteIdTravellerCountAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuotePublicByQuoteIdTravellerCountDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuotePublicByQuoteIdTotalAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_ASC',
  QuotePublicByQuoteIdTotalDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_DESC',
  QuotePublicByQuoteIdHeroIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_ASC',
  QuotePublicByQuoteIdHeroIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_DESC',
  QuotePublicByQuoteIdTripIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_ASC',
  QuotePublicByQuoteIdTripIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_DESC',
  QuotePublicByQuoteIdLockedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_ASC',
  QuotePublicByQuoteIdLockedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_DESC',
  QuotePublicByQuoteIdBaseCurrencyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuotePublicByQuoteIdBaseCurrencyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuotePublicByQuoteIdInclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuotePublicByQuoteIdInclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuotePublicByQuoteIdExclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuotePublicByQuoteIdExclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuotePublicByQuoteIdExpiresAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_ASC',
  QuotePublicByQuoteIdExpiresDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_DESC',
  QuotePublicByQuoteIdUserIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_ASC',
  QuotePublicByQuoteIdUserIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_DESC',
  QuoteDayDestinationsByDayIdCountAsc = 'QUOTE_DAY_DESTINATIONS_BY_DAY_ID__COUNT_ASC',
  QuoteDayDestinationsByDayIdCountDesc = 'QUOTE_DAY_DESTINATIONS_BY_DAY_ID__COUNT_DESC'
}

/** A condition to be used against `QuoteDay` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteDayCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `order` field. */
  order?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `activitySummary` field. */
  activitySummary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `activityDetail` field. */
  activityDetail?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `accommodationId` field. */
  accommodationId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `propertyId` field. */
  propertyId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `QuoteDay` values. */
export type QuoteDaysConnection = {
  __typename?: 'QuoteDaysConnection';
  /** A list of `QuoteDay` objects. */
  nodes: Array<Maybe<QuoteDay>>;
  /** A list of edges which contains the `QuoteDay` and cursor to aid in pagination. */
  edges: Array<QuoteDaysEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteDay` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteDay = Node & {
  __typename?: 'QuoteDay';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  order: Scalars['Int'];
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
  /** Reads and enables pagination through a set of `QuoteDayDestination`. */
  quoteDayDestinationsByDayId: QuoteDayDestinationsConnection;
};


export type QuoteDayQuoteDayDestinationsByDayIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDayDestinationsOrderBy>>;
  condition?: Maybe<QuoteDayDestinationCondition>;
  filter?: Maybe<QuoteDayDestinationFilter>;
};

/** Methods to use when ordering `QuoteDayDestination`. */
export enum QuoteDayDestinationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DestinationIdAsc = 'DESTINATION_ID_ASC',
  DestinationIdDesc = 'DESTINATION_ID_DESC',
  DayIdAsc = 'DAY_ID_ASC',
  DayIdDesc = 'DAY_ID_DESC',
  OrderAsc = 'ORDER_ASC',
  OrderDesc = 'ORDER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  DestinationByDestinationIdIdAsc = 'DESTINATION_BY_DESTINATION_ID__ID_ASC',
  DestinationByDestinationIdIdDesc = 'DESTINATION_BY_DESTINATION_ID__ID_DESC',
  DestinationByDestinationIdCreatedAsc = 'DESTINATION_BY_DESTINATION_ID__CREATED_ASC',
  DestinationByDestinationIdCreatedDesc = 'DESTINATION_BY_DESTINATION_ID__CREATED_DESC',
  DestinationByDestinationIdModifiedAsc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_ASC',
  DestinationByDestinationIdModifiedDesc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_DESC',
  DestinationByDestinationIdNameAsc = 'DESTINATION_BY_DESTINATION_ID__NAME_ASC',
  DestinationByDestinationIdNameDesc = 'DESTINATION_BY_DESTINATION_ID__NAME_DESC',
  DestinationByDestinationIdBodyAsc = 'DESTINATION_BY_DESTINATION_ID__BODY_ASC',
  DestinationByDestinationIdBodyDesc = 'DESTINATION_BY_DESTINATION_ID__BODY_DESC',
  DestinationByDestinationIdGalleryIdAsc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_ASC',
  DestinationByDestinationIdGalleryIdDesc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_DESC',
  DestinationByDestinationIdParentIdAsc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_ASC',
  DestinationByDestinationIdParentIdDesc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_DESC',
  DestinationByDestinationIdCountryIdAsc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_ASC',
  DestinationByDestinationIdCountryIdDesc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_DESC',
  DestinationByDestinationIdLatitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_ASC',
  DestinationByDestinationIdLatitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_DESC',
  DestinationByDestinationIdLongitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_ASC',
  DestinationByDestinationIdLongitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_DESC',
  DestinationByDestinationIdHeroMediaIdAsc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_ASC',
  DestinationByDestinationIdHeroMediaIdDesc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_DESC',
  QuoteDayByDayIdIdAsc = 'QUOTE_DAY_BY_DAY_ID__ID_ASC',
  QuoteDayByDayIdIdDesc = 'QUOTE_DAY_BY_DAY_ID__ID_DESC',
  QuoteDayByDayIdOrderAsc = 'QUOTE_DAY_BY_DAY_ID__ORDER_ASC',
  QuoteDayByDayIdOrderDesc = 'QUOTE_DAY_BY_DAY_ID__ORDER_DESC',
  QuoteDayByDayIdDateAsc = 'QUOTE_DAY_BY_DAY_ID__DATE_ASC',
  QuoteDayByDayIdDateDesc = 'QUOTE_DAY_BY_DAY_ID__DATE_DESC',
  QuoteDayByDayIdActivitySummaryAsc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_SUMMARY_ASC',
  QuoteDayByDayIdActivitySummaryDesc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_SUMMARY_DESC',
  QuoteDayByDayIdActivityDetailAsc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_DETAIL_ASC',
  QuoteDayByDayIdActivityDetailDesc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_DETAIL_DESC',
  QuoteDayByDayIdAccommodationIdAsc = 'QUOTE_DAY_BY_DAY_ID__ACCOMMODATION_ID_ASC',
  QuoteDayByDayIdAccommodationIdDesc = 'QUOTE_DAY_BY_DAY_ID__ACCOMMODATION_ID_DESC',
  QuoteDayByDayIdQuoteIdAsc = 'QUOTE_DAY_BY_DAY_ID__QUOTE_ID_ASC',
  QuoteDayByDayIdQuoteIdDesc = 'QUOTE_DAY_BY_DAY_ID__QUOTE_ID_DESC',
  QuoteDayByDayIdPropertyIdAsc = 'QUOTE_DAY_BY_DAY_ID__PROPERTY_ID_ASC',
  QuoteDayByDayIdPropertyIdDesc = 'QUOTE_DAY_BY_DAY_ID__PROPERTY_ID_DESC'
}

/** A condition to be used against `QuoteDayDestination` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteDayDestinationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `destinationId` field. */
  destinationId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `dayId` field. */
  dayId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `order` field. */
  order?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `QuoteDayDestination` values. */
export type QuoteDayDestinationsConnection = {
  __typename?: 'QuoteDayDestinationsConnection';
  /** A list of `QuoteDayDestination` objects. */
  nodes: Array<Maybe<QuoteDayDestination>>;
  /** A list of edges which contains the `QuoteDayDestination` and cursor to aid in pagination. */
  edges: Array<QuoteDayDestinationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteDayDestination` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteDayDestination = Node & {
  __typename?: 'QuoteDayDestination';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  destinationId: Scalars['UUID'];
  dayId: Scalars['UUID'];
  order: Scalars['Int'];
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
};

/** A `QuoteDayDestination` edge in the connection. */
export type QuoteDayDestinationsEdge = {
  __typename?: 'QuoteDayDestinationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteDayDestination` at the end of the edge. */
  node?: Maybe<QuoteDayDestination>;
};

/** A `QuoteDay` edge in the connection. */
export type QuoteDaysEdge = {
  __typename?: 'QuoteDaysEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteDay` at the end of the edge. */
  node?: Maybe<QuoteDay>;
};

/** A `QuoteAccommodationDetail` edge in the connection. */
export type QuoteAccommodationDetailsEdge = {
  __typename?: 'QuoteAccommodationDetailsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteAccommodationDetail` at the end of the edge. */
  node?: Maybe<QuoteAccommodationDetail>;
};

/** A `Property` edge in the connection. */
export type PropertiesEdge = {
  __typename?: 'PropertiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Property` at the end of the edge. */
  node?: Maybe<Property>;
};

/** Methods to use when ordering `QuoteHero`. */
export enum QuoteHeroesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  SubtitleAsc = 'SUBTITLE_ASC',
  SubtitleDesc = 'SUBTITLE_DESC',
  ImageIdAsc = 'IMAGE_ID_ASC',
  ImageIdDesc = 'IMAGE_ID_DESC',
  StyleAsc = 'STYLE_ASC',
  StyleDesc = 'STYLE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaItemByImageIdIdAsc = 'MEDIA_ITEM_BY_IMAGE_ID__ID_ASC',
  MediaItemByImageIdIdDesc = 'MEDIA_ITEM_BY_IMAGE_ID__ID_DESC',
  MediaItemByImageIdContentTypeAsc = 'MEDIA_ITEM_BY_IMAGE_ID__CONTENT_TYPE_ASC',
  MediaItemByImageIdContentTypeDesc = 'MEDIA_ITEM_BY_IMAGE_ID__CONTENT_TYPE_DESC',
  MediaItemByImageIdCreatedAsc = 'MEDIA_ITEM_BY_IMAGE_ID__CREATED_ASC',
  MediaItemByImageIdCreatedDesc = 'MEDIA_ITEM_BY_IMAGE_ID__CREATED_DESC',
  MediaItemByImageIdModifiedAsc = 'MEDIA_ITEM_BY_IMAGE_ID__MODIFIED_ASC',
  MediaItemByImageIdModifiedDesc = 'MEDIA_ITEM_BY_IMAGE_ID__MODIFIED_DESC',
  MediaItemByImageIdNameAsc = 'MEDIA_ITEM_BY_IMAGE_ID__NAME_ASC',
  MediaItemByImageIdNameDesc = 'MEDIA_ITEM_BY_IMAGE_ID__NAME_DESC',
  MediaItemByImageIdFileNameAsc = 'MEDIA_ITEM_BY_IMAGE_ID__FILE_NAME_ASC',
  MediaItemByImageIdFileNameDesc = 'MEDIA_ITEM_BY_IMAGE_ID__FILE_NAME_DESC',
  MediaItemByImageIdSummaryAsc = 'MEDIA_ITEM_BY_IMAGE_ID__SUMMARY_ASC',
  MediaItemByImageIdSummaryDesc = 'MEDIA_ITEM_BY_IMAGE_ID__SUMMARY_DESC',
  MediaItemByImageIdHashAsc = 'MEDIA_ITEM_BY_IMAGE_ID__HASH_ASC',
  MediaItemByImageIdHashDesc = 'MEDIA_ITEM_BY_IMAGE_ID__HASH_DESC',
  QuotesByHeroIdCountAsc = 'QUOTES_BY_HERO_ID__COUNT_ASC',
  QuotesByHeroIdCountDesc = 'QUOTES_BY_HERO_ID__COUNT_DESC',
  QuotePublicsByHeroIdCountAsc = 'QUOTE_PUBLICS_BY_HERO_ID__COUNT_ASC',
  QuotePublicsByHeroIdCountDesc = 'QUOTE_PUBLICS_BY_HERO_ID__COUNT_DESC'
}

/** A condition to be used against `QuoteHero` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteHeroCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `subtitle` field. */
  subtitle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imageId` field. */
  imageId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `style` field. */
  style?: Maybe<Scalars['String']>;
};

/** A connection to a list of `QuoteHero` values. */
export type QuoteHeroesConnection = {
  __typename?: 'QuoteHeroesConnection';
  /** A list of `QuoteHero` objects. */
  nodes: Array<Maybe<QuoteHero>>;
  /** A list of edges which contains the `QuoteHero` and cursor to aid in pagination. */
  edges: Array<QuoteHeroesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteHero` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `QuoteHero` edge in the connection. */
export type QuoteHeroesEdge = {
  __typename?: 'QuoteHeroesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteHero` at the end of the edge. */
  node?: Maybe<QuoteHero>;
};

/** A `MediaGalleryItem` edge in the connection. */
export type MediaGalleryItemsEdge = {
  __typename?: 'MediaGalleryItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `MediaGalleryItem` at the end of the edge. */
  node?: Maybe<MediaGalleryItem>;
};

/** Methods to use when ordering `Supplier`. */
export enum SuppliersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNumberAsc = 'CONTACT_NUMBER_ASC',
  ContactNumberDesc = 'CONTACT_NUMBER_DESC',
  RegionAsc = 'REGION_ASC',
  RegionDesc = 'REGION_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  BankDetailsAsc = 'BANK_DETAILS_ASC',
  BankDetailsDesc = 'BANK_DETAILS_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  ExpensesBySupplierIdCountAsc = 'EXPENSES_BY_SUPPLIER_ID__COUNT_ASC',
  ExpensesBySupplierIdCountDesc = 'EXPENSES_BY_SUPPLIER_ID__COUNT_DESC',
  SupplierInvoicesBySupplierIdCountAsc = 'SUPPLIER_INVOICES_BY_SUPPLIER_ID__COUNT_ASC',
  SupplierInvoicesBySupplierIdCountDesc = 'SUPPLIER_INVOICES_BY_SUPPLIER_ID__COUNT_DESC',
  QuoteFinanceLineItemsBySupplierIdCountAsc = 'QUOTE_FINANCE_LINE_ITEMS_BY_SUPPLIER_ID__COUNT_ASC',
  QuoteFinanceLineItemsBySupplierIdCountDesc = 'QUOTE_FINANCE_LINE_ITEMS_BY_SUPPLIER_ID__COUNT_DESC'
}

/** A condition to be used against `Supplier` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SupplierCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `contactNumber` field. */
  contactNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `region` field. */
  region?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `url` field. */
  url?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bankDetails` field. */
  bankDetails?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Supplier` values. */
export type SuppliersConnection = {
  __typename?: 'SuppliersConnection';
  /** A list of `Supplier` objects. */
  nodes: Array<Maybe<Supplier>>;
  /** A list of edges which contains the `Supplier` and cursor to aid in pagination. */
  edges: Array<SuppliersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Supplier` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Supplier` edge in the connection. */
export type SuppliersEdge = {
  __typename?: 'SuppliersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Supplier` at the end of the edge. */
  node?: Maybe<Supplier>;
};

/** Methods to use when ordering `DestinationGuide`. */
export enum DestinationGuidesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationIdAsc = 'DESTINATION_ID_ASC',
  DestinationIdDesc = 'DESTINATION_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  DestinationByDestinationIdIdAsc = 'DESTINATION_BY_DESTINATION_ID__ID_ASC',
  DestinationByDestinationIdIdDesc = 'DESTINATION_BY_DESTINATION_ID__ID_DESC',
  DestinationByDestinationIdCreatedAsc = 'DESTINATION_BY_DESTINATION_ID__CREATED_ASC',
  DestinationByDestinationIdCreatedDesc = 'DESTINATION_BY_DESTINATION_ID__CREATED_DESC',
  DestinationByDestinationIdModifiedAsc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_ASC',
  DestinationByDestinationIdModifiedDesc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_DESC',
  DestinationByDestinationIdNameAsc = 'DESTINATION_BY_DESTINATION_ID__NAME_ASC',
  DestinationByDestinationIdNameDesc = 'DESTINATION_BY_DESTINATION_ID__NAME_DESC',
  DestinationByDestinationIdBodyAsc = 'DESTINATION_BY_DESTINATION_ID__BODY_ASC',
  DestinationByDestinationIdBodyDesc = 'DESTINATION_BY_DESTINATION_ID__BODY_DESC',
  DestinationByDestinationIdGalleryIdAsc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_ASC',
  DestinationByDestinationIdGalleryIdDesc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_DESC',
  DestinationByDestinationIdParentIdAsc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_ASC',
  DestinationByDestinationIdParentIdDesc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_DESC',
  DestinationByDestinationIdCountryIdAsc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_ASC',
  DestinationByDestinationIdCountryIdDesc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_DESC',
  DestinationByDestinationIdLatitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_ASC',
  DestinationByDestinationIdLatitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_DESC',
  DestinationByDestinationIdLongitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_ASC',
  DestinationByDestinationIdLongitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_DESC',
  DestinationByDestinationIdHeroMediaIdAsc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_ASC',
  DestinationByDestinationIdHeroMediaIdDesc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_DESC'
}

/** A condition to be used against `DestinationGuide` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DestinationGuideCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `destinationId` field. */
  destinationId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
};

/** A connection to a list of `DestinationGuide` values. */
export type DestinationGuidesConnection = {
  __typename?: 'DestinationGuidesConnection';
  /** A list of `DestinationGuide` objects. */
  nodes: Array<Maybe<DestinationGuide>>;
  /** A list of edges which contains the `DestinationGuide` and cursor to aid in pagination. */
  edges: Array<DestinationGuidesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DestinationGuide` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type DestinationGuide = Node & {
  __typename?: 'DestinationGuide';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  body?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  destinationId: Scalars['UUID'];
  modified: Scalars['Datetime'];
  title?: Maybe<Scalars['String']>;
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
};

/** A `DestinationGuide` edge in the connection. */
export type DestinationGuidesEdge = {
  __typename?: 'DestinationGuidesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `DestinationGuide` at the end of the edge. */
  node?: Maybe<DestinationGuide>;
};

/** A `Destination` edge in the connection. */
export type DestinationsEdge = {
  __typename?: 'DestinationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Destination` at the end of the edge. */
  node?: Maybe<Destination>;
};

/** A `Passport` edge in the connection. */
export type PassportsEdge = {
  __typename?: 'PassportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Passport` at the end of the edge. */
  node?: Maybe<Passport>;
};

/** Methods to use when ordering `TripTraveller`. */
export enum TripTravellersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  TravellerIdAsc = 'TRAVELLER_ID_ASC',
  TravellerIdDesc = 'TRAVELLER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TravellerByTravellerIdIdAsc = 'TRAVELLER_BY_TRAVELLER_ID__ID_ASC',
  TravellerByTravellerIdIdDesc = 'TRAVELLER_BY_TRAVELLER_ID__ID_DESC',
  TravellerByTravellerIdCreatedAsc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_ASC',
  TravellerByTravellerIdCreatedDesc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_DESC',
  TravellerByTravellerIdDateOfBirthAsc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_ASC',
  TravellerByTravellerIdDateOfBirthDesc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_DESC',
  TravellerByTravellerIdDietaryRequirementsAsc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_ASC',
  TravellerByTravellerIdDietaryRequirementsDesc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_DESC',
  TravellerByTravellerIdEmailAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_ASC',
  TravellerByTravellerIdEmailDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_DESC',
  TravellerByTravellerIdFirstNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_ASC',
  TravellerByTravellerIdFirstNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_DESC',
  TravellerByTravellerIdHeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_ASC',
  TravellerByTravellerIdHeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_DESC',
  TravellerByTravellerIdLastNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_ASC',
  TravellerByTravellerIdLastNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_DESC',
  TravellerByTravellerIdMedicalConditionsAsc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_ASC',
  TravellerByTravellerIdMedicalConditionsDesc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_DESC',
  TravellerByTravellerIdMiddleNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_ASC',
  TravellerByTravellerIdMiddleNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_DESC',
  TravellerByTravellerIdModifiedAsc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_ASC',
  TravellerByTravellerIdModifiedDesc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_DESC',
  TravellerByTravellerIdNationalityAsc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_ASC',
  TravellerByTravellerIdNationalityDesc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_DESC',
  TravellerByTravellerIdNotesAsc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_ASC',
  TravellerByTravellerIdNotesDesc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_DESC',
  TravellerByTravellerIdPhoneAsc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_ASC',
  TravellerByTravellerIdPhoneDesc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_DESC',
  TravellerByTravellerIdWeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_ASC',
  TravellerByTravellerIdWeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_DESC',
  TravellerByTravellerIdEmergencyContactAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_ASC',
  TravellerByTravellerIdEmergencyContactDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_DESC',
  TravellerByTravellerIdInsuranceDetailsAsc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_ASC',
  TravellerByTravellerIdInsuranceDetailsDesc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC'
}

/** A condition to be used against `TripTraveller` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TripTravellerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `travellerId` field. */
  travellerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `TripTraveller` values. */
export type TripTravellersConnection = {
  __typename?: 'TripTravellersConnection';
  /** A list of `TripTraveller` objects. */
  nodes: Array<Maybe<TripTraveller>>;
  /** A list of edges which contains the `TripTraveller` and cursor to aid in pagination. */
  edges: Array<TripTravellersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TripTraveller` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TripTraveller = Node & {
  __typename?: 'TripTraveller';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  travellerId: Scalars['UUID'];
  tripId: Scalars['UUID'];
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
};

/** A `TripTraveller` edge in the connection. */
export type TripTravellersEdge = {
  __typename?: 'TripTravellersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TripTraveller` at the end of the edge. */
  node?: Maybe<TripTraveller>;
};

/** A `CustomerTraveller` edge in the connection. */
export type CustomerTravellersEdge = {
  __typename?: 'CustomerTravellersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerTraveller` at the end of the edge. */
  node?: Maybe<CustomerTraveller>;
};

/** Methods to use when ordering `Enquiry`. */
export enum EnquiriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommentsAsc = 'COMMENTS_ASC',
  CommentsDesc = 'COMMENTS_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  DatesAsc = 'DATES_ASC',
  DatesDesc = 'DATES_DESC',
  DestinationAsc = 'DESTINATION_ASC',
  DestinationDesc = 'DESTINATION_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TravellersAsc = 'TRAVELLERS_ASC',
  TravellersDesc = 'TRAVELLERS_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC'
}

/** A condition to be used against `Enquiry` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EnquiryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `comments` field. */
  comments?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `dates` field. */
  dates?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `destination` field. */
  destination?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `travellers` field. */
  travellers?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `archived` field. */
  archived?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `Enquiry` values. */
export type EnquiriesConnection = {
  __typename?: 'EnquiriesConnection';
  /** A list of `Enquiry` objects. */
  nodes: Array<Maybe<Enquiry>>;
  /** A list of edges which contains the `Enquiry` and cursor to aid in pagination. */
  edges: Array<EnquiriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Enquiry` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Enquiry = Node & {
  __typename?: 'Enquiry';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  comments?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  customerId: Scalars['UUID'];
  dates?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  travellers?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  archived?: Maybe<Scalars['Datetime']>;
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
};

/** A `Enquiry` edge in the connection. */
export type EnquiriesEdge = {
  __typename?: 'EnquiriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Enquiry` at the end of the edge. */
  node?: Maybe<Enquiry>;
};

/** Methods to use when ordering `Invoice`. */
export enum InvoicesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DueAsc = 'DUE_ASC',
  DueDesc = 'DUE_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  VoidedAsc = 'VOIDED_ASC',
  VoidedDesc = 'VOIDED_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  NoteAsc = 'NOTE_ASC',
  NoteDesc = 'NOTE_DESC',
  InvoicedAsc = 'INVOICED_ASC',
  InvoicedDesc = 'INVOICED_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdTotalAsc = 'QUOTE_BY_QUOTE_ID__TOTAL_ASC',
  QuoteByQuoteIdTotalDesc = 'QUOTE_BY_QUOTE_ID__TOTAL_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdLastViewedAsc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByQuoteIdLastViewedDesc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  ExpensesByInvoiceIdCountAsc = 'EXPENSES_BY_INVOICE_ID__COUNT_ASC',
  ExpensesByInvoiceIdCountDesc = 'EXPENSES_BY_INVOICE_ID__COUNT_DESC',
  PaymentsByInvoiceIdCountAsc = 'PAYMENTS_BY_INVOICE_ID__COUNT_ASC',
  PaymentsByInvoiceIdCountDesc = 'PAYMENTS_BY_INVOICE_ID__COUNT_DESC',
  TransactionLinksByInvoiceIdCountAsc = 'TRANSACTION_LINKS_BY_INVOICE_ID__COUNT_ASC',
  TransactionLinksByInvoiceIdCountDesc = 'TRANSACTION_LINKS_BY_INVOICE_ID__COUNT_DESC'
}

/** A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type InvoiceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `due` field. */
  due?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `key` field. */
  key?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `number` field. */
  number?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `voided` field. */
  voided?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `note` field. */
  note?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiced` field. */
  invoiced?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: Maybe<Scalars['Datetime']>;
};

/** A connection to a list of `Invoice` values. */
export type InvoicesConnection = {
  __typename?: 'InvoicesConnection';
  /** A list of `Invoice` objects. */
  nodes: Array<Maybe<Invoice>>;
  /** A list of edges which contains the `Invoice` and cursor to aid in pagination. */
  edges: Array<InvoicesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Invoice` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Invoice` edge in the connection. */
export type InvoicesEdge = {
  __typename?: 'InvoicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Invoice` at the end of the edge. */
  node?: Maybe<Invoice>;
};

/** Methods to use when ordering `Payment`. */
export enum PaymentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AmountActualAsc = 'AMOUNT_ACTUAL_ASC',
  AmountActualDesc = 'AMOUNT_ACTUAL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  ReferenceAsc = 'REFERENCE_ASC',
  ReferenceDesc = 'REFERENCE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  InvoiceByInvoiceIdIdAsc = 'INVOICE_BY_INVOICE_ID__ID_ASC',
  InvoiceByInvoiceIdIdDesc = 'INVOICE_BY_INVOICE_ID__ID_DESC',
  InvoiceByInvoiceIdAmountAsc = 'INVOICE_BY_INVOICE_ID__AMOUNT_ASC',
  InvoiceByInvoiceIdAmountDesc = 'INVOICE_BY_INVOICE_ID__AMOUNT_DESC',
  InvoiceByInvoiceIdCreatedAsc = 'INVOICE_BY_INVOICE_ID__CREATED_ASC',
  InvoiceByInvoiceIdCreatedDesc = 'INVOICE_BY_INVOICE_ID__CREATED_DESC',
  InvoiceByInvoiceIdCurrencyAsc = 'INVOICE_BY_INVOICE_ID__CURRENCY_ASC',
  InvoiceByInvoiceIdCurrencyDesc = 'INVOICE_BY_INVOICE_ID__CURRENCY_DESC',
  InvoiceByInvoiceIdDueAsc = 'INVOICE_BY_INVOICE_ID__DUE_ASC',
  InvoiceByInvoiceIdDueDesc = 'INVOICE_BY_INVOICE_ID__DUE_DESC',
  InvoiceByInvoiceIdKeyAsc = 'INVOICE_BY_INVOICE_ID__KEY_ASC',
  InvoiceByInvoiceIdKeyDesc = 'INVOICE_BY_INVOICE_ID__KEY_DESC',
  InvoiceByInvoiceIdModifiedAsc = 'INVOICE_BY_INVOICE_ID__MODIFIED_ASC',
  InvoiceByInvoiceIdModifiedDesc = 'INVOICE_BY_INVOICE_ID__MODIFIED_DESC',
  InvoiceByInvoiceIdSummaryAsc = 'INVOICE_BY_INVOICE_ID__SUMMARY_ASC',
  InvoiceByInvoiceIdSummaryDesc = 'INVOICE_BY_INVOICE_ID__SUMMARY_DESC',
  InvoiceByInvoiceIdTypeAsc = 'INVOICE_BY_INVOICE_ID__TYPE_ASC',
  InvoiceByInvoiceIdTypeDesc = 'INVOICE_BY_INVOICE_ID__TYPE_DESC',
  InvoiceByInvoiceIdNumberAsc = 'INVOICE_BY_INVOICE_ID__NUMBER_ASC',
  InvoiceByInvoiceIdNumberDesc = 'INVOICE_BY_INVOICE_ID__NUMBER_DESC',
  InvoiceByInvoiceIdQuoteIdAsc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_ASC',
  InvoiceByInvoiceIdQuoteIdDesc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_DESC',
  InvoiceByInvoiceIdVoidedAsc = 'INVOICE_BY_INVOICE_ID__VOIDED_ASC',
  InvoiceByInvoiceIdVoidedDesc = 'INVOICE_BY_INVOICE_ID__VOIDED_DESC',
  InvoiceByInvoiceIdCategoryIdAsc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_ASC',
  InvoiceByInvoiceIdCategoryIdDesc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_DESC',
  InvoiceByInvoiceIdTripIdAsc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_ASC',
  InvoiceByInvoiceIdTripIdDesc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_DESC',
  InvoiceByInvoiceIdPaidAsc = 'INVOICE_BY_INVOICE_ID__PAID_ASC',
  InvoiceByInvoiceIdPaidDesc = 'INVOICE_BY_INVOICE_ID__PAID_DESC',
  InvoiceByInvoiceIdNoteAsc = 'INVOICE_BY_INVOICE_ID__NOTE_ASC',
  InvoiceByInvoiceIdNoteDesc = 'INVOICE_BY_INVOICE_ID__NOTE_DESC',
  InvoiceByInvoiceIdInvoicedAsc = 'INVOICE_BY_INVOICE_ID__INVOICED_ASC',
  InvoiceByInvoiceIdInvoicedDesc = 'INVOICE_BY_INVOICE_ID__INVOICED_DESC',
  InvoiceByInvoiceIdLockedAsc = 'INVOICE_BY_INVOICE_ID__LOCKED_ASC',
  InvoiceByInvoiceIdLockedDesc = 'INVOICE_BY_INVOICE_ID__LOCKED_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TransactionLinksByPaymentIdCountAsc = 'TRANSACTION_LINKS_BY_PAYMENT_ID__COUNT_ASC',
  TransactionLinksByPaymentIdCountDesc = 'TRANSACTION_LINKS_BY_PAYMENT_ID__COUNT_DESC'
}

/** A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PaymentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `amountActual` field. */
  amountActual?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `reference` field. */
  reference?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['Int']>;
};

/** A connection to a list of `Payment` values. */
export type PaymentsConnection = {
  __typename?: 'PaymentsConnection';
  /** A list of `Payment` objects. */
  nodes: Array<Maybe<Payment>>;
  /** A list of edges which contains the `Payment` and cursor to aid in pagination. */
  edges: Array<PaymentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Payment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Payment` edge in the connection. */
export type PaymentsEdge = {
  __typename?: 'PaymentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Payment` at the end of the edge. */
  node?: Maybe<Payment>;
};

/** Methods to use when ordering `Testimonial`. */
export enum TestimonialsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GuestNameAsc = 'GUEST_NAME_ASC',
  GuestNameDesc = 'GUEST_NAME_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC'
}

/** A condition to be used against `Testimonial` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TestimonialCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `body` field. */
  body?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `guestName` field. */
  guestName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: Maybe<Scalars['UUID']>;
};

/** A connection to a list of `Testimonial` values. */
export type TestimonialsConnection = {
  __typename?: 'TestimonialsConnection';
  /** A list of `Testimonial` objects. */
  nodes: Array<Maybe<Testimonial>>;
  /** A list of edges which contains the `Testimonial` and cursor to aid in pagination. */
  edges: Array<TestimonialsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Testimonial` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Testimonial = Node & {
  __typename?: 'Testimonial';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  body?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  guestName?: Maybe<Scalars['String']>;
  modified: Scalars['Datetime'];
  tripId?: Maybe<Scalars['UUID']>;
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
};

/** A `Testimonial` edge in the connection. */
export type TestimonialsEdge = {
  __typename?: 'TestimonialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Testimonial` at the end of the edge. */
  node?: Maybe<Testimonial>;
};

/** Methods to use when ordering `QuoteView`. */
export enum QuoteViewsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  TimezoneAsc = 'TIMEZONE_ASC',
  TimezoneDesc = 'TIMEZONE_DESC',
  UserIpAsc = 'USER_IP_ASC',
  UserIpDesc = 'USER_IP_DESC',
  ViewTypeAsc = 'VIEW_TYPE_ASC',
  ViewTypeDesc = 'VIEW_TYPE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdTotalAsc = 'QUOTE_BY_QUOTE_ID__TOTAL_ASC',
  QuoteByQuoteIdTotalDesc = 'QUOTE_BY_QUOTE_ID__TOTAL_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdLastViewedAsc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByQuoteIdLastViewedDesc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC'
}

/** A condition to be used against `QuoteView` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteViewCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `city` field. */
  city?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `country` field. */
  country?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `timezone` field. */
  timezone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userIp` field. */
  userIp?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `viewType` field. */
  viewType?: Maybe<Scalars['String']>;
};

/** A connection to a list of `QuoteView` values. */
export type QuoteViewsConnection = {
  __typename?: 'QuoteViewsConnection';
  /** A list of `QuoteView` objects. */
  nodes: Array<Maybe<QuoteView>>;
  /** A list of edges which contains the `QuoteView` and cursor to aid in pagination. */
  edges: Array<QuoteViewsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteView` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteView = Node & {
  __typename?: 'QuoteView';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  quoteId: Scalars['UUID'];
  timezone?: Maybe<Scalars['String']>;
  userIp?: Maybe<Scalars['String']>;
  viewType?: Maybe<Scalars['String']>;
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
};

/** A `QuoteView` edge in the connection. */
export type QuoteViewsEdge = {
  __typename?: 'QuoteViewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteView` at the end of the edge. */
  node?: Maybe<QuoteView>;
};

/** Methods to use when ordering `QuoteCurrency`. */
export enum QuoteCurrenciesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  RateAsc = 'RATE_ASC',
  RateDesc = 'RATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdTotalAsc = 'QUOTE_BY_QUOTE_ID__TOTAL_ASC',
  QuoteByQuoteIdTotalDesc = 'QUOTE_BY_QUOTE_ID__TOTAL_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdLastViewedAsc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_ASC',
  QuoteByQuoteIdLastViewedDesc = 'QUOTE_BY_QUOTE_ID__LAST_VIEWED_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC'
}

/** A condition to be used against `QuoteCurrency` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteCurrencyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `rate` field. */
  rate?: Maybe<Scalars['BigFloat']>;
};

/** A connection to a list of `QuoteCurrency` values. */
export type QuoteCurrenciesConnection = {
  __typename?: 'QuoteCurrenciesConnection';
  /** A list of `QuoteCurrency` objects. */
  nodes: Array<Maybe<QuoteCurrency>>;
  /** A list of edges which contains the `QuoteCurrency` and cursor to aid in pagination. */
  edges: Array<QuoteCurrenciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteCurrency` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteCurrency = Node & {
  __typename?: 'QuoteCurrency';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  code?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  rate: Scalars['BigFloat'];
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
};

/** A `QuoteCurrency` edge in the connection. */
export type QuoteCurrenciesEdge = {
  __typename?: 'QuoteCurrenciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteCurrency` at the end of the edge. */
  node?: Maybe<QuoteCurrency>;
};

/** A `Expense` edge in the connection. */
export type ExpensesEdge = {
  __typename?: 'ExpensesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Expense` at the end of the edge. */
  node?: Maybe<Expense>;
};

/** A `Transaction` edge in the connection. */
export type TransactionsEdge = {
  __typename?: 'TransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Transaction` at the end of the edge. */
  node?: Maybe<Transaction>;
};

/** Methods to use when ordering `TransactionImportBatch`. */
export enum TransactionImportBatchesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  AccountIdAsc = 'ACCOUNT_ID_ASC',
  AccountIdDesc = 'ACCOUNT_ID_DESC',
  DateRangeMinAsc = 'DATE_RANGE_MIN_ASC',
  DateRangeMinDesc = 'DATE_RANGE_MIN_DESC',
  DateRangeMaxAsc = 'DATE_RANGE_MAX_ASC',
  DateRangeMaxDesc = 'DATE_RANGE_MAX_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  AccountByAccountIdIdAsc = 'ACCOUNT_BY_ACCOUNT_ID__ID_ASC',
  AccountByAccountIdIdDesc = 'ACCOUNT_BY_ACCOUNT_ID__ID_DESC',
  AccountByAccountIdCreatedAsc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_ASC',
  AccountByAccountIdCreatedDesc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_DESC',
  AccountByAccountIdModifiedAsc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_ASC',
  AccountByAccountIdModifiedDesc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_DESC',
  AccountByAccountIdNameAsc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_ASC',
  AccountByAccountIdNameDesc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_DESC',
  AccountByAccountIdInstitutionAsc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_ASC',
  AccountByAccountIdInstitutionDesc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_DESC',
  AccountByAccountIdDetailsAsc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_ASC',
  AccountByAccountIdDetailsDesc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_DESC',
  TransactionsByTransactionImportBatchIdCountAsc = 'TRANSACTIONS_BY_TRANSACTION_IMPORT_BATCH_ID__COUNT_ASC',
  TransactionsByTransactionImportBatchIdCountDesc = 'TRANSACTIONS_BY_TRANSACTION_IMPORT_BATCH_ID__COUNT_DESC'
}

/** A condition to be used against `TransactionImportBatch` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TransactionImportBatchCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `accountId` field. */
  accountId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `dateRangeMin` field. */
  dateRangeMin?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `dateRangeMax` field. */
  dateRangeMax?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `key` field. */
  key?: Maybe<Scalars['String']>;
};

/** A connection to a list of `TransactionImportBatch` values. */
export type TransactionImportBatchesConnection = {
  __typename?: 'TransactionImportBatchesConnection';
  /** A list of `TransactionImportBatch` objects. */
  nodes: Array<Maybe<TransactionImportBatch>>;
  /** A list of edges which contains the `TransactionImportBatch` and cursor to aid in pagination. */
  edges: Array<TransactionImportBatchesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransactionImportBatch` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TransactionImportBatch` edge in the connection. */
export type TransactionImportBatchesEdge = {
  __typename?: 'TransactionImportBatchesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TransactionImportBatch` at the end of the edge. */
  node?: Maybe<TransactionImportBatch>;
};

/** A `Account` edge in the connection. */
export type AccountsEdge = {
  __typename?: 'AccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Account` at the end of the edge. */
  node?: Maybe<Account>;
};

/** Methods to use when ordering `CombinedTransaction`. */
export enum CombinedTransactionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  AccountIdAsc = 'ACCOUNT_ID_ASC',
  AccountIdDesc = 'ACCOUNT_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  ReverseTransactionIdAsc = 'REVERSE_TRANSACTION_ID_ASC',
  ReverseTransactionIdDesc = 'REVERSE_TRANSACTION_ID_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC',
  TransactionImportBatchIdAsc = 'TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionImportBatchIdDesc = 'TRANSACTION_IMPORT_BATCH_ID_DESC',
  BalanceAsc = 'BALANCE_ASC',
  BalanceDesc = 'BALANCE_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC'
}

/** A condition to be used against `CombinedTransaction` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CombinedTransactionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `accountId` field. */
  accountId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reverseTransactionId` field. */
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `balance` field. */
  balance?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `CombinedTransaction` object types. All fields are combined with a logical ‘and.’ */
export type CombinedTransactionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `accountId` field. */
  accountId?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `externalId` field. */
  externalId?: Maybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `reverseTransactionId` field. */
  reverseTransactionId?: Maybe<UuidFilter>;
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>;
  /** Filter by the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: Maybe<UuidFilter>;
  /** Filter by the object’s `balance` field. */
  balance?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CombinedTransactionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CombinedTransactionFilter>>;
  /** Negates the expression. */
  not?: Maybe<CombinedTransactionFilter>;
};

/** A connection to a list of `CombinedTransaction` values. */
export type CombinedTransactionsConnection = {
  __typename?: 'CombinedTransactionsConnection';
  /** A list of `CombinedTransaction` objects. */
  nodes: Array<Maybe<CombinedTransaction>>;
  /** A list of edges which contains the `CombinedTransaction` and cursor to aid in pagination. */
  edges: Array<CombinedTransactionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CombinedTransaction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CombinedTransaction = {
  __typename?: 'CombinedTransaction';
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
};

/** A `CombinedTransaction` edge in the connection. */
export type CombinedTransactionsEdge = {
  __typename?: 'CombinedTransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CombinedTransaction` at the end of the edge. */
  node?: Maybe<CombinedTransaction>;
};

/** Methods to use when ordering `Country`. */
export enum CountriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Iso2Asc = 'ISO2_ASC',
  Iso2Desc = 'ISO2_DESC',
  Iso3Asc = 'ISO3_ASC',
  Iso3Desc = 'ISO3_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  AirportsByCountryIdCountAsc = 'AIRPORTS_BY_COUNTRY_ID__COUNT_ASC',
  AirportsByCountryIdCountDesc = 'AIRPORTS_BY_COUNTRY_ID__COUNT_DESC',
  DestinationsByCountryIdCountAsc = 'DESTINATIONS_BY_COUNTRY_ID__COUNT_ASC',
  DestinationsByCountryIdCountDesc = 'DESTINATIONS_BY_COUNTRY_ID__COUNT_DESC',
  PassportsByCountryIdCountAsc = 'PASSPORTS_BY_COUNTRY_ID__COUNT_ASC',
  PassportsByCountryIdCountDesc = 'PASSPORTS_BY_COUNTRY_ID__COUNT_DESC',
  PropertiesByCountryIdCountAsc = 'PROPERTIES_BY_COUNTRY_ID__COUNT_ASC',
  PropertiesByCountryIdCountDesc = 'PROPERTIES_BY_COUNTRY_ID__COUNT_DESC'
}

/** A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CountryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `iso2` field. */
  iso2?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `iso3` field. */
  iso3?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Country` values. */
export type CountriesConnection = {
  __typename?: 'CountriesConnection';
  /** A list of `Country` objects. */
  nodes: Array<Maybe<Country>>;
  /** A list of edges which contains the `Country` and cursor to aid in pagination. */
  edges: Array<CountriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Country` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Country` edge in the connection. */
export type CountriesEdge = {
  __typename?: 'CountriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Country` at the end of the edge. */
  node?: Maybe<Country>;
};

/** Methods to use when ordering `Customer`. */
export enum CustomersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerTravellersByCustomerIdCountAsc = 'CUSTOMER_TRAVELLERS_BY_CUSTOMER_ID__COUNT_ASC',
  CustomerTravellersByCustomerIdCountDesc = 'CUSTOMER_TRAVELLERS_BY_CUSTOMER_ID__COUNT_DESC',
  TripsByCustomerIdCountAsc = 'TRIPS_BY_CUSTOMER_ID__COUNT_ASC',
  TripsByCustomerIdCountDesc = 'TRIPS_BY_CUSTOMER_ID__COUNT_DESC',
  EmailsByCustomerIdCountAsc = 'EMAILS_BY_CUSTOMER_ID__COUNT_ASC',
  EmailsByCustomerIdCountDesc = 'EMAILS_BY_CUSTOMER_ID__COUNT_DESC',
  EnquiriesByCustomerIdCountAsc = 'ENQUIRIES_BY_CUSTOMER_ID__COUNT_ASC',
  EnquiriesByCustomerIdCountDesc = 'ENQUIRIES_BY_CUSTOMER_ID__COUNT_DESC'
}

/** A condition to be used against `Customer` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CustomerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Customer` values. */
export type CustomersConnection = {
  __typename?: 'CustomersConnection';
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer` and cursor to aid in pagination. */
  edges: Array<CustomersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Customer` edge in the connection. */
export type CustomersEdge = {
  __typename?: 'CustomersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** Methods to use when ordering `DashboardSummary`. */
export enum DashboardSummariesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
  ActionedAsc = 'ACTIONED_ASC',
  ActionedDesc = 'ACTIONED_DESC'
}

/** A condition to be used against `DashboardSummary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DashboardSummaryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `actioned` field. */
  actioned?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `DashboardSummary` object types. All fields are combined with a logical ‘and.’ */
export type DashboardSummaryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `date` field. */
  date?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `value` field. */
  value?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `actioned` field. */
  actioned?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<DashboardSummaryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<DashboardSummaryFilter>>;
  /** Negates the expression. */
  not?: Maybe<DashboardSummaryFilter>;
};

/** A connection to a list of `DashboardSummary` values. */
export type DashboardSummariesConnection = {
  __typename?: 'DashboardSummariesConnection';
  /** A list of `DashboardSummary` objects. */
  nodes: Array<Maybe<DashboardSummary>>;
  /** A list of edges which contains the `DashboardSummary` and cursor to aid in pagination. */
  edges: Array<DashboardSummariesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DashboardSummary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type DashboardSummary = {
  __typename?: 'DashboardSummary';
  id?: Maybe<Scalars['UUID']>;
  date?: Maybe<Scalars['Datetime']>;
  type?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['BigFloat']>;
  actioned?: Maybe<Scalars['Boolean']>;
};

/** A `DashboardSummary` edge in the connection. */
export type DashboardSummariesEdge = {
  __typename?: 'DashboardSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `DashboardSummary` at the end of the edge. */
  node?: Maybe<DashboardSummary>;
};

/** Methods to use when ordering `FinanceCategory`. */
export enum FinanceCategoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ExpensesByCategoryIdCountAsc = 'EXPENSES_BY_CATEGORY_ID__COUNT_ASC',
  ExpensesByCategoryIdCountDesc = 'EXPENSES_BY_CATEGORY_ID__COUNT_DESC',
  InvoicesByCategoryIdCountAsc = 'INVOICES_BY_CATEGORY_ID__COUNT_ASC',
  InvoicesByCategoryIdCountDesc = 'INVOICES_BY_CATEGORY_ID__COUNT_DESC',
  PaymentsByCategoryIdCountAsc = 'PAYMENTS_BY_CATEGORY_ID__COUNT_ASC',
  PaymentsByCategoryIdCountDesc = 'PAYMENTS_BY_CATEGORY_ID__COUNT_DESC',
  SupplierInvoicesByCategoryIdCountAsc = 'SUPPLIER_INVOICES_BY_CATEGORY_ID__COUNT_ASC',
  SupplierInvoicesByCategoryIdCountDesc = 'SUPPLIER_INVOICES_BY_CATEGORY_ID__COUNT_DESC',
  TransactionsByCategoryIdCountAsc = 'TRANSACTIONS_BY_CATEGORY_ID__COUNT_ASC',
  TransactionsByCategoryIdCountDesc = 'TRANSACTIONS_BY_CATEGORY_ID__COUNT_DESC'
}

/** A condition to be used against `FinanceCategory` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FinanceCategoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>;
};

/** A connection to a list of `FinanceCategory` values. */
export type FinanceCategoriesConnection = {
  __typename?: 'FinanceCategoriesConnection';
  /** A list of `FinanceCategory` objects. */
  nodes: Array<Maybe<FinanceCategory>>;
  /** A list of edges which contains the `FinanceCategory` and cursor to aid in pagination. */
  edges: Array<FinanceCategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FinanceCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `FinanceCategory` edge in the connection. */
export type FinanceCategoriesEdge = {
  __typename?: 'FinanceCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `FinanceCategory` at the end of the edge. */
  node?: Maybe<FinanceCategory>;
};

/** Methods to use when ordering `InvoiceSummary`. */
export enum InvoiceSummariesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  PaidActualAsc = 'PAID_ACTUAL_ASC',
  PaidActualDesc = 'PAID_ACTUAL_DESC',
  OutstandingAsc = 'OUTSTANDING_ASC',
  OutstandingDesc = 'OUTSTANDING_DESC'
}

/** A condition to be used against `InvoiceSummary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type InvoiceSummaryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `paidActual` field. */
  paidActual?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `outstanding` field. */
  outstanding?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `InvoiceSummary` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceSummaryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `paid` field. */
  paid?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `paidActual` field. */
  paidActual?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `outstanding` field. */
  outstanding?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<InvoiceSummaryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<InvoiceSummaryFilter>>;
  /** Negates the expression. */
  not?: Maybe<InvoiceSummaryFilter>;
};

/** A connection to a list of `InvoiceSummary` values. */
export type InvoiceSummariesConnection = {
  __typename?: 'InvoiceSummariesConnection';
  /** A list of `InvoiceSummary` objects. */
  nodes: Array<Maybe<InvoiceSummary>>;
  /** A list of edges which contains the `InvoiceSummary` and cursor to aid in pagination. */
  edges: Array<InvoiceSummariesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InvoiceSummary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type InvoiceSummary = {
  __typename?: 'InvoiceSummary';
  id?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['BigFloat']>;
  paidActual?: Maybe<Scalars['BigFloat']>;
  outstanding?: Maybe<Scalars['BigFloat']>;
};

/** A `InvoiceSummary` edge in the connection. */
export type InvoiceSummariesEdge = {
  __typename?: 'InvoiceSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `InvoiceSummary` at the end of the edge. */
  node?: Maybe<InvoiceSummary>;
};

/** Methods to use when ordering `MapPoint`. */
export enum MapPointsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertiesByMapPointIdCountAsc = 'PROPERTIES_BY_MAP_POINT_ID__COUNT_ASC',
  PropertiesByMapPointIdCountDesc = 'PROPERTIES_BY_MAP_POINT_ID__COUNT_DESC'
}

/** A condition to be used against `MapPoint` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MapPointCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: Maybe<Scalars['Float']>;
};

/** A connection to a list of `MapPoint` values. */
export type MapPointsConnection = {
  __typename?: 'MapPointsConnection';
  /** A list of `MapPoint` objects. */
  nodes: Array<Maybe<MapPoint>>;
  /** A list of edges which contains the `MapPoint` and cursor to aid in pagination. */
  edges: Array<MapPointsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MapPoint` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `MapPoint` edge in the connection. */
export type MapPointsEdge = {
  __typename?: 'MapPointsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `MapPoint` at the end of the edge. */
  node?: Maybe<MapPoint>;
};

/** Methods to use when ordering `MediaItem`. */
export enum MediaItemsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ContentTypeAsc = 'CONTENT_TYPE_ASC',
  ContentTypeDesc = 'CONTENT_TYPE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  FileNameAsc = 'FILE_NAME_ASC',
  FileNameDesc = 'FILE_NAME_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  HashAsc = 'HASH_ASC',
  HashDesc = 'HASH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  AgenciesByLogoIdCountAsc = 'AGENCIES_BY_LOGO_ID__COUNT_ASC',
  AgenciesByLogoIdCountDesc = 'AGENCIES_BY_LOGO_ID__COUNT_DESC',
  SupplierInvoicesByMediaItemIdCountAsc = 'SUPPLIER_INVOICES_BY_MEDIA_ITEM_ID__COUNT_ASC',
  SupplierInvoicesByMediaItemIdCountDesc = 'SUPPLIER_INVOICES_BY_MEDIA_ITEM_ID__COUNT_DESC',
  DestinationsByHeroMediaIdCountAsc = 'DESTINATIONS_BY_HERO_MEDIA_ID__COUNT_ASC',
  DestinationsByHeroMediaIdCountDesc = 'DESTINATIONS_BY_HERO_MEDIA_ID__COUNT_DESC',
  MediaGalleryItemsByMediaItemIdCountAsc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_ITEM_ID__COUNT_ASC',
  MediaGalleryItemsByMediaItemIdCountDesc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_ITEM_ID__COUNT_DESC',
  PropertiesByHeroMediaIdCountAsc = 'PROPERTIES_BY_HERO_MEDIA_ID__COUNT_ASC',
  PropertiesByHeroMediaIdCountDesc = 'PROPERTIES_BY_HERO_MEDIA_ID__COUNT_DESC',
  QuotesByHeroImageIdCountAsc = 'QUOTES_BY_HERO_IMAGE_ID__COUNT_ASC',
  QuotesByHeroImageIdCountDesc = 'QUOTES_BY_HERO_IMAGE_ID__COUNT_DESC',
  QuoteHeroesByImageIdCountAsc = 'QUOTE_HEROES_BY_IMAGE_ID__COUNT_ASC',
  QuoteHeroesByImageIdCountDesc = 'QUOTE_HEROES_BY_IMAGE_ID__COUNT_DESC'
}

/** A condition to be used against `MediaItem` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MediaItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `contentType` field. */
  contentType?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fileName` field. */
  fileName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `hash` field. */
  hash?: Maybe<Scalars['String']>;
};

/** A connection to a list of `MediaItem` values. */
export type MediaItemsConnection = {
  __typename?: 'MediaItemsConnection';
  /** A list of `MediaItem` objects. */
  nodes: Array<Maybe<MediaItem>>;
  /** A list of edges which contains the `MediaItem` and cursor to aid in pagination. */
  edges: Array<MediaItemsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MediaItem` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `MediaItem` edge in the connection. */
export type MediaItemsEdge = {
  __typename?: 'MediaItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `MediaItem` at the end of the edge. */
  node?: Maybe<MediaItem>;
};

/** Methods to use when ordering `QuoteFinanceLineItemSummary`. */
export enum QuoteFinanceLineItemSummariesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  AmountActualAsc = 'AMOUNT_ACTUAL_ASC',
  AmountActualDesc = 'AMOUNT_ACTUAL_DESC',
  CurrencyActualAsc = 'CURRENCY_ACTUAL_ASC',
  CurrencyActualDesc = 'CURRENCY_ACTUAL_DESC',
  MarginActualAsc = 'MARGIN_ACTUAL_ASC',
  MarginActualDesc = 'MARGIN_ACTUAL_DESC'
}

/** A condition to be used against `QuoteFinanceLineItemSummary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteFinanceLineItemSummaryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `amountActual` field. */
  amountActual?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `currencyActual` field. */
  currencyActual?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `marginActual` field. */
  marginActual?: Maybe<Scalars['BigFloat']>;
};

/** A filter to be used against `QuoteFinanceLineItemSummary` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFinanceLineItemSummaryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `amountActual` field. */
  amountActual?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `currencyActual` field. */
  currencyActual?: Maybe<StringFilter>;
  /** Filter by the object’s `marginActual` field. */
  marginActual?: Maybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteFinanceLineItemSummaryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteFinanceLineItemSummaryFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteFinanceLineItemSummaryFilter>;
};

/** A connection to a list of `QuoteFinanceLineItemSummary` values. */
export type QuoteFinanceLineItemSummariesConnection = {
  __typename?: 'QuoteFinanceLineItemSummariesConnection';
  /** A list of `QuoteFinanceLineItemSummary` objects. */
  nodes: Array<Maybe<QuoteFinanceLineItemSummary>>;
  /** A list of edges which contains the `QuoteFinanceLineItemSummary` and cursor to aid in pagination. */
  edges: Array<QuoteFinanceLineItemSummariesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteFinanceLineItemSummary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteFinanceLineItemSummary = {
  __typename?: 'QuoteFinanceLineItemSummary';
  id?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  margin?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  currencyActual?: Maybe<Scalars['String']>;
  marginActual?: Maybe<Scalars['BigFloat']>;
};

/** A `QuoteFinanceLineItemSummary` edge in the connection. */
export type QuoteFinanceLineItemSummariesEdge = {
  __typename?: 'QuoteFinanceLineItemSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteFinanceLineItemSummary` at the end of the edge. */
  node?: Maybe<QuoteFinanceLineItemSummary>;
};

/** Methods to use when ordering `QuoteFinanceSummary`. */
export enum QuoteFinanceSummariesOrderBy {
  Natural = 'NATURAL',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC'
}

/** A condition to be used against `QuoteFinanceSummary` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteFinanceSummaryCondition = {
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `total` field. */
  total?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
};

/** A filter to be used against `QuoteFinanceSummary` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFinanceSummaryFilter = {
  /** Filter by the object’s `quoteId` field. */
  quoteId?: Maybe<UuidFilter>;
  /** Filter by the object’s `total` field. */
  total?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<QuoteFinanceSummaryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<QuoteFinanceSummaryFilter>>;
  /** Negates the expression. */
  not?: Maybe<QuoteFinanceSummaryFilter>;
};

/** A connection to a list of `QuoteFinanceSummary` values. */
export type QuoteFinanceSummariesConnection = {
  __typename?: 'QuoteFinanceSummariesConnection';
  /** A list of `QuoteFinanceSummary` objects. */
  nodes: Array<Maybe<QuoteFinanceSummary>>;
  /** A list of edges which contains the `QuoteFinanceSummary` and cursor to aid in pagination. */
  edges: Array<QuoteFinanceSummariesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteFinanceSummary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type QuoteFinanceSummary = {
  __typename?: 'QuoteFinanceSummary';
  quoteId?: Maybe<Scalars['UUID']>;
  total?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
};

/** A `QuoteFinanceSummary` edge in the connection. */
export type QuoteFinanceSummariesEdge = {
  __typename?: 'QuoteFinanceSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `QuoteFinanceSummary` at the end of the edge. */
  node?: Maybe<QuoteFinanceSummary>;
};

/** Methods to use when ordering `Timeline`. */
export enum TimelinesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  GroupAsc = 'GROUP_ASC',
  GroupDesc = 'GROUP_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  WeekAsc = 'WEEK_ASC',
  WeekDesc = 'WEEK_DESC',
  ActionedAsc = 'ACTIONED_ASC',
  ActionedDesc = 'ACTIONED_DESC'
}

/** A condition to be used against `Timeline` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TimelineCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `url` field. */
  url?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `group` field. */
  group?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `week` field. */
  week?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `actioned` field. */
  actioned?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `Timeline` object types. All fields are combined with a logical ‘and.’ */
export type TimelineFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `url` field. */
  url?: Maybe<StringFilter>;
  /** Filter by the object’s `group` field. */
  group?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `week` field. */
  week?: Maybe<StringFilter>;
  /** Filter by the object’s `actioned` field. */
  actioned?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TimelineFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TimelineFilter>>;
  /** Negates the expression. */
  not?: Maybe<TimelineFilter>;
};

/** A connection to a list of `Timeline` values. */
export type TimelinesConnection = {
  __typename?: 'TimelinesConnection';
  /** A list of `Timeline` objects. */
  nodes: Array<Maybe<Timeline>>;
  /** A list of edges which contains the `Timeline` and cursor to aid in pagination. */
  edges: Array<TimelinesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Timeline` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Timeline = {
  __typename?: 'Timeline';
  id?: Maybe<Scalars['UUID']>;
  url?: Maybe<Scalars['String']>;
  group?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  week?: Maybe<Scalars['String']>;
  actioned?: Maybe<Scalars['Datetime']>;
};

/** A `Timeline` edge in the connection. */
export type TimelinesEdge = {
  __typename?: 'TimelinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Timeline` at the end of the edge. */
  node?: Maybe<Timeline>;
};

/** Methods to use when ordering `Traveller`. */
export enum TravellersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  DietaryRequirementsAsc = 'DIETARY_REQUIREMENTS_ASC',
  DietaryRequirementsDesc = 'DIETARY_REQUIREMENTS_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  MedicalConditionsAsc = 'MEDICAL_CONDITIONS_ASC',
  MedicalConditionsDesc = 'MEDICAL_CONDITIONS_DESC',
  MiddleNameAsc = 'MIDDLE_NAME_ASC',
  MiddleNameDesc = 'MIDDLE_NAME_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NationalityAsc = 'NATIONALITY_ASC',
  NationalityDesc = 'NATIONALITY_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC',
  EmergencyContactAsc = 'EMERGENCY_CONTACT_ASC',
  EmergencyContactDesc = 'EMERGENCY_CONTACT_DESC',
  InsuranceDetailsAsc = 'INSURANCE_DETAILS_ASC',
  InsuranceDetailsDesc = 'INSURANCE_DETAILS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CustomerTravellersByTravellerIdCountAsc = 'CUSTOMER_TRAVELLERS_BY_TRAVELLER_ID__COUNT_ASC',
  CustomerTravellersByTravellerIdCountDesc = 'CUSTOMER_TRAVELLERS_BY_TRAVELLER_ID__COUNT_DESC',
  PassportsByTravellerIdCountAsc = 'PASSPORTS_BY_TRAVELLER_ID__COUNT_ASC',
  PassportsByTravellerIdCountDesc = 'PASSPORTS_BY_TRAVELLER_ID__COUNT_DESC',
  TripTravellersByTravellerIdCountAsc = 'TRIP_TRAVELLERS_BY_TRAVELLER_ID__COUNT_ASC',
  TripTravellersByTravellerIdCountDesc = 'TRIP_TRAVELLERS_BY_TRAVELLER_ID__COUNT_DESC'
}

/** A condition to be used against `Traveller` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TravellerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `dietaryRequirements` field. */
  dietaryRequirements?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `height` field. */
  height?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `medicalConditions` field. */
  medicalConditions?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `middleName` field. */
  middleName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `nationality` field. */
  nationality?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `emergencyContact` field. */
  emergencyContact?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `insuranceDetails` field. */
  insuranceDetails?: Maybe<Scalars['String']>;
};

/** A connection to a list of `Traveller` values. */
export type TravellersConnection = {
  __typename?: 'TravellersConnection';
  /** A list of `Traveller` objects. */
  nodes: Array<Maybe<Traveller>>;
  /** A list of edges which contains the `Traveller` and cursor to aid in pagination. */
  edges: Array<TravellersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Traveller` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Traveller` edge in the connection. */
export type TravellersEdge = {
  __typename?: 'TravellersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Traveller` at the end of the edge. */
  node?: Maybe<Traveller>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  PasswordAsc = 'PASSWORD_ASC',
  PasswordDesc = 'PASSWORD_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  SkypeAsc = 'SKYPE_ASC',
  SkypeDesc = 'SKYPE_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  GenderPrepositionAsc = 'GENDER_PREPOSITION_ASC',
  GenderPrepositionDesc = 'GENDER_PREPOSITION_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripsByUserIdCountAsc = 'TRIPS_BY_USER_ID__COUNT_ASC',
  TripsByUserIdCountDesc = 'TRIPS_BY_USER_ID__COUNT_DESC',
  EmailsByUserIdCountAsc = 'EMAILS_BY_USER_ID__COUNT_ASC',
  EmailsByUserIdCountDesc = 'EMAILS_BY_USER_ID__COUNT_DESC',
  NotesByUserIdCountAsc = 'NOTES_BY_USER_ID__COUNT_ASC',
  NotesByUserIdCountDesc = 'NOTES_BY_USER_ID__COUNT_DESC',
  QuotesByUserIdCountAsc = 'QUOTES_BY_USER_ID__COUNT_ASC',
  QuotesByUserIdCountDesc = 'QUOTES_BY_USER_ID__COUNT_DESC',
  RemindersByUserIdCountAsc = 'REMINDERS_BY_USER_ID__COUNT_ASC',
  RemindersByUserIdCountDesc = 'REMINDERS_BY_USER_ID__COUNT_DESC',
  TransactionNotesByUserIdCountAsc = 'TRANSACTION_NOTES_BY_USER_ID__COUNT_ASC',
  TransactionNotesByUserIdCountDesc = 'TRANSACTION_NOTES_BY_USER_ID__COUNT_DESC',
  QuotePublicsByUserIdCountAsc = 'QUOTE_PUBLICS_BY_USER_ID__COUNT_ASC',
  QuotePublicsByUserIdCountDesc = 'QUOTE_PUBLICS_BY_USER_ID__COUNT_DESC'
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `password` field. */
  password?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skype` field. */
  skype?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `genderPreposition` field. */
  genderPreposition?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `VirtualTransaction`. */
export enum VirtualTransactionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  AccountIdAsc = 'ACCOUNT_ID_ASC',
  AccountIdDesc = 'ACCOUNT_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  ReverseTransactionIdAsc = 'REVERSE_TRANSACTION_ID_ASC',
  ReverseTransactionIdDesc = 'REVERSE_TRANSACTION_ID_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC',
  TransactionImportBatchIdAsc = 'TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionImportBatchIdDesc = 'TRANSACTION_IMPORT_BATCH_ID_DESC',
  BalanceAsc = 'BALANCE_ASC',
  BalanceDesc = 'BALANCE_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC'
}

/** A condition to be used against `VirtualTransaction` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VirtualTransactionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `accountId` field. */
  accountId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reverseTransactionId` field. */
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `source` field. */
  source?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `balance` field. */
  balance?: Maybe<Scalars['BigFloat']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `VirtualTransaction` object types. All fields are combined with a logical ‘and.’ */
export type VirtualTransactionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `accountId` field. */
  accountId?: Maybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `externalId` field. */
  externalId?: Maybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<IntFilter>;
  /** Filter by the object’s `reverseTransactionId` field. */
  reverseTransactionId?: Maybe<UuidFilter>;
  /** Filter by the object’s `source` field. */
  source?: Maybe<StringFilter>;
  /** Filter by the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: Maybe<UuidFilter>;
  /** Filter by the object’s `balance` field. */
  balance?: Maybe<BigFloatFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: Maybe<StringFilter>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VirtualTransactionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VirtualTransactionFilter>>;
  /** Negates the expression. */
  not?: Maybe<VirtualTransactionFilter>;
};

/** A connection to a list of `VirtualTransaction` values. */
export type VirtualTransactionsConnection = {
  __typename?: 'VirtualTransactionsConnection';
  /** A list of `VirtualTransaction` objects. */
  nodes: Array<Maybe<VirtualTransaction>>;
  /** A list of edges which contains the `VirtualTransaction` and cursor to aid in pagination. */
  edges: Array<VirtualTransactionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VirtualTransaction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type VirtualTransaction = {
  __typename?: 'VirtualTransaction';
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
};

/** A `VirtualTransaction` edge in the connection. */
export type VirtualTransactionsEdge = {
  __typename?: 'VirtualTransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VirtualTransaction` at the end of the edge. */
  node?: Maybe<VirtualTransaction>;
};

/** Methods to use when ordering `VisaRequirement`. */
export enum VisaRequirementsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  LastVerifiedAsc = 'LAST_VERIFIED_ASC',
  LastVerifiedDesc = 'LAST_VERIFIED_DESC',
  DestinationCountriesAsc = 'DESTINATION_COUNTRIES_ASC',
  DestinationCountriesDesc = 'DESTINATION_COUNTRIES_DESC',
  PassportCountriesAsc = 'PASSPORT_COUNTRIES_ASC',
  PassportCountriesDesc = 'PASSPORT_COUNTRIES_DESC',
  DetailAsc = 'DETAIL_ASC',
  DetailDesc = 'DETAIL_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `VisaRequirement` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VisaRequirementCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `created` field. */
  created?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `lastVerified` field. */
  lastVerified?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `destinationCountries` field. */
  destinationCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `passportCountries` field. */
  passportCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `detail` field. */
  detail?: Maybe<Scalars['String']>;
};

/** A filter to be used against `VisaRequirement` object types. All fields are combined with a logical ‘and.’ */
export type VisaRequirementFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `lastVerified` field. */
  lastVerified?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `destinationCountries` field. */
  destinationCountries?: Maybe<StringListFilter>;
  /** Filter by the object’s `passportCountries` field. */
  passportCountries?: Maybe<StringListFilter>;
  /** Filter by the object’s `detail` field. */
  detail?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<VisaRequirementFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<VisaRequirementFilter>>;
  /** Negates the expression. */
  not?: Maybe<VisaRequirementFilter>;
};

/** A connection to a list of `VisaRequirement` values. */
export type VisaRequirementsConnection = {
  __typename?: 'VisaRequirementsConnection';
  /** A list of `VisaRequirement` objects. */
  nodes: Array<Maybe<VisaRequirement>>;
  /** A list of edges which contains the `VisaRequirement` and cursor to aid in pagination. */
  edges: Array<VisaRequirementsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VisaRequirement` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type VisaRequirement = Node & {
  __typename?: 'VisaRequirement';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  created: Scalars['Datetime'];
  modified: Scalars['Datetime'];
  lastVerified: Scalars['Datetime'];
  destinationCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  passportCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  detail?: Maybe<Scalars['String']>;
};

/** A `VisaRequirement` edge in the connection. */
export type VisaRequirementsEdge = {
  __typename?: 'VisaRequirementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `VisaRequirement` at the end of the edge. */
  node?: Maybe<VisaRequirement>;
};

export type InvoicePublic = Node & {
  __typename?: 'InvoicePublic';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  due?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  amount?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  amountPaid?: Maybe<Scalars['BigFloat']>;
  amountDue?: Maybe<Scalars['BigFloat']>;
  trip?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  categoryId?: Maybe<Scalars['UUID']>;
  key?: Maybe<Scalars['String']>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `Account`. */
  createAccount?: Maybe<CreateAccountPayload>;
  /** Creates a single `Agency`. */
  createAgency?: Maybe<CreateAgencyPayload>;
  /** Creates a single `AgencyMember`. */
  createAgencyMember?: Maybe<CreateAgencyMemberPayload>;
  /** Creates a single `Airport`. */
  createAirport?: Maybe<CreateAirportPayload>;
  /** Creates a single `Country`. */
  createCountry?: Maybe<CreateCountryPayload>;
  /** Creates a single `Customer`. */
  createCustomer?: Maybe<CreateCustomerPayload>;
  /** Creates a single `CustomerTraveller`. */
  createCustomerTraveller?: Maybe<CreateCustomerTravellerPayload>;
  /** Creates a single `Destination`. */
  createDestination?: Maybe<CreateDestinationPayload>;
  /** Creates a single `DestinationFeature`. */
  createDestinationFeature?: Maybe<CreateDestinationFeaturePayload>;
  /** Creates a single `DestinationGuide`. */
  createDestinationGuide?: Maybe<CreateDestinationGuidePayload>;
  /** Creates a single `Email`. */
  createEmail?: Maybe<CreateEmailPayload>;
  /** Creates a single `Enquiry`. */
  createEnquiry?: Maybe<CreateEnquiryPayload>;
  /** Creates a single `Expense`. */
  createExpense?: Maybe<CreateExpensePayload>;
  /** Creates a single `Feature`. */
  createFeature?: Maybe<CreateFeaturePayload>;
  /** Creates a single `FinanceCategory`. */
  createFinanceCategory?: Maybe<CreateFinanceCategoryPayload>;
  /** Creates a single `Invoice`. */
  createInvoice?: Maybe<CreateInvoicePayload>;
  /** Creates a single `MapPoint`. */
  createMapPoint?: Maybe<CreateMapPointPayload>;
  /** Creates a single `MediaGallery`. */
  createMediaGallery?: Maybe<CreateMediaGalleryPayload>;
  /** Creates a single `MediaGalleryItem`. */
  createMediaGalleryItem?: Maybe<CreateMediaGalleryItemPayload>;
  /** Creates a single `MediaItem`. */
  createMediaItem?: Maybe<CreateMediaItemPayload>;
  /** Creates a single `Note`. */
  createNote?: Maybe<CreateNotePayload>;
  /** Creates a single `Passport`. */
  createPassport?: Maybe<CreatePassportPayload>;
  /** Creates a single `Payment`. */
  createPayment?: Maybe<CreatePaymentPayload>;
  /** Creates a single `Property`. */
  createProperty?: Maybe<CreatePropertyPayload>;
  /** Creates a single `Quote`. */
  createQuote?: Maybe<CreateQuotePayload>;
  /** Creates a single `QuoteView`. */
  createQuoteView?: Maybe<CreateQuoteViewPayload>;
  /** Creates a single `QuoteAccommodationDetail`. */
  createQuoteAccommodationDetail?: Maybe<CreateQuoteAccommodationDetailPayload>;
  /** Creates a single `QuoteCurrency`. */
  createQuoteCurrency?: Maybe<CreateQuoteCurrencyPayload>;
  /** Creates a single `QuoteDay`. */
  createQuoteDay?: Maybe<CreateQuoteDayPayload>;
  /** Creates a single `QuoteDayDestination`. */
  createQuoteDayDestination?: Maybe<CreateQuoteDayDestinationPayload>;
  /** Creates a single `QuoteFinanceLineItem`. */
  createQuoteFinanceLineItem?: Maybe<CreateQuoteFinanceLineItemPayload>;
  /** Creates a single `QuoteHero`. */
  createQuoteHero?: Maybe<CreateQuoteHeroPayload>;
  /** Creates a single `QuotePublic`. */
  createQuotePublic?: Maybe<CreateQuotePublicPayload>;
  /** Creates a single `Reminder`. */
  createReminder?: Maybe<CreateReminderPayload>;
  /** Creates a single `Supplier`. */
  createSupplier?: Maybe<CreateSupplierPayload>;
  /** Creates a single `SupplierInvoice`. */
  createSupplierInvoice?: Maybe<CreateSupplierInvoicePayload>;
  /** Creates a single `Testimonial`. */
  createTestimonial?: Maybe<CreateTestimonialPayload>;
  /** Creates a single `Transaction`. */
  createTransaction?: Maybe<CreateTransactionPayload>;
  /** Creates a single `TransactionImportBatch`. */
  createTransactionImportBatch?: Maybe<CreateTransactionImportBatchPayload>;
  /** Creates a single `TransactionLink`. */
  createTransactionLink?: Maybe<CreateTransactionLinkPayload>;
  /** Creates a single `TransactionNote`. */
  createTransactionNote?: Maybe<CreateTransactionNotePayload>;
  /** Creates a single `Traveller`. */
  createTraveller?: Maybe<CreateTravellerPayload>;
  /** Creates a single `Trip`. */
  createTrip?: Maybe<CreateTripPayload>;
  /** Creates a single `TripTraveller`. */
  createTripTraveller?: Maybe<CreateTripTravellerPayload>;
  /** Creates a single `TripFlight`. */
  createTripFlight?: Maybe<CreateTripFlightPayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `VisaRequirement`. */
  createVisaRequirement?: Maybe<CreateVisaRequirementPayload>;
  /** Updates a single `Account` using its globally unique id and a patch. */
  updateAccountByNodeId?: Maybe<UpdateAccountPayload>;
  /** Updates a single `Account` using a unique key and a patch. */
  updateAccount?: Maybe<UpdateAccountPayload>;
  /** Updates a single `Agency` using its globally unique id and a patch. */
  updateAgencyByNodeId?: Maybe<UpdateAgencyPayload>;
  /** Updates a single `Agency` using a unique key and a patch. */
  updateAgency?: Maybe<UpdateAgencyPayload>;
  /** Updates a single `AgencyMember` using its globally unique id and a patch. */
  updateAgencyMemberByNodeId?: Maybe<UpdateAgencyMemberPayload>;
  /** Updates a single `AgencyMember` using a unique key and a patch. */
  updateAgencyMember?: Maybe<UpdateAgencyMemberPayload>;
  /** Updates a single `Airport` using its globally unique id and a patch. */
  updateAirportByNodeId?: Maybe<UpdateAirportPayload>;
  /** Updates a single `Airport` using a unique key and a patch. */
  updateAirport?: Maybe<UpdateAirportPayload>;
  /** Updates a single `Country` using its globally unique id and a patch. */
  updateCountryByNodeId?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Country` using a unique key and a patch. */
  updateCountry?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Customer` using its globally unique id and a patch. */
  updateCustomerByNodeId?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `Customer` using a unique key and a patch. */
  updateCustomer?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `CustomerTraveller` using its globally unique id and a patch. */
  updateCustomerTravellerByNodeId?: Maybe<UpdateCustomerTravellerPayload>;
  /** Updates a single `CustomerTraveller` using a unique key and a patch. */
  updateCustomerTraveller?: Maybe<UpdateCustomerTravellerPayload>;
  /** Updates a single `Destination` using its globally unique id and a patch. */
  updateDestinationByNodeId?: Maybe<UpdateDestinationPayload>;
  /** Updates a single `Destination` using a unique key and a patch. */
  updateDestination?: Maybe<UpdateDestinationPayload>;
  /** Updates a single `DestinationFeature` using its globally unique id and a patch. */
  updateDestinationFeatureByNodeId?: Maybe<UpdateDestinationFeaturePayload>;
  /** Updates a single `DestinationFeature` using a unique key and a patch. */
  updateDestinationFeature?: Maybe<UpdateDestinationFeaturePayload>;
  /** Updates a single `DestinationGuide` using its globally unique id and a patch. */
  updateDestinationGuideByNodeId?: Maybe<UpdateDestinationGuidePayload>;
  /** Updates a single `DestinationGuide` using a unique key and a patch. */
  updateDestinationGuide?: Maybe<UpdateDestinationGuidePayload>;
  /** Updates a single `Email` using its globally unique id and a patch. */
  updateEmailByNodeId?: Maybe<UpdateEmailPayload>;
  /** Updates a single `Email` using a unique key and a patch. */
  updateEmail?: Maybe<UpdateEmailPayload>;
  /** Updates a single `Enquiry` using its globally unique id and a patch. */
  updateEnquiryByNodeId?: Maybe<UpdateEnquiryPayload>;
  /** Updates a single `Enquiry` using a unique key and a patch. */
  updateEnquiry?: Maybe<UpdateEnquiryPayload>;
  /** Updates a single `Expense` using its globally unique id and a patch. */
  updateExpenseByNodeId?: Maybe<UpdateExpensePayload>;
  /** Updates a single `Expense` using a unique key and a patch. */
  updateExpense?: Maybe<UpdateExpensePayload>;
  /** Updates a single `Feature` using its globally unique id and a patch. */
  updateFeatureByNodeId?: Maybe<UpdateFeaturePayload>;
  /** Updates a single `Feature` using a unique key and a patch. */
  updateFeature?: Maybe<UpdateFeaturePayload>;
  /** Updates a single `FinanceCategory` using its globally unique id and a patch. */
  updateFinanceCategoryByNodeId?: Maybe<UpdateFinanceCategoryPayload>;
  /** Updates a single `FinanceCategory` using a unique key and a patch. */
  updateFinanceCategory?: Maybe<UpdateFinanceCategoryPayload>;
  /** Updates a single `Invoice` using its globally unique id and a patch. */
  updateInvoiceByNodeId?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `Invoice` using a unique key and a patch. */
  updateInvoice?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `MapPoint` using its globally unique id and a patch. */
  updateMapPointByNodeId?: Maybe<UpdateMapPointPayload>;
  /** Updates a single `MapPoint` using a unique key and a patch. */
  updateMapPoint?: Maybe<UpdateMapPointPayload>;
  /** Updates a single `MediaGallery` using its globally unique id and a patch. */
  updateMediaGalleryByNodeId?: Maybe<UpdateMediaGalleryPayload>;
  /** Updates a single `MediaGallery` using a unique key and a patch. */
  updateMediaGallery?: Maybe<UpdateMediaGalleryPayload>;
  /** Updates a single `MediaGalleryItem` using its globally unique id and a patch. */
  updateMediaGalleryItemByNodeId?: Maybe<UpdateMediaGalleryItemPayload>;
  /** Updates a single `MediaGalleryItem` using a unique key and a patch. */
  updateMediaGalleryItem?: Maybe<UpdateMediaGalleryItemPayload>;
  /** Updates a single `MediaItem` using its globally unique id and a patch. */
  updateMediaItemByNodeId?: Maybe<UpdateMediaItemPayload>;
  /** Updates a single `MediaItem` using a unique key and a patch. */
  updateMediaItem?: Maybe<UpdateMediaItemPayload>;
  /** Updates a single `Note` using its globally unique id and a patch. */
  updateNoteByNodeId?: Maybe<UpdateNotePayload>;
  /** Updates a single `Note` using a unique key and a patch. */
  updateNote?: Maybe<UpdateNotePayload>;
  /** Updates a single `Passport` using its globally unique id and a patch. */
  updatePassportByNodeId?: Maybe<UpdatePassportPayload>;
  /** Updates a single `Passport` using a unique key and a patch. */
  updatePassport?: Maybe<UpdatePassportPayload>;
  /** Updates a single `Payment` using its globally unique id and a patch. */
  updatePaymentByNodeId?: Maybe<UpdatePaymentPayload>;
  /** Updates a single `Payment` using a unique key and a patch. */
  updatePayment?: Maybe<UpdatePaymentPayload>;
  /** Updates a single `Property` using its globally unique id and a patch. */
  updatePropertyByNodeId?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Property` using a unique key and a patch. */
  updateProperty?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Quote` using its globally unique id and a patch. */
  updateQuoteByNodeId?: Maybe<UpdateQuotePayload>;
  /** Updates a single `Quote` using a unique key and a patch. */
  updateQuote?: Maybe<UpdateQuotePayload>;
  /** Updates a single `QuoteView` using its globally unique id and a patch. */
  updateQuoteViewByNodeId?: Maybe<UpdateQuoteViewPayload>;
  /** Updates a single `QuoteView` using a unique key and a patch. */
  updateQuoteView?: Maybe<UpdateQuoteViewPayload>;
  /** Updates a single `QuoteAccommodationDetail` using its globally unique id and a patch. */
  updateQuoteAccommodationDetailByNodeId?: Maybe<UpdateQuoteAccommodationDetailPayload>;
  /** Updates a single `QuoteAccommodationDetail` using a unique key and a patch. */
  updateQuoteAccommodationDetail?: Maybe<UpdateQuoteAccommodationDetailPayload>;
  /** Updates a single `QuoteCurrency` using its globally unique id and a patch. */
  updateQuoteCurrencyByNodeId?: Maybe<UpdateQuoteCurrencyPayload>;
  /** Updates a single `QuoteCurrency` using a unique key and a patch. */
  updateQuoteCurrency?: Maybe<UpdateQuoteCurrencyPayload>;
  /** Updates a single `QuoteDay` using its globally unique id and a patch. */
  updateQuoteDayByNodeId?: Maybe<UpdateQuoteDayPayload>;
  /** Updates a single `QuoteDay` using a unique key and a patch. */
  updateQuoteDay?: Maybe<UpdateQuoteDayPayload>;
  /** Updates a single `QuoteDayDestination` using its globally unique id and a patch. */
  updateQuoteDayDestinationByNodeId?: Maybe<UpdateQuoteDayDestinationPayload>;
  /** Updates a single `QuoteDayDestination` using a unique key and a patch. */
  updateQuoteDayDestination?: Maybe<UpdateQuoteDayDestinationPayload>;
  /** Updates a single `QuoteFinanceLineItem` using its globally unique id and a patch. */
  updateQuoteFinanceLineItemByNodeId?: Maybe<UpdateQuoteFinanceLineItemPayload>;
  /** Updates a single `QuoteFinanceLineItem` using a unique key and a patch. */
  updateQuoteFinanceLineItem?: Maybe<UpdateQuoteFinanceLineItemPayload>;
  /** Updates a single `QuoteHero` using its globally unique id and a patch. */
  updateQuoteHeroByNodeId?: Maybe<UpdateQuoteHeroPayload>;
  /** Updates a single `QuoteHero` using a unique key and a patch. */
  updateQuoteHero?: Maybe<UpdateQuoteHeroPayload>;
  /** Updates a single `QuotePublic` using its globally unique id and a patch. */
  updateQuotePublicByNodeId?: Maybe<UpdateQuotePublicPayload>;
  /** Updates a single `QuotePublic` using a unique key and a patch. */
  updateQuotePublic?: Maybe<UpdateQuotePublicPayload>;
  /** Updates a single `Reminder` using its globally unique id and a patch. */
  updateReminderByNodeId?: Maybe<UpdateReminderPayload>;
  /** Updates a single `Reminder` using a unique key and a patch. */
  updateReminder?: Maybe<UpdateReminderPayload>;
  /** Updates a single `Supplier` using its globally unique id and a patch. */
  updateSupplierByNodeId?: Maybe<UpdateSupplierPayload>;
  /** Updates a single `Supplier` using a unique key and a patch. */
  updateSupplier?: Maybe<UpdateSupplierPayload>;
  /** Updates a single `SupplierInvoice` using its globally unique id and a patch. */
  updateSupplierInvoiceByNodeId?: Maybe<UpdateSupplierInvoicePayload>;
  /** Updates a single `SupplierInvoice` using a unique key and a patch. */
  updateSupplierInvoice?: Maybe<UpdateSupplierInvoicePayload>;
  /** Updates a single `Testimonial` using its globally unique id and a patch. */
  updateTestimonialByNodeId?: Maybe<UpdateTestimonialPayload>;
  /** Updates a single `Testimonial` using a unique key and a patch. */
  updateTestimonial?: Maybe<UpdateTestimonialPayload>;
  /** Updates a single `Transaction` using its globally unique id and a patch. */
  updateTransactionByNodeId?: Maybe<UpdateTransactionPayload>;
  /** Updates a single `Transaction` using a unique key and a patch. */
  updateTransaction?: Maybe<UpdateTransactionPayload>;
  /** Updates a single `TransactionImportBatch` using its globally unique id and a patch. */
  updateTransactionImportBatchByNodeId?: Maybe<UpdateTransactionImportBatchPayload>;
  /** Updates a single `TransactionImportBatch` using a unique key and a patch. */
  updateTransactionImportBatch?: Maybe<UpdateTransactionImportBatchPayload>;
  /** Updates a single `TransactionLink` using its globally unique id and a patch. */
  updateTransactionLinkByNodeId?: Maybe<UpdateTransactionLinkPayload>;
  /** Updates a single `TransactionLink` using a unique key and a patch. */
  updateTransactionLink?: Maybe<UpdateTransactionLinkPayload>;
  /** Updates a single `TransactionNote` using its globally unique id and a patch. */
  updateTransactionNoteByNodeId?: Maybe<UpdateTransactionNotePayload>;
  /** Updates a single `TransactionNote` using a unique key and a patch. */
  updateTransactionNote?: Maybe<UpdateTransactionNotePayload>;
  /** Updates a single `Traveller` using its globally unique id and a patch. */
  updateTravellerByNodeId?: Maybe<UpdateTravellerPayload>;
  /** Updates a single `Traveller` using a unique key and a patch. */
  updateTraveller?: Maybe<UpdateTravellerPayload>;
  /** Updates a single `Trip` using its globally unique id and a patch. */
  updateTripByNodeId?: Maybe<UpdateTripPayload>;
  /** Updates a single `Trip` using a unique key and a patch. */
  updateTrip?: Maybe<UpdateTripPayload>;
  /** Updates a single `TripTraveller` using its globally unique id and a patch. */
  updateTripTravellerByNodeId?: Maybe<UpdateTripTravellerPayload>;
  /** Updates a single `TripTraveller` using a unique key and a patch. */
  updateTripTraveller?: Maybe<UpdateTripTravellerPayload>;
  /** Updates a single `TripFlight` using its globally unique id and a patch. */
  updateTripFlightByNodeId?: Maybe<UpdateTripFlightPayload>;
  /** Updates a single `TripFlight` using a unique key and a patch. */
  updateTripFlight?: Maybe<UpdateTripFlightPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `VisaRequirement` using its globally unique id and a patch. */
  updateVisaRequirementByNodeId?: Maybe<UpdateVisaRequirementPayload>;
  /** Updates a single `VisaRequirement` using a unique key and a patch. */
  updateVisaRequirement?: Maybe<UpdateVisaRequirementPayload>;
  /** Deletes a single `Account` using its globally unique id. */
  deleteAccountByNodeId?: Maybe<DeleteAccountPayload>;
  /** Deletes a single `Account` using a unique key. */
  deleteAccount?: Maybe<DeleteAccountPayload>;
  /** Deletes a single `Agency` using its globally unique id. */
  deleteAgencyByNodeId?: Maybe<DeleteAgencyPayload>;
  /** Deletes a single `Agency` using a unique key. */
  deleteAgency?: Maybe<DeleteAgencyPayload>;
  /** Deletes a single `AgencyMember` using its globally unique id. */
  deleteAgencyMemberByNodeId?: Maybe<DeleteAgencyMemberPayload>;
  /** Deletes a single `AgencyMember` using a unique key. */
  deleteAgencyMember?: Maybe<DeleteAgencyMemberPayload>;
  /** Deletes a single `Airport` using its globally unique id. */
  deleteAirportByNodeId?: Maybe<DeleteAirportPayload>;
  /** Deletes a single `Airport` using a unique key. */
  deleteAirport?: Maybe<DeleteAirportPayload>;
  /** Deletes a single `Country` using its globally unique id. */
  deleteCountryByNodeId?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Country` using a unique key. */
  deleteCountry?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Customer` using its globally unique id. */
  deleteCustomerByNodeId?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `Customer` using a unique key. */
  deleteCustomer?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `CustomerTraveller` using its globally unique id. */
  deleteCustomerTravellerByNodeId?: Maybe<DeleteCustomerTravellerPayload>;
  /** Deletes a single `CustomerTraveller` using a unique key. */
  deleteCustomerTraveller?: Maybe<DeleteCustomerTravellerPayload>;
  /** Deletes a single `Destination` using its globally unique id. */
  deleteDestinationByNodeId?: Maybe<DeleteDestinationPayload>;
  /** Deletes a single `Destination` using a unique key. */
  deleteDestination?: Maybe<DeleteDestinationPayload>;
  /** Deletes a single `DestinationFeature` using its globally unique id. */
  deleteDestinationFeatureByNodeId?: Maybe<DeleteDestinationFeaturePayload>;
  /** Deletes a single `DestinationFeature` using a unique key. */
  deleteDestinationFeature?: Maybe<DeleteDestinationFeaturePayload>;
  /** Deletes a single `DestinationGuide` using its globally unique id. */
  deleteDestinationGuideByNodeId?: Maybe<DeleteDestinationGuidePayload>;
  /** Deletes a single `DestinationGuide` using a unique key. */
  deleteDestinationGuide?: Maybe<DeleteDestinationGuidePayload>;
  /** Deletes a single `Email` using its globally unique id. */
  deleteEmailByNodeId?: Maybe<DeleteEmailPayload>;
  /** Deletes a single `Email` using a unique key. */
  deleteEmail?: Maybe<DeleteEmailPayload>;
  /** Deletes a single `Enquiry` using its globally unique id. */
  deleteEnquiryByNodeId?: Maybe<DeleteEnquiryPayload>;
  /** Deletes a single `Enquiry` using a unique key. */
  deleteEnquiry?: Maybe<DeleteEnquiryPayload>;
  /** Deletes a single `Expense` using its globally unique id. */
  deleteExpenseByNodeId?: Maybe<DeleteExpensePayload>;
  /** Deletes a single `Expense` using a unique key. */
  deleteExpense?: Maybe<DeleteExpensePayload>;
  /** Deletes a single `Feature` using its globally unique id. */
  deleteFeatureByNodeId?: Maybe<DeleteFeaturePayload>;
  /** Deletes a single `Feature` using a unique key. */
  deleteFeature?: Maybe<DeleteFeaturePayload>;
  /** Deletes a single `FinanceCategory` using its globally unique id. */
  deleteFinanceCategoryByNodeId?: Maybe<DeleteFinanceCategoryPayload>;
  /** Deletes a single `FinanceCategory` using a unique key. */
  deleteFinanceCategory?: Maybe<DeleteFinanceCategoryPayload>;
  /** Deletes a single `Invoice` using its globally unique id. */
  deleteInvoiceByNodeId?: Maybe<DeleteInvoicePayload>;
  /** Deletes a single `Invoice` using a unique key. */
  deleteInvoice?: Maybe<DeleteInvoicePayload>;
  /** Deletes a single `MapPoint` using its globally unique id. */
  deleteMapPointByNodeId?: Maybe<DeleteMapPointPayload>;
  /** Deletes a single `MapPoint` using a unique key. */
  deleteMapPoint?: Maybe<DeleteMapPointPayload>;
  /** Deletes a single `MediaGallery` using its globally unique id. */
  deleteMediaGalleryByNodeId?: Maybe<DeleteMediaGalleryPayload>;
  /** Deletes a single `MediaGallery` using a unique key. */
  deleteMediaGallery?: Maybe<DeleteMediaGalleryPayload>;
  /** Deletes a single `MediaGalleryItem` using its globally unique id. */
  deleteMediaGalleryItemByNodeId?: Maybe<DeleteMediaGalleryItemPayload>;
  /** Deletes a single `MediaGalleryItem` using a unique key. */
  deleteMediaGalleryItem?: Maybe<DeleteMediaGalleryItemPayload>;
  /** Deletes a single `MediaItem` using its globally unique id. */
  deleteMediaItemByNodeId?: Maybe<DeleteMediaItemPayload>;
  /** Deletes a single `MediaItem` using a unique key. */
  deleteMediaItem?: Maybe<DeleteMediaItemPayload>;
  /** Deletes a single `Note` using its globally unique id. */
  deleteNoteByNodeId?: Maybe<DeleteNotePayload>;
  /** Deletes a single `Note` using a unique key. */
  deleteNote?: Maybe<DeleteNotePayload>;
  /** Deletes a single `Passport` using its globally unique id. */
  deletePassportByNodeId?: Maybe<DeletePassportPayload>;
  /** Deletes a single `Passport` using a unique key. */
  deletePassport?: Maybe<DeletePassportPayload>;
  /** Deletes a single `Payment` using its globally unique id. */
  deletePaymentByNodeId?: Maybe<DeletePaymentPayload>;
  /** Deletes a single `Payment` using a unique key. */
  deletePayment?: Maybe<DeletePaymentPayload>;
  /** Deletes a single `Property` using its globally unique id. */
  deletePropertyByNodeId?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Property` using a unique key. */
  deleteProperty?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Quote` using its globally unique id. */
  deleteQuoteByNodeId?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `Quote` using a unique key. */
  deleteQuote?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `QuoteView` using its globally unique id. */
  deleteQuoteViewByNodeId?: Maybe<DeleteQuoteViewPayload>;
  /** Deletes a single `QuoteView` using a unique key. */
  deleteQuoteView?: Maybe<DeleteQuoteViewPayload>;
  /** Deletes a single `QuoteAccommodationDetail` using its globally unique id. */
  deleteQuoteAccommodationDetailByNodeId?: Maybe<DeleteQuoteAccommodationDetailPayload>;
  /** Deletes a single `QuoteAccommodationDetail` using a unique key. */
  deleteQuoteAccommodationDetail?: Maybe<DeleteQuoteAccommodationDetailPayload>;
  /** Deletes a single `QuoteCurrency` using its globally unique id. */
  deleteQuoteCurrencyByNodeId?: Maybe<DeleteQuoteCurrencyPayload>;
  /** Deletes a single `QuoteCurrency` using a unique key. */
  deleteQuoteCurrency?: Maybe<DeleteQuoteCurrencyPayload>;
  /** Deletes a single `QuoteDay` using its globally unique id. */
  deleteQuoteDayByNodeId?: Maybe<DeleteQuoteDayPayload>;
  /** Deletes a single `QuoteDay` using a unique key. */
  deleteQuoteDay?: Maybe<DeleteQuoteDayPayload>;
  /** Deletes a single `QuoteDayDestination` using its globally unique id. */
  deleteQuoteDayDestinationByNodeId?: Maybe<DeleteQuoteDayDestinationPayload>;
  /** Deletes a single `QuoteDayDestination` using a unique key. */
  deleteQuoteDayDestination?: Maybe<DeleteQuoteDayDestinationPayload>;
  /** Deletes a single `QuoteFinanceLineItem` using its globally unique id. */
  deleteQuoteFinanceLineItemByNodeId?: Maybe<DeleteQuoteFinanceLineItemPayload>;
  /** Deletes a single `QuoteFinanceLineItem` using a unique key. */
  deleteQuoteFinanceLineItem?: Maybe<DeleteQuoteFinanceLineItemPayload>;
  /** Deletes a single `QuoteHero` using its globally unique id. */
  deleteQuoteHeroByNodeId?: Maybe<DeleteQuoteHeroPayload>;
  /** Deletes a single `QuoteHero` using a unique key. */
  deleteQuoteHero?: Maybe<DeleteQuoteHeroPayload>;
  /** Deletes a single `QuotePublic` using its globally unique id. */
  deleteQuotePublicByNodeId?: Maybe<DeleteQuotePublicPayload>;
  /** Deletes a single `QuotePublic` using a unique key. */
  deleteQuotePublic?: Maybe<DeleteQuotePublicPayload>;
  /** Deletes a single `Reminder` using its globally unique id. */
  deleteReminderByNodeId?: Maybe<DeleteReminderPayload>;
  /** Deletes a single `Reminder` using a unique key. */
  deleteReminder?: Maybe<DeleteReminderPayload>;
  /** Deletes a single `Supplier` using its globally unique id. */
  deleteSupplierByNodeId?: Maybe<DeleteSupplierPayload>;
  /** Deletes a single `Supplier` using a unique key. */
  deleteSupplier?: Maybe<DeleteSupplierPayload>;
  /** Deletes a single `SupplierInvoice` using its globally unique id. */
  deleteSupplierInvoiceByNodeId?: Maybe<DeleteSupplierInvoicePayload>;
  /** Deletes a single `SupplierInvoice` using a unique key. */
  deleteSupplierInvoice?: Maybe<DeleteSupplierInvoicePayload>;
  /** Deletes a single `Testimonial` using its globally unique id. */
  deleteTestimonialByNodeId?: Maybe<DeleteTestimonialPayload>;
  /** Deletes a single `Testimonial` using a unique key. */
  deleteTestimonial?: Maybe<DeleteTestimonialPayload>;
  /** Deletes a single `Transaction` using its globally unique id. */
  deleteTransactionByNodeId?: Maybe<DeleteTransactionPayload>;
  /** Deletes a single `Transaction` using a unique key. */
  deleteTransaction?: Maybe<DeleteTransactionPayload>;
  /** Deletes a single `TransactionImportBatch` using its globally unique id. */
  deleteTransactionImportBatchByNodeId?: Maybe<DeleteTransactionImportBatchPayload>;
  /** Deletes a single `TransactionImportBatch` using a unique key. */
  deleteTransactionImportBatch?: Maybe<DeleteTransactionImportBatchPayload>;
  /** Deletes a single `TransactionLink` using its globally unique id. */
  deleteTransactionLinkByNodeId?: Maybe<DeleteTransactionLinkPayload>;
  /** Deletes a single `TransactionLink` using a unique key. */
  deleteTransactionLink?: Maybe<DeleteTransactionLinkPayload>;
  /** Deletes a single `TransactionNote` using its globally unique id. */
  deleteTransactionNoteByNodeId?: Maybe<DeleteTransactionNotePayload>;
  /** Deletes a single `TransactionNote` using a unique key. */
  deleteTransactionNote?: Maybe<DeleteTransactionNotePayload>;
  /** Deletes a single `Traveller` using its globally unique id. */
  deleteTravellerByNodeId?: Maybe<DeleteTravellerPayload>;
  /** Deletes a single `Traveller` using a unique key. */
  deleteTraveller?: Maybe<DeleteTravellerPayload>;
  /** Deletes a single `Trip` using its globally unique id. */
  deleteTripByNodeId?: Maybe<DeleteTripPayload>;
  /** Deletes a single `Trip` using a unique key. */
  deleteTrip?: Maybe<DeleteTripPayload>;
  /** Deletes a single `TripTraveller` using its globally unique id. */
  deleteTripTravellerByNodeId?: Maybe<DeleteTripTravellerPayload>;
  /** Deletes a single `TripTraveller` using a unique key. */
  deleteTripTraveller?: Maybe<DeleteTripTravellerPayload>;
  /** Deletes a single `TripFlight` using its globally unique id. */
  deleteTripFlightByNodeId?: Maybe<DeleteTripFlightPayload>;
  /** Deletes a single `TripFlight` using a unique key. */
  deleteTripFlight?: Maybe<DeleteTripFlightPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `VisaRequirement` using its globally unique id. */
  deleteVisaRequirementByNodeId?: Maybe<DeleteVisaRequirementPayload>;
  /** Deletes a single `VisaRequirement` using a unique key. */
  deleteVisaRequirement?: Maybe<DeleteVisaRequirementPayload>;
  dateWeek?: Maybe<DateWeekPayload>;
  randomString?: Maybe<RandomStringPayload>;
  executePayment?: Maybe<GenericResponse>;
  trackQuoteView?: Maybe<GenericResponse>;
  generateUploadUrl?: Maybe<Scalars['String']>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAccountArgs = {
  input: CreateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAgencyArgs = {
  input: CreateAgencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAgencyMemberArgs = {
  input: CreateAgencyMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAirportArgs = {
  input: CreateAirportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCountryArgs = {
  input: CreateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerTravellerArgs = {
  input: CreateCustomerTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDestinationArgs = {
  input: CreateDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDestinationFeatureArgs = {
  input: CreateDestinationFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDestinationGuideArgs = {
  input: CreateDestinationGuideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEmailArgs = {
  input: CreateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEnquiryArgs = {
  input: CreateEnquiryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateExpenseArgs = {
  input: CreateExpenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFeatureArgs = {
  input: CreateFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFinanceCategoryArgs = {
  input: CreateFinanceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMapPointArgs = {
  input: CreateMapPointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMediaGalleryArgs = {
  input: CreateMediaGalleryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMediaGalleryItemArgs = {
  input: CreateMediaGalleryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMediaItemArgs = {
  input: CreateMediaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePassportArgs = {
  input: CreatePassportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePaymentArgs = {
  input: CreatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePropertyArgs = {
  input: CreatePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteArgs = {
  input: CreateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteViewArgs = {
  input: CreateQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteAccommodationDetailArgs = {
  input: CreateQuoteAccommodationDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteCurrencyArgs = {
  input: CreateQuoteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteDayArgs = {
  input: CreateQuoteDayInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteDayDestinationArgs = {
  input: CreateQuoteDayDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteFinanceLineItemArgs = {
  input: CreateQuoteFinanceLineItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteHeroArgs = {
  input: CreateQuoteHeroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuotePublicArgs = {
  input: CreateQuotePublicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReminderArgs = {
  input: CreateReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSupplierArgs = {
  input: CreateSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSupplierInvoiceArgs = {
  input: CreateSupplierInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTestimonialArgs = {
  input: CreateTestimonialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionArgs = {
  input: CreateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionImportBatchArgs = {
  input: CreateTransactionImportBatchInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionLinkArgs = {
  input: CreateTransactionLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionNoteArgs = {
  input: CreateTransactionNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTravellerArgs = {
  input: CreateTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTripArgs = {
  input: CreateTripInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTripTravellerArgs = {
  input: CreateTripTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTripFlightArgs = {
  input: CreateTripFlightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVisaRequirementArgs = {
  input: CreateVisaRequirementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAccountByNodeIdArgs = {
  input: UpdateAccountByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAccountArgs = {
  input: UpdateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgencyByNodeIdArgs = {
  input: UpdateAgencyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgencyArgs = {
  input: UpdateAgencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgencyMemberByNodeIdArgs = {
  input: UpdateAgencyMemberByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgencyMemberArgs = {
  input: UpdateAgencyMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAirportByNodeIdArgs = {
  input: UpdateAirportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAirportArgs = {
  input: UpdateAirportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCountryByNodeIdArgs = {
  input: UpdateCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCountryArgs = {
  input: UpdateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerByNodeIdArgs = {
  input: UpdateCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerTravellerByNodeIdArgs = {
  input: UpdateCustomerTravellerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerTravellerArgs = {
  input: UpdateCustomerTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationByNodeIdArgs = {
  input: UpdateDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationArgs = {
  input: UpdateDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationFeatureByNodeIdArgs = {
  input: UpdateDestinationFeatureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationFeatureArgs = {
  input: UpdateDestinationFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationGuideByNodeIdArgs = {
  input: UpdateDestinationGuideByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationGuideArgs = {
  input: UpdateDestinationGuideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEmailByNodeIdArgs = {
  input: UpdateEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEmailArgs = {
  input: UpdateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnquiryByNodeIdArgs = {
  input: UpdateEnquiryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnquiryArgs = {
  input: UpdateEnquiryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseByNodeIdArgs = {
  input: UpdateExpenseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseArgs = {
  input: UpdateExpenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeatureByNodeIdArgs = {
  input: UpdateFeatureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeatureArgs = {
  input: UpdateFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFinanceCategoryByNodeIdArgs = {
  input: UpdateFinanceCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFinanceCategoryArgs = {
  input: UpdateFinanceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceByNodeIdArgs = {
  input: UpdateInvoiceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMapPointByNodeIdArgs = {
  input: UpdateMapPointByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMapPointArgs = {
  input: UpdateMapPointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaGalleryByNodeIdArgs = {
  input: UpdateMediaGalleryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaGalleryArgs = {
  input: UpdateMediaGalleryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaGalleryItemByNodeIdArgs = {
  input: UpdateMediaGalleryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaGalleryItemArgs = {
  input: UpdateMediaGalleryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaItemByNodeIdArgs = {
  input: UpdateMediaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaItemArgs = {
  input: UpdateMediaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNoteByNodeIdArgs = {
  input: UpdateNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePassportByNodeIdArgs = {
  input: UpdatePassportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePassportArgs = {
  input: UpdatePassportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePaymentByNodeIdArgs = {
  input: UpdatePaymentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePaymentArgs = {
  input: UpdatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyByNodeIdArgs = {
  input: UpdatePropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyArgs = {
  input: UpdatePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteByNodeIdArgs = {
  input: UpdateQuoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteArgs = {
  input: UpdateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteViewByNodeIdArgs = {
  input: UpdateQuoteViewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteViewArgs = {
  input: UpdateQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteAccommodationDetailByNodeIdArgs = {
  input: UpdateQuoteAccommodationDetailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteAccommodationDetailArgs = {
  input: UpdateQuoteAccommodationDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteCurrencyByNodeIdArgs = {
  input: UpdateQuoteCurrencyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteCurrencyArgs = {
  input: UpdateQuoteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteDayByNodeIdArgs = {
  input: UpdateQuoteDayByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteDayArgs = {
  input: UpdateQuoteDayInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteDayDestinationByNodeIdArgs = {
  input: UpdateQuoteDayDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteDayDestinationArgs = {
  input: UpdateQuoteDayDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteFinanceLineItemByNodeIdArgs = {
  input: UpdateQuoteFinanceLineItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteFinanceLineItemArgs = {
  input: UpdateQuoteFinanceLineItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteHeroByNodeIdArgs = {
  input: UpdateQuoteHeroByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteHeroArgs = {
  input: UpdateQuoteHeroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuotePublicByNodeIdArgs = {
  input: UpdateQuotePublicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuotePublicArgs = {
  input: UpdateQuotePublicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReminderByNodeIdArgs = {
  input: UpdateReminderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReminderArgs = {
  input: UpdateReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSupplierByNodeIdArgs = {
  input: UpdateSupplierByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSupplierArgs = {
  input: UpdateSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSupplierInvoiceByNodeIdArgs = {
  input: UpdateSupplierInvoiceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSupplierInvoiceArgs = {
  input: UpdateSupplierInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTestimonialByNodeIdArgs = {
  input: UpdateTestimonialByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTestimonialArgs = {
  input: UpdateTestimonialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionByNodeIdArgs = {
  input: UpdateTransactionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionArgs = {
  input: UpdateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionImportBatchByNodeIdArgs = {
  input: UpdateTransactionImportBatchByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionImportBatchArgs = {
  input: UpdateTransactionImportBatchInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionLinkByNodeIdArgs = {
  input: UpdateTransactionLinkByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionLinkArgs = {
  input: UpdateTransactionLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionNoteByNodeIdArgs = {
  input: UpdateTransactionNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionNoteArgs = {
  input: UpdateTransactionNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTravellerByNodeIdArgs = {
  input: UpdateTravellerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTravellerArgs = {
  input: UpdateTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripByNodeIdArgs = {
  input: UpdateTripByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripArgs = {
  input: UpdateTripInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripTravellerByNodeIdArgs = {
  input: UpdateTripTravellerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripTravellerArgs = {
  input: UpdateTripTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripFlightByNodeIdArgs = {
  input: UpdateTripFlightByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripFlightArgs = {
  input: UpdateTripFlightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVisaRequirementByNodeIdArgs = {
  input: UpdateVisaRequirementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVisaRequirementArgs = {
  input: UpdateVisaRequirementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAccountByNodeIdArgs = {
  input: DeleteAccountByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAccountArgs = {
  input: DeleteAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgencyByNodeIdArgs = {
  input: DeleteAgencyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgencyArgs = {
  input: DeleteAgencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgencyMemberByNodeIdArgs = {
  input: DeleteAgencyMemberByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgencyMemberArgs = {
  input: DeleteAgencyMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAirportByNodeIdArgs = {
  input: DeleteAirportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAirportArgs = {
  input: DeleteAirportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCountryByNodeIdArgs = {
  input: DeleteCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCountryArgs = {
  input: DeleteCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerByNodeIdArgs = {
  input: DeleteCustomerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerArgs = {
  input: DeleteCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerTravellerByNodeIdArgs = {
  input: DeleteCustomerTravellerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerTravellerArgs = {
  input: DeleteCustomerTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationByNodeIdArgs = {
  input: DeleteDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationArgs = {
  input: DeleteDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationFeatureByNodeIdArgs = {
  input: DeleteDestinationFeatureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationFeatureArgs = {
  input: DeleteDestinationFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationGuideByNodeIdArgs = {
  input: DeleteDestinationGuideByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationGuideArgs = {
  input: DeleteDestinationGuideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEmailByNodeIdArgs = {
  input: DeleteEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEmailArgs = {
  input: DeleteEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnquiryByNodeIdArgs = {
  input: DeleteEnquiryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnquiryArgs = {
  input: DeleteEnquiryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseByNodeIdArgs = {
  input: DeleteExpenseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseArgs = {
  input: DeleteExpenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeatureByNodeIdArgs = {
  input: DeleteFeatureByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeatureArgs = {
  input: DeleteFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFinanceCategoryByNodeIdArgs = {
  input: DeleteFinanceCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFinanceCategoryArgs = {
  input: DeleteFinanceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceByNodeIdArgs = {
  input: DeleteInvoiceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceArgs = {
  input: DeleteInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMapPointByNodeIdArgs = {
  input: DeleteMapPointByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMapPointArgs = {
  input: DeleteMapPointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaGalleryByNodeIdArgs = {
  input: DeleteMediaGalleryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaGalleryArgs = {
  input: DeleteMediaGalleryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaGalleryItemByNodeIdArgs = {
  input: DeleteMediaGalleryItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaGalleryItemArgs = {
  input: DeleteMediaGalleryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaItemByNodeIdArgs = {
  input: DeleteMediaItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaItemArgs = {
  input: DeleteMediaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNoteByNodeIdArgs = {
  input: DeleteNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNoteArgs = {
  input: DeleteNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePassportByNodeIdArgs = {
  input: DeletePassportByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePassportArgs = {
  input: DeletePassportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePaymentByNodeIdArgs = {
  input: DeletePaymentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePaymentArgs = {
  input: DeletePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyByNodeIdArgs = {
  input: DeletePropertyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyArgs = {
  input: DeletePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteByNodeIdArgs = {
  input: DeleteQuoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteArgs = {
  input: DeleteQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteViewByNodeIdArgs = {
  input: DeleteQuoteViewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteViewArgs = {
  input: DeleteQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteAccommodationDetailByNodeIdArgs = {
  input: DeleteQuoteAccommodationDetailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteAccommodationDetailArgs = {
  input: DeleteQuoteAccommodationDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteCurrencyByNodeIdArgs = {
  input: DeleteQuoteCurrencyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteCurrencyArgs = {
  input: DeleteQuoteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteDayByNodeIdArgs = {
  input: DeleteQuoteDayByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteDayArgs = {
  input: DeleteQuoteDayInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteDayDestinationByNodeIdArgs = {
  input: DeleteQuoteDayDestinationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteDayDestinationArgs = {
  input: DeleteQuoteDayDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteFinanceLineItemByNodeIdArgs = {
  input: DeleteQuoteFinanceLineItemByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteFinanceLineItemArgs = {
  input: DeleteQuoteFinanceLineItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteHeroByNodeIdArgs = {
  input: DeleteQuoteHeroByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteHeroArgs = {
  input: DeleteQuoteHeroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuotePublicByNodeIdArgs = {
  input: DeleteQuotePublicByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuotePublicArgs = {
  input: DeleteQuotePublicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReminderByNodeIdArgs = {
  input: DeleteReminderByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReminderArgs = {
  input: DeleteReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSupplierByNodeIdArgs = {
  input: DeleteSupplierByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSupplierArgs = {
  input: DeleteSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSupplierInvoiceByNodeIdArgs = {
  input: DeleteSupplierInvoiceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSupplierInvoiceArgs = {
  input: DeleteSupplierInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTestimonialByNodeIdArgs = {
  input: DeleteTestimonialByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTestimonialArgs = {
  input: DeleteTestimonialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionByNodeIdArgs = {
  input: DeleteTransactionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionArgs = {
  input: DeleteTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionImportBatchByNodeIdArgs = {
  input: DeleteTransactionImportBatchByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionImportBatchArgs = {
  input: DeleteTransactionImportBatchInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionLinkByNodeIdArgs = {
  input: DeleteTransactionLinkByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionLinkArgs = {
  input: DeleteTransactionLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionNoteByNodeIdArgs = {
  input: DeleteTransactionNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionNoteArgs = {
  input: DeleteTransactionNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTravellerByNodeIdArgs = {
  input: DeleteTravellerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTravellerArgs = {
  input: DeleteTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripByNodeIdArgs = {
  input: DeleteTripByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripArgs = {
  input: DeleteTripInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripTravellerByNodeIdArgs = {
  input: DeleteTripTravellerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripTravellerArgs = {
  input: DeleteTripTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripFlightByNodeIdArgs = {
  input: DeleteTripFlightByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripFlightArgs = {
  input: DeleteTripFlightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVisaRequirementByNodeIdArgs = {
  input: DeleteVisaRequirementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVisaRequirementArgs = {
  input: DeleteVisaRequirementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDateWeekArgs = {
  input: DateWeekInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRandomStringArgs = {
  input: RandomStringInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationExecutePaymentArgs = {
  input: ExecutePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTrackQuoteViewArgs = {
  input: TrackQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationGenerateUploadUrlArgs = {
  input: GenerateUploadUrlInput;
};

/** All input for the create `Account` mutation. */
export type CreateAccountInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` to be created by this mutation. */
  account: AccountInput;
};

/** An input for mutations affecting `Account` */
export type AccountInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  institution?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  transactionsUsingId?: Maybe<FkTransactionAccountAccountIdInverseInput>;
  transactionImportBatchesUsingId?: Maybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
};

/** Input for the nested mutation of `transaction` in the `AccountInput` mutation. */
export type FkTransactionAccountAccountIdInverseInput = {
  /** Flag indicating whether all other `transaction` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionPkTransactionConnect>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionNodeIdConnect>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionPkTransactionDelete>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionNodeIdDelete>>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionOnTransactionForFkTransactionAccountAccountIdUsingPkTransactionUpdate>>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AccountOnTransactionForFkTransactionAccountAccountIdNodeIdUpdate>>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionAccountAccountIdTransactionCreateInput>>;
};

/** The fields on `transaction` to look up the row to connect. */
export type TransactionPkTransactionConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TransactionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `transaction` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `transaction` to look up the row to delete. */
export type TransactionPkTransactionDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TransactionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `transaction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionAccountAccountIdUsingPkTransactionUpdate = {
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionAccountAccountIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionAccountAccountIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** Input for the nested mutation of `account` in the `TransactionInput` mutation. */
export type FkTransactionAccountAccountIdInput = {
  /** The primary key(s) for `account` for the far side of the relationship. */
  connectById?: Maybe<AccountPkAccountConnect>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  connectByNodeId?: Maybe<AccountNodeIdConnect>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  deleteById?: Maybe<AccountPkAccountDelete>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AccountNodeIdDelete>;
  /** The primary key(s) and patch data for `account` for the far side of the relationship. */
  updateById?: Maybe<AccountOnTransactionForFkTransactionAccountAccountIdUsingPkAccountUpdate>;
  /** The primary key(s) and patch data for `account` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionOnTransactionForFkTransactionAccountAccountIdNodeIdUpdate>;
  /** A `AccountInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionAccountAccountIdAccountCreateInput>;
};

/** The fields on `account` to look up the row to connect. */
export type AccountPkAccountConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type AccountNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `account` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `account` to look up the row to delete. */
export type AccountPkAccountDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type AccountNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `account` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `account` to look up the row to update. */
export type AccountOnTransactionForFkTransactionAccountAccountIdUsingPkAccountUpdate = {
  /** An object where the defined keys will be set on the `account` being updated. */
  patch: UpdateAccountOnTransactionForFkTransactionAccountAccountIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `account` being updated. */
export type UpdateAccountOnTransactionForFkTransactionAccountAccountIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  institution?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  transactionsUsingId?: Maybe<FkTransactionAccountAccountIdInverseInput>;
  transactionImportBatchesUsingId?: Maybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
};

/** Input for the nested mutation of `transactionImportBatch` in the `AccountInput` mutation. */
export type FkTransactionImportBatchAccountAccountIdInverseInput = {
  /** Flag indicating whether all other `transactionImportBatch` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionImportBatchPkTransactionImportBatchConnect>>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionImportBatchNodeIdConnect>>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionImportBatchPkTransactionImportBatchDelete>>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionImportBatchNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionImportBatch` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkTransactionImportBatchUpdate>>;
  /** The primary key(s) and patch data for `transactionImportBatch` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdNodeIdUpdate>>;
  /** A `TransactionImportBatchInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionImportBatchAccountAccountIdTransactionImportBatchCreateInput>>;
};

/** The fields on `transactionImportBatch` to look up the row to connect. */
export type TransactionImportBatchPkTransactionImportBatchConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TransactionImportBatchNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `transactionImportBatch` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `transactionImportBatch` to look up the row to delete. */
export type TransactionImportBatchPkTransactionImportBatchDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TransactionImportBatchNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `transactionImportBatch` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `transactionImportBatch` to look up the row to update. */
export type TransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkTransactionImportBatchUpdate = {
  /** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
  patch: UpdateTransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
export type UpdateTransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  dateRangeMin?: Maybe<Scalars['Datetime']>;
  dateRangeMax?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionImportBatchAccountAccountIdInput>;
  transactionsUsingId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** Input for the nested mutation of `account` in the `TransactionImportBatchInput` mutation. */
export type FkTransactionImportBatchAccountAccountIdInput = {
  /** The primary key(s) for `account` for the far side of the relationship. */
  connectById?: Maybe<AccountPkAccountConnect>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  connectByNodeId?: Maybe<AccountNodeIdConnect>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  deleteById?: Maybe<AccountPkAccountDelete>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AccountNodeIdDelete>;
  /** The primary key(s) and patch data for `account` for the far side of the relationship. */
  updateById?: Maybe<AccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkAccountUpdate>;
  /** The primary key(s) and patch data for `account` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdNodeIdUpdate>;
  /** A `AccountInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionImportBatchAccountAccountIdAccountCreateInput>;
};

/** The fields on `account` to look up the row to update. */
export type AccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkAccountUpdate = {
  /** An object where the defined keys will be set on the `account` being updated. */
  patch: UpdateAccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `account` being updated. */
export type UpdateAccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  institution?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  transactionsUsingId?: Maybe<FkTransactionAccountAccountIdInverseInput>;
  transactionImportBatchesUsingId?: Maybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `account` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `account` being updated. */
  patch: AccountPatch;
};

/** Represents an update to a `Account`. Fields that are set will be updated. */
export type AccountPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  institution?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  transactionsUsingId?: Maybe<FkTransactionAccountAccountIdInverseInput>;
  transactionImportBatchesUsingId?: Maybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
};

/** The `account` to be created by this mutation. */
export type FkTransactionImportBatchAccountAccountIdAccountCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  institution?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  transactionsUsingId?: Maybe<FkTransactionAccountAccountIdInverseInput>;
  transactionImportBatchesUsingId?: Maybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
};

/** Input for the nested mutation of `transaction` in the `TransactionImportBatchInput` mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput = {
  /** Flag indicating whether all other `transaction` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionPkTransactionConnect>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionNodeIdConnect>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionPkTransactionDelete>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionNodeIdDelete>>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionUpdate>>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdNodeIdUpdate>>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionCreateInput>>;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionUpdate = {
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** Input for the nested mutation of `transaction` in the `TransactionInput` mutation. */
export type FkTransactionTransactionReverseTransactionIdInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: Maybe<TransactionPkTransactionConnect>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectByNodeId?: Maybe<TransactionNodeIdConnect>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: Maybe<TransactionPkTransactionDelete>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TransactionNodeIdDelete>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: Maybe<TransactionOnTransactionForFkTransactionTransactionReverseTransactionIdUsingPkTransactionUpdate>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionOnTransactionForFkTransactionTransactionReverseTransactionIdNodeIdUpdate>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionTransactionReverseTransactionIdTransactionCreateInput>;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionTransactionReverseTransactionIdUsingPkTransactionUpdate = {
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionTransactionReverseTransactionIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionTransactionReverseTransactionIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** Input for the nested mutation of `transactionImportBatch` in the `TransactionInput` mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdInput = {
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  connectById?: Maybe<TransactionImportBatchPkTransactionImportBatchConnect>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  connectByNodeId?: Maybe<TransactionImportBatchNodeIdConnect>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  deleteById?: Maybe<TransactionImportBatchPkTransactionImportBatchDelete>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TransactionImportBatchNodeIdDelete>;
  /** The primary key(s) and patch data for `transactionImportBatch` for the far side of the relationship. */
  updateById?: Maybe<TransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionImportBatchUpdate>;
  /** The primary key(s) and patch data for `transactionImportBatch` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdNodeIdUpdate>;
  /** A `TransactionImportBatchInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionImportBatchCreateInput>;
};

/** The fields on `transactionImportBatch` to look up the row to update. */
export type TransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionImportBatchUpdate = {
  /** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
  patch: UpdateTransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
export type UpdateTransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  dateRangeMin?: Maybe<Scalars['Datetime']>;
  dateRangeMax?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionImportBatchAccountAccountIdInput>;
  transactionsUsingId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionImportBatch` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
  patch: TransactionImportBatchPatch;
};

/** Represents an update to a `TransactionImportBatch`. Fields that are set will be updated. */
export type TransactionImportBatchPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  dateRangeMin?: Maybe<Scalars['Datetime']>;
  dateRangeMax?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionImportBatchAccountAccountIdInput>;
  transactionsUsingId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** The `transactionImportBatch` to be created by this mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionImportBatchCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  dateRangeMin: Scalars['Datetime'];
  dateRangeMax: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionImportBatchAccountAccountIdInput>;
  transactionsUsingId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** Input for the nested mutation of `financeCategory` in the `TransactionInput` mutation. */
export type FkTransactionFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: Maybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<FinanceCategoryNodeIdConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: Maybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FinanceCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: Maybe<FinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdNodeIdUpdate>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
};

/** The fields on `financeCategory` to look up the row to connect. */
export type FinanceCategoryPkFinanceCategoryConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type FinanceCategoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `financeCategory` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `financeCategory` to look up the row to delete. */
export type FinanceCategoryPkFinanceCategoryDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FinanceCategoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `financeCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** Input for the nested mutation of `expense` in the `FinanceCategoryInput` mutation. */
export type FkExpenseFinanceCategoryCategoryIdInverseInput = {
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: Maybe<Array<ExpensePkExpenseConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ExpenseNodeIdConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: Maybe<Array<ExpensePkExpenseDelete>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ExpenseNodeIdDelete>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: Maybe<Array<ExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkExpenseUpdate>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdNodeIdUpdate>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkExpenseFinanceCategoryCategoryIdExpenseCreateInput>>;
};

/** The fields on `expense` to look up the row to connect. */
export type ExpensePkExpenseConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ExpenseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `expense` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `expense` to look up the row to delete. */
export type ExpensePkExpenseDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ExpenseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `expense` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkExpenseUpdate = {
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** Input for the nested mutation of `invoice` in the `ExpenseInput` mutation. */
export type FkExpenseInvoiceInvoiceIdInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: Maybe<InvoicePkInvoiceConnect>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<InvoiceNodeIdConnect>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: Maybe<InvoicePkInvoiceDelete>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<InvoiceNodeIdDelete>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: Maybe<InvoiceOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkInvoiceUpdate>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<ExpenseOnExpenseForFkExpenseInvoiceInvoiceIdNodeIdUpdate>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<FkExpenseInvoiceInvoiceIdInvoiceCreateInput>;
};

/** The fields on `invoice` to look up the row to connect. */
export type InvoicePkInvoiceConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type InvoiceNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `invoice` to look up the row to delete. */
export type InvoicePkInvoiceDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type InvoiceNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `invoice` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkInvoiceUpdate = {
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnExpenseForFkExpenseInvoiceInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnExpenseForFkExpenseInvoiceInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `quote` in the `InvoiceInput` mutation. */
export type FkInvoiceQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<InvoiceOnInvoiceForFkInvoiceQuoteQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkInvoiceQuoteQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to connect. */
export type QuotePkQuoteConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quote` to look up the row to delete. */
export type QuotePkQuoteDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quote` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnInvoiceForFkInvoiceQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnInvoiceForFkInvoiceQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `QuoteInput` mutation. */
export type FkQuoteTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnQuoteForFkQuoteTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteOnQuoteForFkQuoteTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to connect. */
export type TripPkTripConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TripNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `trip` to look up the row to delete. */
export type TripPkTripDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TripNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `trip` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `trip` to look up the row to update. */
export type TripOnQuoteForFkQuoteTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnQuoteForFkQuoteTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnQuoteForFkQuoteTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `customer` in the `TripInput` mutation. */
export type FkTripCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerPkCustomerConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerPkCustomerDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnTripForFkTripCustomerCustomerIdUsingPkCustomerUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripOnTripForFkTripCustomerCustomerIdNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripCustomerCustomerIdCustomerCreateInput>;
};

/** The fields on `customer` to look up the row to connect. */
export type CustomerPkCustomerConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `customer` to look up the row to delete. */
export type CustomerPkCustomerDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnTripForFkTripCustomerCustomerIdUsingPkCustomerUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnTripForFkTripCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnTripForFkTripCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** Input for the nested mutation of `customerTraveller` in the `CustomerInput` mutation. */
export type FkCustomerTravellerCustomerCustomerIdInverseInput = {
  /** Flag indicating whether all other `customerTraveller` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerTravellerPkCustomerTravellerConnect>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerTravellerNodeIdConnect>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerTravellerPkCustomerTravellerDelete>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerTravellerNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerTraveller` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerTravellerUpdate>>;
  /** The primary key(s) and patch data for `customerTraveller` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdNodeIdUpdate>>;
  /** A `CustomerTravellerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkCustomerTravellerCustomerCustomerIdCustomerTravellerCreateInput>>;
};

/** The fields on `customerTraveller` to look up the row to connect. */
export type CustomerTravellerPkCustomerTravellerConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CustomerTravellerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `customerTraveller` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `customerTraveller` to look up the row to delete. */
export type CustomerTravellerPkCustomerTravellerDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CustomerTravellerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `customerTraveller` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `customerTraveller` to look up the row to update. */
export type CustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerTravellerUpdate = {
  /** An object where the defined keys will be set on the `customerTraveller` being updated. */
  patch: UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `customerTraveller` being updated. */
export type UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkCustomerTravellerCustomerCustomerIdInput>;
  travellerToTravellerId?: Maybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** Input for the nested mutation of `customer` in the `CustomerTravellerInput` mutation. */
export type FkCustomerTravellerCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerPkCustomerConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerPkCustomerDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<FkCustomerTravellerCustomerCustomerIdCustomerCreateInput>;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `CustomerInput` mutation. */
export type FkTripCustomerCustomerIdInverseInput = {
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<Array<TripPkTripConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripNodeIdConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripPkTripDelete>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripNodeIdDelete>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<Array<TripOnTripForFkTripCustomerCustomerIdUsingPkTripUpdate>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnTripForFkTripCustomerCustomerIdNodeIdUpdate>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripCustomerCustomerIdTripCreateInput>>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripCustomerCustomerIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `user` in the `TripInput` mutation. */
export type FkTripUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserPkUserConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserPkUserDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnTripForFkTripUserUserIdUsingPkUserUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripOnTripForFkTripUserUserIdNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripUserUserIdUserCreateInput>;
};

/** The fields on `user` to look up the row to connect. */
export type UserPkUserConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type UserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `user` to look up the row to delete. */
export type UserPkUserDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `user` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnTripForFkTripUserUserIdUsingPkUserUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnTripForFkTripUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnTripForFkTripUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** Input for the nested mutation of `trip` in the `UserInput` mutation. */
export type FkTripUserUserIdInverseInput = {
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<Array<TripPkTripConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripNodeIdConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripPkTripDelete>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripNodeIdDelete>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<Array<TripOnTripForFkTripUserUserIdUsingPkTripUpdate>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnTripForFkTripUserUserIdNodeIdUpdate>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripUserUserIdTripCreateInput>>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripUserUserIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `TripInput` mutation. */
export type FkTripMediaGalleryMediaGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripOnTripForFkTripMediaGalleryMediaGalleryIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripMediaGalleryMediaGalleryIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to connect. */
export type MediaGalleryPkMediaGalleryConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type MediaGalleryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `mediaGallery` to look up the row to delete. */
export type MediaGalleryPkMediaGalleryDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type MediaGalleryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `MediaGalleryInput` mutation. */
export type FkMediaGalleryMediaGalleryParentIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<MediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkMediaGalleryMediaGalleryParentIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `MediaGalleryInput` mutation. */
export type FkTripMediaGalleryMediaGalleryIdInverseInput = {
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<Array<TripPkTripConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripNodeIdConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripPkTripDelete>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripNodeIdDelete>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<Array<TripOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkTripUpdate>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdNodeIdUpdate>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripMediaGalleryMediaGalleryIdTripCreateInput>>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripMediaGalleryMediaGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripMediaGalleryMediaGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `quote` in the `TripInput` mutation. */
export type FkTripQuoteActiveQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnTripForFkTripQuoteActiveQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripOnTripForFkTripQuoteActiveQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripQuoteActiveQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnTripForFkTripQuoteActiveQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnTripForFkTripQuoteActiveQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnTripForFkTripQuoteActiveQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `QuoteInput` mutation. */
export type FkQuoteMediaItemHeroImageIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: Maybe<MediaItemPkMediaItemConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaItemNodeIdConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: Maybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaItemNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: Maybe<MediaItemOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkMediaItemUpdate>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteOnQuoteForFkQuoteMediaItemHeroImageIdNodeIdUpdate>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteMediaItemHeroImageIdMediaItemCreateInput>;
};

/** The fields on `mediaItem` to look up the row to connect. */
export type MediaItemPkMediaItemConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type MediaItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `mediaItem` to look up the row to delete. */
export type MediaItemPkMediaItemDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type MediaItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkMediaItemUpdate = {
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnQuoteForFkQuoteMediaItemHeroImageIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnQuoteForFkQuoteMediaItemHeroImageIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** Input for the nested mutation of `agency` in the `MediaItemInput` mutation. */
export type FkAgencyMediaItemLogoIdInverseInput = {
  /** Flag indicating whether all other `agency` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectById?: Maybe<Array<AgencyPkAgencyConnect>>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<AgencyNodeIdConnect>>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteById?: Maybe<Array<AgencyPkAgencyDelete>>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<AgencyNodeIdDelete>>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateById?: Maybe<Array<AgencyOnAgencyForFkAgencyMediaItemLogoIdUsingPkAgencyUpdate>>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaItemOnAgencyForFkAgencyMediaItemLogoIdNodeIdUpdate>>;
  /** A `AgencyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkAgencyMediaItemLogoIdAgencyCreateInput>>;
};

/** The fields on `agency` to look up the row to connect. */
export type AgencyPkAgencyConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type AgencyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `agency` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `agency` to look up the row to delete. */
export type AgencyPkAgencyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type AgencyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `agency` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `agency` to look up the row to update. */
export type AgencyOnAgencyForFkAgencyMediaItemLogoIdUsingPkAgencyUpdate = {
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: UpdateAgencyOnAgencyForFkAgencyMediaItemLogoIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `agency` being updated. */
export type UpdateAgencyOnAgencyForFkAgencyMediaItemLogoIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `AgencyInput` mutation. */
export type FkAgencyMediaItemLogoIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: Maybe<MediaItemPkMediaItemConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaItemNodeIdConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: Maybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaItemNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: Maybe<MediaItemOnAgencyForFkAgencyMediaItemLogoIdUsingPkMediaItemUpdate>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<AgencyOnAgencyForFkAgencyMediaItemLogoIdNodeIdUpdate>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: Maybe<FkAgencyMediaItemLogoIdMediaItemCreateInput>;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnAgencyForFkAgencyMediaItemLogoIdUsingPkMediaItemUpdate = {
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnAgencyForFkAgencyMediaItemLogoIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnAgencyForFkAgencyMediaItemLogoIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `MediaItemInput` mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdInverseInput = {
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SupplierInvoiceNodeIdConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SupplierInvoiceNodeIdDelete>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: Maybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkSupplierInvoiceUpdate>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdNodeIdUpdate>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkSupplierInvoiceMediaItemMediaItemIdSupplierInvoiceCreateInput>>;
};

/** The fields on `supplierInvoice` to look up the row to connect. */
export type SupplierInvoicePkSupplierInvoiceConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type SupplierInvoiceNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `supplierInvoice` to look up the row to delete. */
export type SupplierInvoicePkSupplierInvoiceDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type SupplierInvoiceNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkSupplierInvoiceUpdate = {
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `financeCategory` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: Maybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<FinanceCategoryNodeIdConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: Maybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FinanceCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: Maybe<FinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdNodeIdUpdate>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** Input for the nested mutation of `invoice` in the `FinanceCategoryInput` mutation. */
export type FkInvoiceFinanceCategoryCategoryIdInverseInput = {
  /** Flag indicating whether all other `invoice` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: Maybe<Array<InvoicePkInvoiceConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<InvoiceNodeIdConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: Maybe<Array<InvoicePkInvoiceDelete>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<InvoiceNodeIdDelete>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: Maybe<Array<InvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkInvoiceUpdate>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdNodeIdUpdate>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkInvoiceFinanceCategoryCategoryIdInvoiceCreateInput>>;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkInvoiceUpdate = {
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `financeCategory` in the `InvoiceInput` mutation. */
export type FkInvoiceFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: Maybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<FinanceCategoryNodeIdConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: Maybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FinanceCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: Maybe<FinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<InvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdNodeIdUpdate>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<FkInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** Input for the nested mutation of `payment` in the `FinanceCategoryInput` mutation. */
export type FkPaymentFinanceCategoryCategoryIdInverseInput = {
  /** Flag indicating whether all other `payment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: Maybe<Array<PaymentPkPaymentConnect>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PaymentNodeIdConnect>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: Maybe<Array<PaymentPkPaymentDelete>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PaymentNodeIdDelete>>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: Maybe<Array<PaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkPaymentUpdate>>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdNodeIdUpdate>>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPaymentFinanceCategoryCategoryIdPaymentCreateInput>>;
};

/** The fields on `payment` to look up the row to connect. */
export type PaymentPkPaymentConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PaymentNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `payment` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `payment` to look up the row to delete. */
export type PaymentPkPaymentDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PaymentNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `payment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkPaymentUpdate = {
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** Input for the nested mutation of `invoice` in the `PaymentInput` mutation. */
export type FkPaymentInvoiceInvoiceIdInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: Maybe<InvoicePkInvoiceConnect>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<InvoiceNodeIdConnect>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: Maybe<InvoicePkInvoiceDelete>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<InvoiceNodeIdDelete>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: Maybe<InvoiceOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkInvoiceUpdate>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<PaymentOnPaymentForFkPaymentInvoiceInvoiceIdNodeIdUpdate>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<FkPaymentInvoiceInvoiceIdInvoiceCreateInput>;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkInvoiceUpdate = {
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnPaymentForFkPaymentInvoiceInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnPaymentForFkPaymentInvoiceInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `InvoiceInput` mutation. */
export type FkInvoiceTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnInvoiceForFkInvoiceTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<InvoiceOnInvoiceForFkInvoiceTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkInvoiceTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnInvoiceForFkInvoiceTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnInvoiceForFkInvoiceTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnInvoiceForFkInvoiceTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `agency` in the `TripInput` mutation. */
export type FkTripAgencyAgencyIdInput = {
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectById?: Maybe<AgencyPkAgencyConnect>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectByNodeId?: Maybe<AgencyNodeIdConnect>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteById?: Maybe<AgencyPkAgencyDelete>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AgencyNodeIdDelete>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateById?: Maybe<AgencyOnTripForFkTripAgencyAgencyIdUsingPkAgencyUpdate>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripOnTripForFkTripAgencyAgencyIdNodeIdUpdate>;
  /** A `AgencyInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripAgencyAgencyIdAgencyCreateInput>;
};

/** The fields on `agency` to look up the row to update. */
export type AgencyOnTripForFkTripAgencyAgencyIdUsingPkAgencyUpdate = {
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: UpdateAgencyOnTripForFkTripAgencyAgencyIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `agency` being updated. */
export type UpdateAgencyOnTripForFkTripAgencyAgencyIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  logoId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** Input for the nested mutation of `agencyMember` in the `AgencyInput` mutation. */
export type FkAgencyMemberAgencyAgencyIdInverseInput = {
  /** Flag indicating whether all other `agencyMember` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  connectById?: Maybe<Array<AgencyMemberPkAgencyMemberConnect>>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<AgencyMemberNodeIdConnect>>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  deleteById?: Maybe<Array<AgencyMemberPkAgencyMemberDelete>>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<AgencyMemberNodeIdDelete>>;
  /** The primary key(s) and patch data for `agencyMember` for the far side of the relationship. */
  updateById?: Maybe<Array<AgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyMemberUpdate>>;
  /** The primary key(s) and patch data for `agencyMember` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdNodeIdUpdate>>;
  /** A `AgencyMemberInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkAgencyMemberAgencyAgencyIdAgencyMemberCreateInput>>;
};

/** The fields on `agencyMember` to look up the row to connect. */
export type AgencyMemberPkAgencyMemberConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type AgencyMemberNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `agencyMember` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `agencyMember` to look up the row to delete. */
export type AgencyMemberPkAgencyMemberDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type AgencyMemberNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `agencyMember` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `agencyMember` to look up the row to update. */
export type AgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyMemberUpdate = {
  /** An object where the defined keys will be set on the `agencyMember` being updated. */
  patch: UpdateAgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `agencyMember` being updated. */
export type UpdateAgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  genderPreposition?: Maybe<Scalars['String']>;
  agencyToAgencyId?: Maybe<FkAgencyMemberAgencyAgencyIdInput>;
  tripsUsingId?: Maybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** Input for the nested mutation of `agency` in the `AgencyMemberInput` mutation. */
export type FkAgencyMemberAgencyAgencyIdInput = {
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectById?: Maybe<AgencyPkAgencyConnect>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectByNodeId?: Maybe<AgencyNodeIdConnect>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteById?: Maybe<AgencyPkAgencyDelete>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AgencyNodeIdDelete>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateById?: Maybe<AgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyUpdate>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateByNodeId?: Maybe<AgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdNodeIdUpdate>;
  /** A `AgencyInput` object that will be created and connected to this object. */
  create?: Maybe<FkAgencyMemberAgencyAgencyIdAgencyCreateInput>;
};

/** The fields on `agency` to look up the row to update. */
export type AgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyUpdate = {
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: UpdateAgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `agency` being updated. */
export type UpdateAgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  logoId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `AgencyInput` mutation. */
export type FkTripAgencyAgencyIdInverseInput = {
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<Array<TripPkTripConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripNodeIdConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripPkTripDelete>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripNodeIdDelete>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<Array<TripOnTripForFkTripAgencyAgencyIdUsingPkTripUpdate>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AgencyOnTripForFkTripAgencyAgencyIdNodeIdUpdate>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripAgencyAgencyIdTripCreateInput>>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripAgencyAgencyIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripAgencyAgencyIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripAgencyAgencyIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `agencyMember` in the `TripInput` mutation. */
export type FkTripAgencyMemberAgencyMemberIdInput = {
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  connectById?: Maybe<AgencyMemberPkAgencyMemberConnect>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  connectByNodeId?: Maybe<AgencyMemberNodeIdConnect>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  deleteById?: Maybe<AgencyMemberPkAgencyMemberDelete>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AgencyMemberNodeIdDelete>;
  /** The primary key(s) and patch data for `agencyMember` for the far side of the relationship. */
  updateById?: Maybe<AgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkAgencyMemberUpdate>;
  /** The primary key(s) and patch data for `agencyMember` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripOnTripForFkTripAgencyMemberAgencyMemberIdNodeIdUpdate>;
  /** A `AgencyMemberInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripAgencyMemberAgencyMemberIdAgencyMemberCreateInput>;
};

/** The fields on `agencyMember` to look up the row to update. */
export type AgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkAgencyMemberUpdate = {
  /** An object where the defined keys will be set on the `agencyMember` being updated. */
  patch: UpdateAgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `agencyMember` being updated. */
export type UpdateAgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  genderPreposition?: Maybe<Scalars['String']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyToAgencyId?: Maybe<FkAgencyMemberAgencyAgencyIdInput>;
  tripsUsingId?: Maybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `AgencyMemberInput` mutation. */
export type FkTripAgencyMemberAgencyMemberIdInverseInput = {
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<Array<TripPkTripConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripNodeIdConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripPkTripDelete>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripNodeIdDelete>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<Array<TripOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkTripUpdate>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdNodeIdUpdate>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripAgencyMemberAgencyMemberIdTripCreateInput>>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripAgencyMemberAgencyMemberIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripAgencyMemberAgencyMemberIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `expense` in the `TripInput` mutation. */
export type FkExpenseTripTripIdInverseInput = {
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: Maybe<Array<ExpensePkExpenseConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ExpenseNodeIdConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: Maybe<Array<ExpensePkExpenseDelete>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ExpenseNodeIdDelete>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: Maybe<Array<ExpenseOnExpenseForFkExpenseTripTripIdUsingPkExpenseUpdate>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnExpenseForFkExpenseTripTripIdNodeIdUpdate>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkExpenseTripTripIdExpenseCreateInput>>;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseTripTripIdUsingPkExpenseUpdate = {
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** Input for the nested mutation of `supplier` in the `ExpenseInput` mutation. */
export type FkExpenseSupplierSupplierIdInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: Maybe<SupplierPkSupplierConnect>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectByNodeId?: Maybe<SupplierNodeIdConnect>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: Maybe<SupplierPkSupplierDelete>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteByNodeId?: Maybe<SupplierNodeIdDelete>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: Maybe<SupplierOnExpenseForFkExpenseSupplierSupplierIdUsingPkSupplierUpdate>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateByNodeId?: Maybe<ExpenseOnExpenseForFkExpenseSupplierSupplierIdNodeIdUpdate>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: Maybe<FkExpenseSupplierSupplierIdSupplierCreateInput>;
};

/** The fields on `supplier` to look up the row to connect. */
export type SupplierPkSupplierConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type SupplierNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `supplier` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `supplier` to look up the row to delete. */
export type SupplierPkSupplierDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type SupplierNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `supplier` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnExpenseForFkExpenseSupplierSupplierIdUsingPkSupplierUpdate = {
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnExpenseForFkExpenseSupplierSupplierIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnExpenseForFkExpenseSupplierSupplierIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `SupplierInput` mutation. */
export type FkSupplierMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<SupplierOnSupplierForFkSupplierMediaGalleryGalleryIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkSupplierMediaGalleryGalleryIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `destination` in the `MediaGalleryInput` mutation. */
export type FkDestinationMediaGalleryGalleryIdInverseInput = {
  /** Flag indicating whether all other `destination` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: Maybe<Array<DestinationPkDestinationConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<DestinationNodeIdConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: Maybe<Array<DestinationPkDestinationDelete>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<DestinationNodeIdDelete>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: Maybe<Array<DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkDestinationUpdate>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdNodeIdUpdate>>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkDestinationMediaGalleryGalleryIdDestinationCreateInput>>;
};

/** The fields on `destination` to look up the row to connect. */
export type DestinationPkDestinationConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type DestinationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `destination` to look up the row to delete. */
export type DestinationPkDestinationDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DestinationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `destination` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkDestinationUpdate = {
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForFkDestinationMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `DestinationInput` mutation. */
export type FkDestinationMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkDestinationMediaGalleryGalleryIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `destinationFeature` in the `MediaGalleryInput` mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdInverseInput = {
  /** Flag indicating whether all other `destinationFeature` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  connectById?: Maybe<Array<DestinationFeaturePkDestinationFeatureConnect>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<DestinationFeatureNodeIdConnect>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  deleteById?: Maybe<Array<DestinationFeaturePkDestinationFeatureDelete>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<DestinationFeatureNodeIdDelete>>;
  /** The primary key(s) and patch data for `destinationFeature` for the far side of the relationship. */
  updateById?: Maybe<Array<DestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkDestinationFeatureUpdate>>;
  /** The primary key(s) and patch data for `destinationFeature` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdNodeIdUpdate>>;
  /** A `DestinationFeatureInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkDestinationFeatureMediaGalleryGalleryIdDestinationFeatureCreateInput>>;
};

/** The fields on `destinationFeature` to look up the row to connect. */
export type DestinationFeaturePkDestinationFeatureConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type DestinationFeatureNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `destinationFeature` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `destinationFeature` to look up the row to delete. */
export type DestinationFeaturePkDestinationFeatureDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DestinationFeatureNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `destinationFeature` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `destinationFeature` to look up the row to update. */
export type DestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkDestinationFeatureUpdate = {
  /** An object where the defined keys will be set on the `destinationFeature` being updated. */
  patch: UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destinationFeature` being updated. */
export type UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  destinationId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationFeatureDestinationDestinationIdInput>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
};

/** Input for the nested mutation of `destination` in the `DestinationFeatureInput` mutation. */
export type FkDestinationFeatureDestinationDestinationIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: Maybe<DestinationPkDestinationConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByNodeId?: Maybe<DestinationNodeIdConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: Maybe<DestinationPkDestinationDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<DestinationNodeIdDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: Maybe<DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByNodeId?: Maybe<DestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdNodeIdUpdate>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: Maybe<FkDestinationFeatureDestinationDestinationIdDestinationCreateInput>;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationUpdate = {
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `destination` in the `DestinationInput` mutation. */
export type FkDestinationDestinationParentIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: Maybe<DestinationPkDestinationConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByNodeId?: Maybe<DestinationNodeIdConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: Maybe<DestinationPkDestinationDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<DestinationNodeIdDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: Maybe<DestinationOnDestinationForFkDestinationDestinationParentIdUsingPkDestinationUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByNodeId?: Maybe<DestinationOnDestinationForFkDestinationDestinationParentIdNodeIdUpdate>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: Maybe<FkDestinationDestinationParentIdDestinationCreateInput>;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationDestinationParentIdUsingPkDestinationUpdate = {
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationDestinationParentIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForFkDestinationDestinationParentIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `country` in the `DestinationInput` mutation. */
export type FkDestinationCountryCountryIdInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryPkCountryConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryPkCountryDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnDestinationForFkDestinationCountryCountryIdUsingPkCountryUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<DestinationOnDestinationForFkDestinationCountryCountryIdNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<FkDestinationCountryCountryIdCountryCreateInput>;
};

/** The fields on `country` to look up the row to connect. */
export type CountryPkCountryConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type CountryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `country` to look up the row to delete. */
export type CountryPkCountryDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CountryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `country` to look up the row to update. */
export type CountryOnDestinationForFkDestinationCountryCountryIdUsingPkCountryUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnDestinationForFkDestinationCountryCountryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnDestinationForFkDestinationCountryCountryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** Input for the nested mutation of `airport` in the `CountryInput` mutation. */
export type FkAirportCountryCountryIdInverseInput = {
  /** Flag indicating whether all other `airport` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectById?: Maybe<Array<AirportPkAirportConnect>>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<AirportNodeIdConnect>>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteById?: Maybe<Array<AirportPkAirportDelete>>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<AirportNodeIdDelete>>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateById?: Maybe<Array<AirportOnAirportForFkAirportCountryCountryIdUsingPkAirportUpdate>>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnAirportForFkAirportCountryCountryIdNodeIdUpdate>>;
  /** A `AirportInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkAirportCountryCountryIdAirportCreateInput>>;
};

/** The fields on `airport` to look up the row to connect. */
export type AirportPkAirportConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type AirportNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `airport` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `airport` to look up the row to delete. */
export type AirportPkAirportDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type AirportNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `airport` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `airport` to look up the row to update. */
export type AirportOnAirportForFkAirportCountryCountryIdUsingPkAirportUpdate = {
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: UpdateAirportOnAirportForFkAirportCountryCountryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `airport` being updated. */
export type UpdateAirportOnAirportForFkAirportCountryCountryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** Input for the nested mutation of `country` in the `AirportInput` mutation. */
export type FkAirportCountryCountryIdInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryPkCountryConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryPkCountryDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnAirportForFkAirportCountryCountryIdUsingPkCountryUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<AirportOnAirportForFkAirportCountryCountryIdNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<FkAirportCountryCountryIdCountryCreateInput>;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnAirportForFkAirportCountryCountryIdUsingPkCountryUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnAirportForFkAirportCountryCountryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnAirportForFkAirportCountryCountryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** Input for the nested mutation of `destination` in the `CountryInput` mutation. */
export type FkDestinationCountryCountryIdInverseInput = {
  /** Flag indicating whether all other `destination` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: Maybe<Array<DestinationPkDestinationConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<DestinationNodeIdConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: Maybe<Array<DestinationPkDestinationDelete>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<DestinationNodeIdDelete>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: Maybe<Array<DestinationOnDestinationForFkDestinationCountryCountryIdUsingPkDestinationUpdate>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnDestinationForFkDestinationCountryCountryIdNodeIdUpdate>>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkDestinationCountryCountryIdDestinationCreateInput>>;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationCountryCountryIdUsingPkDestinationUpdate = {
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationCountryCountryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForFkDestinationCountryCountryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `DestinationInput` mutation. */
export type DestinationHeroMediaIdFkeyInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: Maybe<MediaItemPkMediaItemConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaItemNodeIdConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: Maybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaItemNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: Maybe<MediaItemOnDestinationForDestinationHeroMediaIdFkeyUsingPkMediaItemUpdate>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<DestinationOnDestinationForDestinationHeroMediaIdFkeyNodeIdUpdate>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: Maybe<DestinationHeroMediaIdFkeyMediaItemCreateInput>;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnDestinationForDestinationHeroMediaIdFkeyUsingPkMediaItemUpdate = {
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnDestinationForDestinationHeroMediaIdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnDestinationForDestinationHeroMediaIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** Input for the nested mutation of `destination` in the `MediaItemInput` mutation. */
export type DestinationHeroMediaIdFkeyInverseInput = {
  /** Flag indicating whether all other `destination` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: Maybe<Array<DestinationPkDestinationConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<DestinationNodeIdConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: Maybe<Array<DestinationPkDestinationDelete>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<DestinationNodeIdDelete>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: Maybe<Array<DestinationOnDestinationForDestinationHeroMediaIdFkeyUsingPkDestinationUpdate>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaItemOnDestinationForDestinationHeroMediaIdFkeyNodeIdUpdate>>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<DestinationHeroMediaIdFkeyDestinationCreateInput>>;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForDestinationHeroMediaIdFkeyUsingPkDestinationUpdate = {
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForDestinationHeroMediaIdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForDestinationHeroMediaIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `destinationFeature` in the `DestinationInput` mutation. */
export type FkDestinationFeatureDestinationDestinationIdInverseInput = {
  /** Flag indicating whether all other `destinationFeature` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  connectById?: Maybe<Array<DestinationFeaturePkDestinationFeatureConnect>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<DestinationFeatureNodeIdConnect>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  deleteById?: Maybe<Array<DestinationFeaturePkDestinationFeatureDelete>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<DestinationFeatureNodeIdDelete>>;
  /** The primary key(s) and patch data for `destinationFeature` for the far side of the relationship. */
  updateById?: Maybe<Array<DestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationFeatureUpdate>>;
  /** The primary key(s) and patch data for `destinationFeature` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdNodeIdUpdate>>;
  /** A `DestinationFeatureInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkDestinationFeatureDestinationDestinationIdDestinationFeatureCreateInput>>;
};

/** The fields on `destinationFeature` to look up the row to update. */
export type DestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationFeatureUpdate = {
  /** An object where the defined keys will be set on the `destinationFeature` being updated. */
  patch: UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destinationFeature` being updated. */
export type UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  galleryId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationFeatureDestinationDestinationIdInput>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `DestinationFeatureInput` mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<DestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `feature` in the `MediaGalleryInput` mutation. */
export type FkFeatureMediaGalleryGalleryIdInverseInput = {
  /** Flag indicating whether all other `feature` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `feature` for the far side of the relationship. */
  connectById?: Maybe<Array<FeaturePkFeatureConnect>>;
  /** The primary key(s) for `feature` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<FeatureNodeIdConnect>>;
  /** The primary key(s) for `feature` for the far side of the relationship. */
  deleteById?: Maybe<Array<FeaturePkFeatureDelete>>;
  /** The primary key(s) for `feature` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<FeatureNodeIdDelete>>;
  /** The primary key(s) and patch data for `feature` for the far side of the relationship. */
  updateById?: Maybe<Array<FeatureOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkFeatureUpdate>>;
  /** The primary key(s) and patch data for `feature` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdNodeIdUpdate>>;
  /** A `FeatureInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkFeatureMediaGalleryGalleryIdFeatureCreateInput>>;
};

/** The fields on `feature` to look up the row to connect. */
export type FeaturePkFeatureConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type FeatureNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `feature` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `feature` to look up the row to delete. */
export type FeaturePkFeatureDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FeatureNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `feature` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `feature` to look up the row to update. */
export type FeatureOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkFeatureUpdate = {
  /** An object where the defined keys will be set on the `feature` being updated. */
  patch: UpdateFeatureOnFeatureForFkFeatureMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `feature` being updated. */
export type UpdateFeatureOnFeatureForFkFeatureMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkFeatureMediaGalleryGalleryIdInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `FeatureInput` mutation. */
export type FkFeatureMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<FeatureOnFeatureForFkFeatureMediaGalleryGalleryIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkFeatureMediaGalleryGalleryIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `mediaGalleryItem` in the `MediaGalleryInput` mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput = {
  /** Flag indicating whether all other `mediaGalleryItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  connectById?: Maybe<Array<MediaGalleryItemPkMediaGalleryItemConnect>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<MediaGalleryItemNodeIdConnect>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<MediaGalleryItemPkMediaGalleryItemDelete>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<MediaGalleryItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `mediaGalleryItem` for the far side of the relationship. */
  updateById?: Maybe<Array<MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryItemUpdate>>;
  /** The primary key(s) and patch data for `mediaGalleryItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdNodeIdUpdate>>;
  /** A `MediaGalleryItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryItemCreateInput>>;
};

/** The fields on `mediaGalleryItem` to look up the row to connect. */
export type MediaGalleryItemPkMediaGalleryItemConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type MediaGalleryItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `mediaGalleryItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `mediaGalleryItem` to look up the row to delete. */
export type MediaGalleryItemPkMediaGalleryItemDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type MediaGalleryItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `mediaGalleryItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `mediaGalleryItem` to look up the row to update. */
export type MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryItemUpdate = {
  /** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
  patch: UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
export type UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  isHero?: Maybe<Scalars['Boolean']>;
  mediaGalleryToMediaGalleryId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `MediaGalleryItemInput` mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `property` in the `MediaGalleryInput` mutation. */
export type FkPropertyMediaGalleryGalleryIdInverseInput = {
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: Maybe<Array<PropertyPkPropertyConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PropertyNodeIdConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: Maybe<Array<PropertyPkPropertyDelete>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PropertyNodeIdDelete>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: Maybe<Array<PropertyOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkPropertyUpdate>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdNodeIdUpdate>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPropertyMediaGalleryGalleryIdPropertyCreateInput>>;
};

/** The fields on `property` to look up the row to connect. */
export type PropertyPkPropertyConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PropertyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `property` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `property` to look up the row to delete. */
export type PropertyPkPropertyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PropertyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `property` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkPropertyUpdate = {
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `PropertyInput` mutation. */
export type FkPropertyMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: Maybe<MediaGalleryPkMediaGalleryConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaGalleryNodeIdConnect>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: Maybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaGalleryNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: Maybe<MediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateByNodeId?: Maybe<PropertyOnPropertyForFkPropertyMediaGalleryGalleryIdNodeIdUpdate>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: Maybe<FkPropertyMediaGalleryGalleryIdMediaGalleryCreateInput>;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** Input for the nested mutation of `supplier` in the `MediaGalleryInput` mutation. */
export type FkSupplierMediaGalleryGalleryIdInverseInput = {
  /** Flag indicating whether all other `supplier` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: Maybe<Array<SupplierPkSupplierConnect>>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SupplierNodeIdConnect>>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: Maybe<Array<SupplierPkSupplierDelete>>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SupplierNodeIdDelete>>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: Maybe<Array<SupplierOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkSupplierUpdate>>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdNodeIdUpdate>>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkSupplierMediaGalleryGalleryIdSupplierCreateInput>>;
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkSupplierUpdate = {
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnSupplierForFkSupplierMediaGalleryGalleryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnSupplierForFkSupplierMediaGalleryGalleryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** Input for the nested mutation of `expense` in the `SupplierInput` mutation. */
export type FkExpenseSupplierSupplierIdInverseInput = {
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: Maybe<Array<ExpensePkExpenseConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ExpenseNodeIdConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: Maybe<Array<ExpensePkExpenseDelete>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ExpenseNodeIdDelete>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: Maybe<Array<ExpenseOnExpenseForFkExpenseSupplierSupplierIdUsingPkExpenseUpdate>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<SupplierOnExpenseForFkExpenseSupplierSupplierIdNodeIdUpdate>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkExpenseSupplierSupplierIdExpenseCreateInput>>;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseSupplierSupplierIdUsingPkExpenseUpdate = {
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseSupplierSupplierIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseSupplierSupplierIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** Input for the nested mutation of `financeCategory` in the `ExpenseInput` mutation. */
export type FkExpenseFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: Maybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<FinanceCategoryNodeIdConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: Maybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FinanceCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: Maybe<FinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<ExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdNodeIdUpdate>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<FkExpenseFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `FinanceCategoryInput` mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput = {
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SupplierInvoiceNodeIdConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SupplierInvoiceNodeIdDelete>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: Maybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkSupplierInvoiceUpdate>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdNodeIdUpdate>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkSupplierInvoiceFinanceCategoryCategoryIdSupplierInvoiceCreateInput>>;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkSupplierInvoiceUpdate = {
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `supplier` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceSupplierSupplierIdInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: Maybe<SupplierPkSupplierConnect>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectByNodeId?: Maybe<SupplierNodeIdConnect>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: Maybe<SupplierPkSupplierDelete>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteByNodeId?: Maybe<SupplierNodeIdDelete>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: Maybe<SupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierUpdate>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateByNodeId?: Maybe<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdNodeIdUpdate>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: Maybe<FkSupplierInvoiceSupplierSupplierIdSupplierCreateInput>;
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierUpdate = {
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `SupplierInput` mutation. */
export type FkSupplierInvoiceSupplierSupplierIdInverseInput = {
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SupplierInvoiceNodeIdConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SupplierInvoiceNodeIdDelete>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: Maybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierInvoiceUpdate>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<SupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdNodeIdUpdate>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkSupplierInvoiceSupplierSupplierIdSupplierInvoiceCreateInput>>;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierInvoiceUpdate = {
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkSupplierInvoiceTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `invoice` in the `TripInput` mutation. */
export type FkInvoiceTripTripIdInverseInput = {
  /** Flag indicating whether all other `invoice` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: Maybe<Array<InvoicePkInvoiceConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<InvoiceNodeIdConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: Maybe<Array<InvoicePkInvoiceDelete>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<InvoiceNodeIdDelete>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: Maybe<Array<InvoiceOnInvoiceForFkInvoiceTripTripIdUsingPkInvoiceUpdate>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnInvoiceForFkInvoiceTripTripIdNodeIdUpdate>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkInvoiceTripTripIdInvoiceCreateInput>>;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForFkInvoiceTripTripIdUsingPkInvoiceUpdate = {
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForFkInvoiceTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForFkInvoiceTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `expense` in the `InvoiceInput` mutation. */
export type FkExpenseInvoiceInvoiceIdInverseInput = {
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: Maybe<Array<ExpensePkExpenseConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ExpenseNodeIdConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: Maybe<Array<ExpensePkExpenseDelete>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ExpenseNodeIdDelete>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: Maybe<Array<ExpenseOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkExpenseUpdate>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<InvoiceOnExpenseForFkExpenseInvoiceInvoiceIdNodeIdUpdate>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkExpenseInvoiceInvoiceIdExpenseCreateInput>>;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkExpenseUpdate = {
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseInvoiceInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseInvoiceInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `ExpenseInput` mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: Maybe<SupplierInvoicePkSupplierInvoiceConnect>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<SupplierInvoiceNodeIdConnect>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: Maybe<SupplierInvoicePkSupplierInvoiceDelete>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<SupplierInvoiceNodeIdDelete>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: Maybe<SupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<ExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdNodeIdUpdate>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput>;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate = {
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: Maybe<MediaItemPkMediaItemConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaItemNodeIdConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: Maybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaItemNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: Maybe<MediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkMediaItemUpdate>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdNodeIdUpdate>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdMediaItemCreateInput>;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkMediaItemUpdate = {
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** Input for the nested mutation of `mediaGalleryItem` in the `MediaItemInput` mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdInverseInput = {
  /** Flag indicating whether all other `mediaGalleryItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  connectById?: Maybe<Array<MediaGalleryItemPkMediaGalleryItemConnect>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<MediaGalleryItemNodeIdConnect>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<MediaGalleryItemPkMediaGalleryItemDelete>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<MediaGalleryItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `mediaGalleryItem` for the far side of the relationship. */
  updateById?: Maybe<Array<MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaGalleryItemUpdate>>;
  /** The primary key(s) and patch data for `mediaGalleryItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdNodeIdUpdate>>;
  /** A `MediaGalleryItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkMediaGalleryItemMediaItemMediaItemIdMediaGalleryItemCreateInput>>;
};

/** The fields on `mediaGalleryItem` to look up the row to update. */
export type MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaGalleryItemUpdate = {
  /** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
  patch: UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
export type UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  isHero?: Maybe<Scalars['Boolean']>;
  mediaGalleryToMediaGalleryId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
};

/** Input for the nested mutation of `mediaItem` in the `MediaGalleryItemInput` mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: Maybe<MediaItemPkMediaItemConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaItemNodeIdConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: Maybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaItemNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: Maybe<MediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaItemUpdate>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdNodeIdUpdate>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdMediaItemCreateInput>;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaItemUpdate = {
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** Input for the nested mutation of `property` in the `MediaItemInput` mutation. */
export type FkPropertyMediaItemHeroMediaIdInverseInput = {
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: Maybe<Array<PropertyPkPropertyConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PropertyNodeIdConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: Maybe<Array<PropertyPkPropertyDelete>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PropertyNodeIdDelete>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: Maybe<Array<PropertyOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkPropertyUpdate>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdNodeIdUpdate>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPropertyMediaItemHeroMediaIdPropertyCreateInput>>;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkPropertyUpdate = {
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyMediaItemHeroMediaIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyMediaItemHeroMediaIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `PropertyInput` mutation. */
export type FkPropertyMediaItemHeroMediaIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: Maybe<MediaItemPkMediaItemConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaItemNodeIdConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: Maybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaItemNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: Maybe<MediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkMediaItemUpdate>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<PropertyOnPropertyForFkPropertyMediaItemHeroMediaIdNodeIdUpdate>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: Maybe<FkPropertyMediaItemHeroMediaIdMediaItemCreateInput>;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkMediaItemUpdate = {
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** Input for the nested mutation of `quote` in the `MediaItemInput` mutation. */
export type FkQuoteMediaItemHeroImageIdInverseInput = {
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteNodeIdConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaItemOnQuoteForFkQuoteMediaItemHeroImageIdNodeIdUpdate>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteMediaItemHeroImageIdQuoteCreateInput>>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteMediaItemHeroImageIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteMediaItemHeroImageIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `quoteHero` in the `QuoteInput` mutation. */
export type FkQuoteQuoteHeroHeroIdInput = {
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectById?: Maybe<QuoteHeroPkQuoteHeroConnect>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteHeroNodeIdConnect>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteById?: Maybe<QuoteHeroPkQuoteHeroDelete>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteHeroNodeIdDelete>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateById?: Maybe<QuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteHeroUpdate>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteOnQuoteForFkQuoteQuoteHeroHeroIdNodeIdUpdate>;
  /** A `QuoteHeroInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteQuoteHeroHeroIdQuoteHeroCreateInput>;
};

/** The fields on `quoteHero` to look up the row to connect. */
export type QuoteHeroPkQuoteHeroConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteHeroNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quoteHero` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteHero` to look up the row to delete. */
export type QuoteHeroPkQuoteHeroDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteHeroNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quoteHero` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteHero` to look up the row to update. */
export type QuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteHeroUpdate = {
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: UpdateQuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteHero` being updated. */
export type UpdateQuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  imageId?: Maybe<Scalars['UUID']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `QuoteHeroInput` mutation. */
export type FkQuoteHeroMediaItemImageIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: Maybe<MediaItemPkMediaItemConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<MediaItemNodeIdConnect>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: Maybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MediaItemNodeIdDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: Maybe<MediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkMediaItemUpdate>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdNodeIdUpdate>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteHeroMediaItemImageIdMediaItemCreateInput>;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkMediaItemUpdate = {
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** Input for the nested mutation of `quoteHero` in the `MediaItemInput` mutation. */
export type FkQuoteHeroMediaItemImageIdInverseInput = {
  /** Flag indicating whether all other `quoteHero` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteHeroPkQuoteHeroConnect>>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteHeroNodeIdConnect>>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteHeroPkQuoteHeroDelete>>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteHeroNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkQuoteHeroUpdate>>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdNodeIdUpdate>>;
  /** A `QuoteHeroInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteHeroMediaItemImageIdQuoteHeroCreateInput>>;
};

/** The fields on `quoteHero` to look up the row to update. */
export type QuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkQuoteHeroUpdate = {
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: UpdateQuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteHero` being updated. */
export type UpdateQuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteHeroInput` mutation. */
export type FkQuoteQuoteHeroHeroIdInverseInput = {
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteNodeIdConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdNodeIdUpdate>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteQuoteHeroHeroIdQuoteCreateInput>>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteQuoteHeroHeroIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteQuoteHeroHeroIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `user` in the `QuoteInput` mutation. */
export type FkQuoteUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserPkUserConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserPkUserDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnQuoteForFkQuoteUserUserIdUsingPkUserUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteOnQuoteForFkQuoteUserUserIdNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteUserUserIdUserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnQuoteForFkQuoteUserUserIdUsingPkUserUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnQuoteForFkQuoteUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnQuoteForFkQuoteUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** Input for the nested mutation of `email` in the `UserInput` mutation. */
export type FkEmailUserUserIdInverseInput = {
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: Maybe<Array<EmailPkEmailConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EmailNodeIdConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: Maybe<Array<EmailPkEmailDelete>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EmailNodeIdDelete>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: Maybe<Array<EmailOnEmailForFkEmailUserUserIdUsingPkEmailUpdate>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnEmailForFkEmailUserUserIdNodeIdUpdate>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkEmailUserUserIdEmailCreateInput>>;
};

/** The fields on `email` to look up the row to connect. */
export type EmailPkEmailConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type EmailNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `email` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `email` to look up the row to delete. */
export type EmailPkEmailDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type EmailNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `email` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailUserUserIdUsingPkEmailUpdate = {
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** Input for the nested mutation of `trip` in the `EmailInput` mutation. */
export type FkEmailTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnEmailForFkEmailTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<EmailOnEmailForFkEmailTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkEmailTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnEmailForFkEmailTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnEmailForFkEmailTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnEmailForFkEmailTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `payment` in the `TripInput` mutation. */
export type FkPaymentTripTripIdInverseInput = {
  /** Flag indicating whether all other `payment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: Maybe<Array<PaymentPkPaymentConnect>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PaymentNodeIdConnect>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: Maybe<Array<PaymentPkPaymentDelete>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PaymentNodeIdDelete>>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: Maybe<Array<PaymentOnPaymentForFkPaymentTripTripIdUsingPkPaymentUpdate>>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnPaymentForFkPaymentTripTripIdNodeIdUpdate>>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPaymentTripTripIdPaymentCreateInput>>;
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnPaymentForFkPaymentTripTripIdUsingPkPaymentUpdate = {
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnPaymentForFkPaymentTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnPaymentForFkPaymentTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** Input for the nested mutation of `financeCategory` in the `PaymentInput` mutation. */
export type FkPaymentFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: Maybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectByNodeId?: Maybe<FinanceCategoryNodeIdConnect>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: Maybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FinanceCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: Maybe<FinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateByNodeId?: Maybe<PaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdNodeIdUpdate>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: Maybe<FkPaymentFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** Input for the nested mutation of `transaction` in the `FinanceCategoryInput` mutation. */
export type FkTransactionFinanceCategoryCategoryIdInverseInput = {
  /** Flag indicating whether all other `transaction` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionPkTransactionConnect>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionNodeIdConnect>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionPkTransactionDelete>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionNodeIdDelete>>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkTransactionUpdate>>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdNodeIdUpdate>>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionFinanceCategoryCategoryIdTransactionCreateInput>>;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkTransactionUpdate = {
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** Input for the nested mutation of `transactionLink` in the `TransactionInput` mutation. */
export type FkTransactionLinkTransactionTransactionIdInverseInput = {
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionLinkNodeIdConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionLinkNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionLinkUpdate>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdNodeIdUpdate>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionLinkTransactionTransactionIdTransactionLinkCreateInput>>;
};

/** The fields on `transactionLink` to look up the row to connect. */
export type TransactionLinkPkTransactionLinkConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TransactionLinkNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `transactionLink` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `transactionLink` to look up the row to delete. */
export type TransactionLinkPkTransactionLinkDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TransactionLinkNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `transactionLink` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionLinkUpdate = {
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** Input for the nested mutation of `transaction` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkTransactionTransactionIdInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: Maybe<TransactionPkTransactionConnect>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectByNodeId?: Maybe<TransactionNodeIdConnect>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: Maybe<TransactionPkTransactionDelete>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TransactionNodeIdDelete>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: Maybe<TransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionUpdate>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdNodeIdUpdate>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionLinkTransactionTransactionIdTransactionCreateInput>;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionUpdate = {
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** Input for the nested mutation of `transactionNote` in the `TransactionInput` mutation. */
export type FkTransactionNoteTransactionTransactionIdInverseInput = {
  /** Flag indicating whether all other `transactionNote` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionNotePkTransactionNoteConnect>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionNoteNodeIdConnect>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionNotePkTransactionNoteDelete>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionNoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionNote` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionNoteUpdate>>;
  /** The primary key(s) and patch data for `transactionNote` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdNodeIdUpdate>>;
  /** A `TransactionNoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionNoteTransactionTransactionIdTransactionNoteCreateInput>>;
};

/** The fields on `transactionNote` to look up the row to connect. */
export type TransactionNotePkTransactionNoteConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TransactionNoteNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `transactionNote` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `transactionNote` to look up the row to delete. */
export type TransactionNotePkTransactionNoteDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TransactionNoteNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `transactionNote` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `transactionNote` to look up the row to update. */
export type TransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionNoteUpdate = {
  /** An object where the defined keys will be set on the `transactionNote` being updated. */
  patch: UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionNote` being updated. */
export type UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  message?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<FkTransactionNoteUserUserIdInput>;
  transactionToTransactionId?: Maybe<FkTransactionNoteTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `user` in the `TransactionNoteInput` mutation. */
export type FkTransactionNoteUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserPkUserConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserPkUserDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkUserUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionNoteUserUserIdUserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkUserUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnTransactionNoteForFkTransactionNoteUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnTransactionNoteForFkTransactionNoteUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** Input for the nested mutation of `note` in the `UserInput` mutation. */
export type FkNoteUserUserIdInverseInput = {
  /** Flag indicating whether all other `note` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  connectById?: Maybe<Array<NotePkNoteConnect>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<NoteNodeIdConnect>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  deleteById?: Maybe<Array<NotePkNoteDelete>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<NoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `note` for the far side of the relationship. */
  updateById?: Maybe<Array<NoteOnNoteForFkNoteUserUserIdUsingPkNoteUpdate>>;
  /** The primary key(s) and patch data for `note` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnNoteForFkNoteUserUserIdNodeIdUpdate>>;
  /** A `NoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkNoteUserUserIdNoteCreateInput>>;
};

/** The fields on `note` to look up the row to connect. */
export type NotePkNoteConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type NoteNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `note` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `note` to look up the row to delete. */
export type NotePkNoteDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type NoteNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `note` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `note` to look up the row to update. */
export type NoteOnNoteForFkNoteUserUserIdUsingPkNoteUpdate = {
  /** An object where the defined keys will be set on the `note` being updated. */
  patch: UpdateNoteOnNoteForFkNoteUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `note` being updated. */
export type UpdateNoteOnNoteForFkNoteUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  tripToTripId?: Maybe<FkNoteTripTripIdInput>;
  userToUserId?: Maybe<FkNoteUserUserIdInput>;
};

/** Input for the nested mutation of `trip` in the `NoteInput` mutation. */
export type FkNoteTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnNoteForFkNoteTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<NoteOnNoteForFkNoteTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkNoteTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnNoteForFkNoteTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnNoteForFkNoteTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnNoteForFkNoteTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `TripInput` mutation. */
export type FkSupplierInvoiceTripTripIdInverseInput = {
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SupplierInvoiceNodeIdConnect>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: Maybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SupplierInvoiceNodeIdDelete>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: Maybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkSupplierInvoiceUpdate>>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdNodeIdUpdate>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkSupplierInvoiceTripTripIdSupplierInvoiceCreateInput>>;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkSupplierInvoiceUpdate = {
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `expense` in the `SupplierInvoiceInput` mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput = {
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: Maybe<Array<ExpensePkExpenseConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ExpenseNodeIdConnect>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: Maybe<Array<ExpensePkExpenseDelete>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ExpenseNodeIdDelete>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: Maybe<Array<ExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkExpenseUpdate>>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<SupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdNodeIdUpdate>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkExpenseSupplierInvoiceSupplierInvoiceIdExpenseCreateInput>>;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkExpenseUpdate = {
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `ExpenseInput` mutation. */
export type FkExpenseTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnExpenseForFkExpenseTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<ExpenseOnExpenseForFkExpenseTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkExpenseTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnExpenseForFkExpenseTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnExpenseForFkExpenseTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnExpenseForFkExpenseTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `email` in the `TripInput` mutation. */
export type FkEmailTripTripIdInverseInput = {
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: Maybe<Array<EmailPkEmailConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EmailNodeIdConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: Maybe<Array<EmailPkEmailDelete>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EmailNodeIdDelete>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: Maybe<Array<EmailOnEmailForFkEmailTripTripIdUsingPkEmailUpdate>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnEmailForFkEmailTripTripIdNodeIdUpdate>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkEmailTripTripIdEmailCreateInput>>;
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailTripTripIdUsingPkEmailUpdate = {
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** Input for the nested mutation of `user` in the `EmailInput` mutation. */
export type FkEmailUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserPkUserConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserPkUserDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnEmailForFkEmailUserUserIdUsingPkUserUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<EmailOnEmailForFkEmailUserUserIdNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FkEmailUserUserIdUserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnEmailForFkEmailUserUserIdUsingPkUserUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnEmailForFkEmailUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnEmailForFkEmailUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** Input for the nested mutation of `quote` in the `UserInput` mutation. */
export type FkQuoteUserUserIdInverseInput = {
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteNodeIdConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteOnQuoteForFkQuoteUserUserIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnQuoteForFkQuoteUserUserIdNodeIdUpdate>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteUserUserIdQuoteCreateInput>>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteUserUserIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `invoice` in the `QuoteInput` mutation. */
export type FkInvoiceQuoteQuoteIdInverseInput = {
  /** Flag indicating whether all other `invoice` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: Maybe<Array<InvoicePkInvoiceConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<InvoiceNodeIdConnect>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: Maybe<Array<InvoicePkInvoiceDelete>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<InvoiceNodeIdDelete>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: Maybe<Array<InvoiceOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkInvoiceUpdate>>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnInvoiceForFkInvoiceQuoteQuoteIdNodeIdUpdate>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkInvoiceQuoteQuoteIdInvoiceCreateInput>>;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkInvoiceUpdate = {
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForFkInvoiceQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForFkInvoiceQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `payment` in the `InvoiceInput` mutation. */
export type FkPaymentInvoiceInvoiceIdInverseInput = {
  /** Flag indicating whether all other `payment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: Maybe<Array<PaymentPkPaymentConnect>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PaymentNodeIdConnect>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: Maybe<Array<PaymentPkPaymentDelete>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PaymentNodeIdDelete>>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: Maybe<Array<PaymentOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkPaymentUpdate>>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<InvoiceOnPaymentForFkPaymentInvoiceInvoiceIdNodeIdUpdate>>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPaymentInvoiceInvoiceIdPaymentCreateInput>>;
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkPaymentUpdate = {
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnPaymentForFkPaymentInvoiceInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnPaymentForFkPaymentInvoiceInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `PaymentInput` mutation. */
export type FkPaymentTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnPaymentForFkPaymentTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<PaymentOnPaymentForFkPaymentTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkPaymentTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnPaymentForFkPaymentTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnPaymentForFkPaymentTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnPaymentForFkPaymentTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `enquiry` in the `TripInput` mutation. */
export type FkEnquiryTripTripIdInverseInput = {
  /** Flag indicating whether all other `enquiry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  connectById?: Maybe<Array<EnquiryPkEnquiryConnect>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EnquiryNodeIdConnect>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  deleteById?: Maybe<Array<EnquiryPkEnquiryDelete>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EnquiryNodeIdDelete>>;
  /** The primary key(s) and patch data for `enquiry` for the far side of the relationship. */
  updateById?: Maybe<Array<EnquiryOnEnquiryForFkEnquiryTripTripIdUsingPkEnquiryUpdate>>;
  /** The primary key(s) and patch data for `enquiry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnEnquiryForFkEnquiryTripTripIdNodeIdUpdate>>;
  /** A `EnquiryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkEnquiryTripTripIdEnquiryCreateInput>>;
};

/** The fields on `enquiry` to look up the row to connect. */
export type EnquiryPkEnquiryConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type EnquiryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `enquiry` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `enquiry` to look up the row to delete. */
export type EnquiryPkEnquiryDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type EnquiryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `enquiry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `enquiry` to look up the row to update. */
export type EnquiryOnEnquiryForFkEnquiryTripTripIdUsingPkEnquiryUpdate = {
  /** An object where the defined keys will be set on the `enquiry` being updated. */
  patch: UpdateEnquiryOnEnquiryForFkEnquiryTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `enquiry` being updated. */
export type UpdateEnquiryOnEnquiryForFkEnquiryTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  comments?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  dates?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  travellers?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkEnquiryCustomerCustomerIdInput>;
  tripToTripId?: Maybe<FkEnquiryTripTripIdInput>;
};

/** Input for the nested mutation of `customer` in the `EnquiryInput` mutation. */
export type FkEnquiryCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerPkCustomerConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerPkCustomerDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkCustomerUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<EnquiryOnEnquiryForFkEnquiryCustomerCustomerIdNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<FkEnquiryCustomerCustomerIdCustomerCreateInput>;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkCustomerUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnEnquiryForFkEnquiryCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnEnquiryForFkEnquiryCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** Input for the nested mutation of `email` in the `CustomerInput` mutation. */
export type FkEmailCustomerCustomerIdInverseInput = {
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: Maybe<Array<EmailPkEmailConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EmailNodeIdConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: Maybe<Array<EmailPkEmailDelete>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EmailNodeIdDelete>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: Maybe<Array<EmailOnEmailForFkEmailCustomerCustomerIdUsingPkEmailUpdate>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnEmailForFkEmailCustomerCustomerIdNodeIdUpdate>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkEmailCustomerCustomerIdEmailCreateInput>>;
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailCustomerCustomerIdUsingPkEmailUpdate = {
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** Input for the nested mutation of `customer` in the `EmailInput` mutation. */
export type FkEmailCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: Maybe<CustomerPkCustomerConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectByNodeId?: Maybe<CustomerNodeIdConnect>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: Maybe<CustomerPkCustomerDelete>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CustomerNodeIdDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: Maybe<CustomerOnEmailForFkEmailCustomerCustomerIdUsingPkCustomerUpdate>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateByNodeId?: Maybe<EmailOnEmailForFkEmailCustomerCustomerIdNodeIdUpdate>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: Maybe<FkEmailCustomerCustomerIdCustomerCreateInput>;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnEmailForFkEmailCustomerCustomerIdUsingPkCustomerUpdate = {
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnEmailForFkEmailCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnEmailForFkEmailCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** Input for the nested mutation of `enquiry` in the `CustomerInput` mutation. */
export type FkEnquiryCustomerCustomerIdInverseInput = {
  /** Flag indicating whether all other `enquiry` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  connectById?: Maybe<Array<EnquiryPkEnquiryConnect>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EnquiryNodeIdConnect>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  deleteById?: Maybe<Array<EnquiryPkEnquiryDelete>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EnquiryNodeIdDelete>>;
  /** The primary key(s) and patch data for `enquiry` for the far side of the relationship. */
  updateById?: Maybe<Array<EnquiryOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkEnquiryUpdate>>;
  /** The primary key(s) and patch data for `enquiry` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CustomerOnEnquiryForFkEnquiryCustomerCustomerIdNodeIdUpdate>>;
  /** A `EnquiryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkEnquiryCustomerCustomerIdEnquiryCreateInput>>;
};

/** The fields on `enquiry` to look up the row to update. */
export type EnquiryOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkEnquiryUpdate = {
  /** An object where the defined keys will be set on the `enquiry` being updated. */
  patch: UpdateEnquiryOnEnquiryForFkEnquiryCustomerCustomerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `enquiry` being updated. */
export type UpdateEnquiryOnEnquiryForFkEnquiryCustomerCustomerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  comments?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  dates?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  travellers?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  archived?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkEnquiryCustomerCustomerIdInput>;
  tripToTripId?: Maybe<FkEnquiryTripTripIdInput>;
};

/** Input for the nested mutation of `trip` in the `EnquiryInput` mutation. */
export type FkEnquiryTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnEnquiryForFkEnquiryTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<EnquiryOnEnquiryForFkEnquiryTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkEnquiryTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnEnquiryForFkEnquiryTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnEnquiryForFkEnquiryTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnEnquiryForFkEnquiryTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `note` in the `TripInput` mutation. */
export type FkNoteTripTripIdInverseInput = {
  /** Flag indicating whether all other `note` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  connectById?: Maybe<Array<NotePkNoteConnect>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<NoteNodeIdConnect>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  deleteById?: Maybe<Array<NotePkNoteDelete>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<NoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `note` for the far side of the relationship. */
  updateById?: Maybe<Array<NoteOnNoteForFkNoteTripTripIdUsingPkNoteUpdate>>;
  /** The primary key(s) and patch data for `note` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnNoteForFkNoteTripTripIdNodeIdUpdate>>;
  /** A `NoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkNoteTripTripIdNoteCreateInput>>;
};

/** The fields on `note` to look up the row to update. */
export type NoteOnNoteForFkNoteTripTripIdUsingPkNoteUpdate = {
  /** An object where the defined keys will be set on the `note` being updated. */
  patch: UpdateNoteOnNoteForFkNoteTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `note` being updated. */
export type UpdateNoteOnNoteForFkNoteTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  tripToTripId?: Maybe<FkNoteTripTripIdInput>;
  userToUserId?: Maybe<FkNoteUserUserIdInput>;
};

/** Input for the nested mutation of `user` in the `NoteInput` mutation. */
export type FkNoteUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserPkUserConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserPkUserDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnNoteForFkNoteUserUserIdUsingPkUserUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<NoteOnNoteForFkNoteUserUserIdNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FkNoteUserUserIdUserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnNoteForFkNoteUserUserIdUsingPkUserUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnNoteForFkNoteUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnNoteForFkNoteUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** Input for the nested mutation of `reminder` in the `UserInput` mutation. */
export type FkReminderUserUserIdInverseInput = {
  /** Flag indicating whether all other `reminder` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reminder` for the far side of the relationship. */
  connectById?: Maybe<Array<ReminderPkReminderConnect>>;
  /** The primary key(s) for `reminder` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReminderNodeIdConnect>>;
  /** The primary key(s) for `reminder` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReminderPkReminderDelete>>;
  /** The primary key(s) for `reminder` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReminderNodeIdDelete>>;
  /** The primary key(s) and patch data for `reminder` for the far side of the relationship. */
  updateById?: Maybe<Array<ReminderOnReminderForFkReminderUserUserIdUsingPkReminderUpdate>>;
  /** The primary key(s) and patch data for `reminder` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnReminderForFkReminderUserUserIdNodeIdUpdate>>;
  /** A `ReminderInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkReminderUserUserIdReminderCreateInput>>;
};

/** The fields on `reminder` to look up the row to connect. */
export type ReminderPkReminderConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ReminderNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reminder` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `reminder` to look up the row to delete. */
export type ReminderPkReminderDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReminderNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reminder` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `reminder` to look up the row to update. */
export type ReminderOnReminderForFkReminderUserUserIdUsingPkReminderUpdate = {
  /** An object where the defined keys will be set on the `reminder` being updated. */
  patch: UpdateReminderOnReminderForFkReminderUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `reminder` being updated. */
export type UpdateReminderOnReminderForFkReminderUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  userToUserId?: Maybe<FkReminderUserUserIdInput>;
};

/** Input for the nested mutation of `user` in the `ReminderInput` mutation. */
export type FkReminderUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserPkUserConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserPkUserDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnReminderForFkReminderUserUserIdUsingPkUserUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReminderOnReminderForFkReminderUserUserIdNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FkReminderUserUserIdUserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReminderForFkReminderUserUserIdUsingPkUserUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReminderForFkReminderUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReminderForFkReminderUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** Input for the nested mutation of `transactionNote` in the `UserInput` mutation. */
export type FkTransactionNoteUserUserIdInverseInput = {
  /** Flag indicating whether all other `transactionNote` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionNotePkTransactionNoteConnect>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionNoteNodeIdConnect>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionNotePkTransactionNoteDelete>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionNoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionNote` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkTransactionNoteUpdate>>;
  /** The primary key(s) and patch data for `transactionNote` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnTransactionNoteForFkTransactionNoteUserUserIdNodeIdUpdate>>;
  /** A `TransactionNoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionNoteUserUserIdTransactionNoteCreateInput>>;
};

/** The fields on `transactionNote` to look up the row to update. */
export type TransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkTransactionNoteUpdate = {
  /** An object where the defined keys will be set on the `transactionNote` being updated. */
  patch: UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionNote` being updated. */
export type UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  message?: Maybe<Scalars['String']>;
  transactionId?: Maybe<Scalars['UUID']>;
  userToUserId?: Maybe<FkTransactionNoteUserUserIdInput>;
  transactionToTransactionId?: Maybe<FkTransactionNoteTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `transaction` in the `TransactionNoteInput` mutation. */
export type FkTransactionNoteTransactionTransactionIdInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: Maybe<TransactionPkTransactionConnect>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectByNodeId?: Maybe<TransactionNodeIdConnect>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: Maybe<TransactionPkTransactionDelete>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TransactionNodeIdDelete>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: Maybe<TransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionUpdate>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdNodeIdUpdate>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionNoteTransactionTransactionIdTransactionCreateInput>;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionUpdate = {
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transaction` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: TransactionPatch;
};

/** Represents an update to a `Transaction`. Fields that are set will be updated. */
export type TransactionPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  externalId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  description?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionNoteTransactionTransactionIdTransactionCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnTransactionNoteForFkTransactionNoteUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionNote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionNote` being updated. */
  patch: TransactionNotePatch;
};

/** Represents an update to a `TransactionNote`. Fields that are set will be updated. */
export type TransactionNotePatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  message?: Maybe<Scalars['String']>;
  transactionId?: Maybe<Scalars['UUID']>;
  userToUserId?: Maybe<FkTransactionNoteUserUserIdInput>;
  transactionToTransactionId?: Maybe<FkTransactionNoteTransactionTransactionIdInput>;
};

/** The `transactionNote` to be created by this mutation. */
export type FkTransactionNoteUserUserIdTransactionNoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  message?: Maybe<Scalars['String']>;
  transactionId?: Maybe<Scalars['UUID']>;
  userToUserId?: Maybe<FkTransactionNoteUserUserIdInput>;
  transactionToTransactionId?: Maybe<FkTransactionNoteTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `quotePublic` in the `UserInput` mutation. */
export type FakePublicQuotePublicForeignKey2InverseInput = {
  /** Flag indicating whether all other `quotePublic` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: Maybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuotePublicNodeIdConnect>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: Maybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuotePublicNodeIdDelete>>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: Maybe<Array<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2UsingFakePublicQuotePublicPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnQuotePublicForFakePublicQuotePublicForeignKey2NodeIdUpdate>>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicQuotePublicForeignKey2QuotePublicCreateInput>>;
};

/** The fields on `quotePublic` to look up the row to connect. */
export type QuotePublicFakePublicQuotePublicPrimaryKeyConnect = {
  key: Scalars['String'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuotePublicNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quotePublic` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quotePublic` to look up the row to delete. */
export type QuotePublicFakePublicQuotePublicPrimaryKeyDelete = {
  key: Scalars['String'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuotePublicNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quotePublic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2Patch;
  key: Scalars['String'];
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  key?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** Input for the nested mutation of `trip` in the `QuotePublicInput` mutation. */
export type FakePublicQuotePublicForeignKey0Input = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnQuotePublicForFakePublicQuotePublicForeignKey0UsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0NodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicQuotePublicForeignKey0TripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnQuotePublicForFakePublicQuotePublicForeignKey0UsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnQuotePublicForFakePublicQuotePublicForeignKey0Patch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnQuotePublicForFakePublicQuotePublicForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `quote` in the `TripInput` mutation. */
export type FkQuoteTripTripIdInverseInput = {
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteNodeIdConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteNodeIdDelete>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteOnQuoteForFkQuoteTripTripIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnQuoteForFkQuoteTripTripIdNodeIdUpdate>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteTripTripIdQuoteCreateInput>>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteTripTripIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `QuoteInput` mutation. */
export type FkTripQuoteActiveQuoteIdInverseInput = {
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<Array<TripPkTripConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripNodeIdConnect>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripPkTripDelete>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripNodeIdDelete>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<Array<TripOnTripForFkTripQuoteActiveQuoteIdUsingPkTripUpdate>>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnTripForFkTripQuoteActiveQuoteIdNodeIdUpdate>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripQuoteActiveQuoteIdTripCreateInput>>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripQuoteActiveQuoteIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripQuoteActiveQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripQuoteActiveQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `testimonial` in the `TripInput` mutation. */
export type FkTestimonialTripTripIdInverseInput = {
  /** Flag indicating whether all other `testimonial` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `testimonial` for the far side of the relationship. */
  connectById?: Maybe<Array<TestimonialPkTestimonialConnect>>;
  /** The primary key(s) for `testimonial` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TestimonialNodeIdConnect>>;
  /** The primary key(s) for `testimonial` for the far side of the relationship. */
  deleteById?: Maybe<Array<TestimonialPkTestimonialDelete>>;
  /** The primary key(s) for `testimonial` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TestimonialNodeIdDelete>>;
  /** The primary key(s) and patch data for `testimonial` for the far side of the relationship. */
  updateById?: Maybe<Array<TestimonialOnTestimonialForFkTestimonialTripTripIdUsingPkTestimonialUpdate>>;
  /** The primary key(s) and patch data for `testimonial` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnTestimonialForFkTestimonialTripTripIdNodeIdUpdate>>;
  /** A `TestimonialInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTestimonialTripTripIdTestimonialCreateInput>>;
};

/** The fields on `testimonial` to look up the row to connect. */
export type TestimonialPkTestimonialConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TestimonialNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `testimonial` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `testimonial` to look up the row to delete. */
export type TestimonialPkTestimonialDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TestimonialNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `testimonial` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `testimonial` to look up the row to update. */
export type TestimonialOnTestimonialForFkTestimonialTripTripIdUsingPkTestimonialUpdate = {
  /** An object where the defined keys will be set on the `testimonial` being updated. */
  patch: UpdateTestimonialOnTestimonialForFkTestimonialTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `testimonial` being updated. */
export type UpdateTestimonialOnTestimonialForFkTestimonialTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  guestName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkTestimonialTripTripIdInput>;
};

/** Input for the nested mutation of `trip` in the `TestimonialInput` mutation. */
export type FkTestimonialTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnTestimonialForFkTestimonialTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<TestimonialOnTestimonialForFkTestimonialTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkTestimonialTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTestimonialForFkTestimonialTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTestimonialForFkTestimonialTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTestimonialForFkTestimonialTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `tripTraveller` in the `TripInput` mutation. */
export type FkTripTravellerTripTripIdInverseInput = {
  /** Flag indicating whether all other `tripTraveller` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  connectById?: Maybe<Array<TripTravellerPkTripTravellerConnect>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripTravellerNodeIdConnect>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripTravellerPkTripTravellerDelete>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripTravellerNodeIdDelete>>;
  /** The primary key(s) and patch data for `tripTraveller` for the far side of the relationship. */
  updateById?: Maybe<Array<TripTravellerOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripTravellerUpdate>>;
  /** The primary key(s) and patch data for `tripTraveller` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnTripTravellerForFkTripTravellerTripTripIdNodeIdUpdate>>;
  /** A `TripTravellerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripTravellerTripTripIdTripTravellerCreateInput>>;
};

/** The fields on `tripTraveller` to look up the row to connect. */
export type TripTravellerPkTripTravellerConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TripTravellerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `tripTraveller` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `tripTraveller` to look up the row to delete. */
export type TripTravellerPkTripTravellerDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TripTravellerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `tripTraveller` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `tripTraveller` to look up the row to update. */
export type TripTravellerOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripTravellerUpdate = {
  /** An object where the defined keys will be set on the `tripTraveller` being updated. */
  patch: UpdateTripTravellerOnTripTravellerForFkTripTravellerTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `tripTraveller` being updated. */
export type UpdateTripTravellerOnTripTravellerForFkTripTravellerTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: Maybe<FkTripTravellerTripTripIdInput>;
};

/** Input for the nested mutation of `traveller` in the `TripTravellerInput` mutation. */
export type FkTripTravellerTravellerTravellerIdInput = {
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectById?: Maybe<TravellerPkTravellerConnect>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectByNodeId?: Maybe<TravellerNodeIdConnect>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteById?: Maybe<TravellerPkTravellerDelete>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TravellerNodeIdDelete>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateById?: Maybe<TravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTravellerUpdate>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdNodeIdUpdate>;
  /** A `TravellerInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripTravellerTravellerTravellerIdTravellerCreateInput>;
};

/** The fields on `traveller` to look up the row to connect. */
export type TravellerPkTravellerConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TravellerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `traveller` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `traveller` to look up the row to delete. */
export type TravellerPkTravellerDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TravellerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `traveller` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `traveller` to look up the row to update. */
export type TravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTravellerUpdate = {
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: UpdateTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `traveller` being updated. */
export type UpdateTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** Input for the nested mutation of `customerTraveller` in the `TravellerInput` mutation. */
export type FkCustomerTravellerTravellerTravellerIdInverseInput = {
  /** Flag indicating whether all other `customerTraveller` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  connectById?: Maybe<Array<CustomerTravellerPkCustomerTravellerConnect>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CustomerTravellerNodeIdConnect>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  deleteById?: Maybe<Array<CustomerTravellerPkCustomerTravellerDelete>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CustomerTravellerNodeIdDelete>>;
  /** The primary key(s) and patch data for `customerTraveller` for the far side of the relationship. */
  updateById?: Maybe<Array<CustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkCustomerTravellerUpdate>>;
  /** The primary key(s) and patch data for `customerTraveller` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdNodeIdUpdate>>;
  /** A `CustomerTravellerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkCustomerTravellerTravellerTravellerIdCustomerTravellerCreateInput>>;
};

/** The fields on `customerTraveller` to look up the row to update. */
export type CustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkCustomerTravellerUpdate = {
  /** An object where the defined keys will be set on the `customerTraveller` being updated. */
  patch: UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `customerTraveller` being updated. */
export type UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkCustomerTravellerCustomerCustomerIdInput>;
  travellerToTravellerId?: Maybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** Input for the nested mutation of `traveller` in the `CustomerTravellerInput` mutation. */
export type FkCustomerTravellerTravellerTravellerIdInput = {
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectById?: Maybe<TravellerPkTravellerConnect>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectByNodeId?: Maybe<TravellerNodeIdConnect>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteById?: Maybe<TravellerPkTravellerDelete>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TravellerNodeIdDelete>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateById?: Maybe<TravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkTravellerUpdate>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateByNodeId?: Maybe<CustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdNodeIdUpdate>;
  /** A `TravellerInput` object that will be created and connected to this object. */
  create?: Maybe<FkCustomerTravellerTravellerTravellerIdTravellerCreateInput>;
};

/** The fields on `traveller` to look up the row to update. */
export type TravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkTravellerUpdate = {
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: UpdateTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `traveller` being updated. */
export type UpdateTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** Input for the nested mutation of `passport` in the `TravellerInput` mutation. */
export type FkPassportTravellerTravellerIdInverseInput = {
  /** Flag indicating whether all other `passport` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  connectById?: Maybe<Array<PassportPkPassportConnect>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PassportNodeIdConnect>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  deleteById?: Maybe<Array<PassportPkPassportDelete>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PassportNodeIdDelete>>;
  /** The primary key(s) and patch data for `passport` for the far side of the relationship. */
  updateById?: Maybe<Array<PassportOnPassportForFkPassportTravellerTravellerIdUsingPkPassportUpdate>>;
  /** The primary key(s) and patch data for `passport` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TravellerOnPassportForFkPassportTravellerTravellerIdNodeIdUpdate>>;
  /** A `PassportInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPassportTravellerTravellerIdPassportCreateInput>>;
};

/** The fields on `passport` to look up the row to connect. */
export type PassportPkPassportConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type PassportNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `passport` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `passport` to look up the row to delete. */
export type PassportPkPassportDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PassportNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `passport` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `passport` to look up the row to update. */
export type PassportOnPassportForFkPassportTravellerTravellerIdUsingPkPassportUpdate = {
  /** An object where the defined keys will be set on the `passport` being updated. */
  patch: UpdatePassportOnPassportForFkPassportTravellerTravellerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `passport` being updated. */
export type UpdatePassportOnPassportForFkPassportTravellerTravellerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  countryOfIssue?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  expiry?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkPassportTravellerTravellerIdInput>;
  countryToCountryId?: Maybe<PassportCountry2IdFkeyInput>;
};

/** Input for the nested mutation of `traveller` in the `PassportInput` mutation. */
export type FkPassportTravellerTravellerIdInput = {
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectById?: Maybe<TravellerPkTravellerConnect>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectByNodeId?: Maybe<TravellerNodeIdConnect>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteById?: Maybe<TravellerPkTravellerDelete>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TravellerNodeIdDelete>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateById?: Maybe<TravellerOnPassportForFkPassportTravellerTravellerIdUsingPkTravellerUpdate>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateByNodeId?: Maybe<PassportOnPassportForFkPassportTravellerTravellerIdNodeIdUpdate>;
  /** A `TravellerInput` object that will be created and connected to this object. */
  create?: Maybe<FkPassportTravellerTravellerIdTravellerCreateInput>;
};

/** The fields on `traveller` to look up the row to update. */
export type TravellerOnPassportForFkPassportTravellerTravellerIdUsingPkTravellerUpdate = {
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: UpdateTravellerOnPassportForFkPassportTravellerTravellerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `traveller` being updated. */
export type UpdateTravellerOnPassportForFkPassportTravellerTravellerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** Input for the nested mutation of `tripTraveller` in the `TravellerInput` mutation. */
export type FkTripTravellerTravellerTravellerIdInverseInput = {
  /** Flag indicating whether all other `tripTraveller` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  connectById?: Maybe<Array<TripTravellerPkTripTravellerConnect>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripTravellerNodeIdConnect>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripTravellerPkTripTravellerDelete>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripTravellerNodeIdDelete>>;
  /** The primary key(s) and patch data for `tripTraveller` for the far side of the relationship. */
  updateById?: Maybe<Array<TripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTripTravellerUpdate>>;
  /** The primary key(s) and patch data for `tripTraveller` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdNodeIdUpdate>>;
  /** A `TripTravellerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripTravellerTravellerTravellerIdTripTravellerCreateInput>>;
};

/** The fields on `tripTraveller` to look up the row to update. */
export type TripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTripTravellerUpdate = {
  /** An object where the defined keys will be set on the `tripTraveller` being updated. */
  patch: UpdateTripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `tripTraveller` being updated. */
export type UpdateTripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: Maybe<FkTripTravellerTripTripIdInput>;
};

/** Input for the nested mutation of `trip` in the `TripTravellerInput` mutation. */
export type FkTripTravellerTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripTravellerOnTripTravellerForFkTripTravellerTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripTravellerTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripTravellerForFkTripTravellerTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripTravellerForFkTripTravellerTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `tripFlight` in the `TripInput` mutation. */
export type FkTripFlightTripTripIdInverseInput = {
  /** Flag indicating whether all other `tripFlight` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectById?: Maybe<Array<TripFlightPkTripFlightConnect>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripFlightNodeIdConnect>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripFlightPkTripFlightDelete>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripFlightNodeIdDelete>>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateById?: Maybe<Array<TripFlightOnTripFlightForFkTripFlightTripTripIdUsingPkTripFlightUpdate>>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnTripFlightForFkTripFlightTripTripIdNodeIdUpdate>>;
  /** A `TripFlightInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTripFlightTripTripIdTripFlightCreateInput>>;
};

/** The fields on `tripFlight` to look up the row to connect. */
export type TripFlightPkTripFlightConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type TripFlightNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `tripFlight` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `tripFlight` to look up the row to delete. */
export type TripFlightPkTripFlightDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TripFlightNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `tripFlight` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `tripFlight` to look up the row to update. */
export type TripFlightOnTripFlightForFkTripFlightTripTripIdUsingPkTripFlightUpdate = {
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: UpdateTripFlightOnTripFlightForFkTripFlightTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `tripFlight` being updated. */
export type UpdateTripFlightOnTripFlightForFkTripFlightTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  arrival?: Maybe<Scalars['Datetime']>;
  carrier?: Maybe<Scalars['String']>;
  departure?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  departureAirportId?: Maybe<Scalars['UUID']>;
  arrivalAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** Input for the nested mutation of `trip` in the `TripFlightInput` mutation. */
export type FkTripFlightTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: Maybe<TripPkTripConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectByNodeId?: Maybe<TripNodeIdConnect>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: Maybe<TripPkTripDelete>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TripNodeIdDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: Maybe<TripOnTripFlightForFkTripFlightTripTripIdUsingPkTripUpdate>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripFlightOnTripFlightForFkTripFlightTripTripIdNodeIdUpdate>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: Maybe<FkTripFlightTripTripIdTripCreateInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripFlightForFkTripFlightTripTripIdUsingPkTripUpdate = {
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripFlightForFkTripFlightTripTripIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripFlightForFkTripFlightTripTripIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `quotePublic` in the `TripInput` mutation. */
export type FakePublicQuotePublicForeignKey0InverseInput = {
  /** Flag indicating whether all other `quotePublic` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: Maybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuotePublicNodeIdConnect>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: Maybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuotePublicNodeIdDelete>>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: Maybe<Array<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TripOnQuotePublicForFakePublicQuotePublicForeignKey0NodeIdUpdate>>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicQuotePublicForeignKey0QuotePublicCreateInput>>;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0Patch;
  key: Scalars['String'];
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  key?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** Input for the nested mutation of `quoteHero` in the `QuotePublicInput` mutation. */
export type FakePublicQuotePublicForeignKey1Input = {
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectById?: Maybe<QuoteHeroPkQuoteHeroConnect>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteHeroNodeIdConnect>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteById?: Maybe<QuoteHeroPkQuoteHeroDelete>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteHeroNodeIdDelete>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateById?: Maybe<QuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1UsingPkQuoteHeroUpdate>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1NodeIdUpdate>;
  /** A `QuoteHeroInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicQuotePublicForeignKey1QuoteHeroCreateInput>;
};

/** The fields on `quoteHero` to look up the row to update. */
export type QuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1UsingPkQuoteHeroUpdate = {
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: UpdateQuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1Patch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteHero` being updated. */
export type UpdateQuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1Patch = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  imageId?: Maybe<Scalars['UUID']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** Input for the nested mutation of `quotePublic` in the `QuoteHeroInput` mutation. */
export type FakePublicQuotePublicForeignKey1InverseInput = {
  /** Flag indicating whether all other `quotePublic` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: Maybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuotePublicNodeIdConnect>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: Maybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuotePublicNodeIdDelete>>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: Maybe<Array<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1UsingFakePublicQuotePublicPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1NodeIdUpdate>>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicQuotePublicForeignKey1QuotePublicCreateInput>>;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1Patch;
  key: Scalars['String'];
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1Patch = {
  id?: Maybe<Scalars['UUID']>;
  key?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** Input for the nested mutation of `user` in the `QuotePublicInput` mutation. */
export type FakePublicQuotePublicForeignKey2Input = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserPkUserConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserPkUserDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnQuotePublicForFakePublicQuotePublicForeignKey2UsingPkUserUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2NodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicQuotePublicForeignKey2UserCreateInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnQuotePublicForFakePublicQuotePublicForeignKey2UsingPkUserUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnQuotePublicForFakePublicQuotePublicForeignKey2Patch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnQuotePublicForFakePublicQuotePublicForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The `user` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey2UserCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `QuotePublicInput` mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0InverseInput = {
  /** Flag indicating whether all other `quoteAccommodationDetail` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteAccommodationDetailNodeIdConnect>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteAccommodationDetailNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingPkQuoteAccommodationDetailUpdate>>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0NodeIdUpdate>>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicQuoteAccommodationDetailForeignKey0QuoteAccommodationDetailCreateInput>>;
};

/** The fields on `quoteAccommodationDetail` to look up the row to connect. */
export type QuoteAccommodationDetailPkQuoteAccommodationDetailConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteAccommodationDetailNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quoteAccommodationDetail` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteAccommodationDetail` to look up the row to delete. */
export type QuoteAccommodationDetailPkQuoteAccommodationDetailDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteAccommodationDetailNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quoteAccommodationDetail` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingPkQuoteAccommodationDetailUpdate = {
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  nights?: Maybe<Scalars['Int']>;
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** Input for the nested mutation of `property` in the `QuoteAccommodationDetailInput` mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: Maybe<PropertyPkPropertyConnect>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectByNodeId?: Maybe<PropertyNodeIdConnect>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: Maybe<PropertyPkPropertyDelete>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PropertyNodeIdDelete>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: Maybe<PropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkPropertyUpdate>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdNodeIdUpdate>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdPropertyCreateInput>;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkPropertyUpdate = {
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `mapPoint` in the `PropertyInput` mutation. */
export type FkPropertyMapPointMapPointIdInput = {
  /** The primary key(s) for `mapPoint` for the far side of the relationship. */
  connectById?: Maybe<MapPointPkMapPointConnect>;
  /** The primary key(s) for `mapPoint` for the far side of the relationship. */
  connectByNodeId?: Maybe<MapPointNodeIdConnect>;
  /** The primary key(s) for `mapPoint` for the far side of the relationship. */
  deleteById?: Maybe<MapPointPkMapPointDelete>;
  /** The primary key(s) for `mapPoint` for the far side of the relationship. */
  deleteByNodeId?: Maybe<MapPointNodeIdDelete>;
  /** The primary key(s) and patch data for `mapPoint` for the far side of the relationship. */
  updateById?: Maybe<MapPointOnPropertyForFkPropertyMapPointMapPointIdUsingPkMapPointUpdate>;
  /** The primary key(s) and patch data for `mapPoint` for the far side of the relationship. */
  updateByNodeId?: Maybe<PropertyOnPropertyForFkPropertyMapPointMapPointIdNodeIdUpdate>;
  /** A `MapPointInput` object that will be created and connected to this object. */
  create?: Maybe<FkPropertyMapPointMapPointIdMapPointCreateInput>;
};

/** The fields on `mapPoint` to look up the row to connect. */
export type MapPointPkMapPointConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type MapPointNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `mapPoint` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `mapPoint` to look up the row to delete. */
export type MapPointPkMapPointDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type MapPointNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `mapPoint` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `mapPoint` to look up the row to update. */
export type MapPointOnPropertyForFkPropertyMapPointMapPointIdUsingPkMapPointUpdate = {
  /** An object where the defined keys will be set on the `mapPoint` being updated. */
  patch: UpdateMapPointOnPropertyForFkPropertyMapPointMapPointIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `mapPoint` being updated. */
export type UpdateMapPointOnPropertyForFkPropertyMapPointMapPointIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  propertiesUsingId?: Maybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** Input for the nested mutation of `property` in the `MapPointInput` mutation. */
export type FkPropertyMapPointMapPointIdInverseInput = {
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: Maybe<Array<PropertyPkPropertyConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PropertyNodeIdConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: Maybe<Array<PropertyPkPropertyDelete>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PropertyNodeIdDelete>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: Maybe<Array<PropertyOnPropertyForFkPropertyMapPointMapPointIdUsingPkPropertyUpdate>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<MapPointOnPropertyForFkPropertyMapPointMapPointIdNodeIdUpdate>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPropertyMapPointMapPointIdPropertyCreateInput>>;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyMapPointMapPointIdUsingPkPropertyUpdate = {
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyMapPointMapPointIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyMapPointMapPointIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `country` in the `PropertyInput` mutation. */
export type FkPropertyCountryCountryIdInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryPkCountryConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryPkCountryDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnPropertyForFkPropertyCountryCountryIdUsingPkCountryUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<PropertyOnPropertyForFkPropertyCountryCountryIdNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<FkPropertyCountryCountryIdCountryCreateInput>;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnPropertyForFkPropertyCountryCountryIdUsingPkCountryUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnPropertyForFkPropertyCountryCountryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnPropertyForFkPropertyCountryCountryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** Input for the nested mutation of `passport` in the `CountryInput` mutation. */
export type PassportCountry2IdFkeyInverseInput = {
  /** Flag indicating whether all other `passport` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  connectById?: Maybe<Array<PassportPkPassportConnect>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PassportNodeIdConnect>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  deleteById?: Maybe<Array<PassportPkPassportDelete>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PassportNodeIdDelete>>;
  /** The primary key(s) and patch data for `passport` for the far side of the relationship. */
  updateById?: Maybe<Array<PassportOnPassportForPassportCountry2IdFkeyUsingPkPassportUpdate>>;
  /** The primary key(s) and patch data for `passport` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnPassportForPassportCountry2IdFkeyNodeIdUpdate>>;
  /** A `PassportInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PassportCountry2IdFkeyPassportCreateInput>>;
};

/** The fields on `passport` to look up the row to update. */
export type PassportOnPassportForPassportCountry2IdFkeyUsingPkPassportUpdate = {
  /** An object where the defined keys will be set on the `passport` being updated. */
  patch: UpdatePassportOnPassportForPassportCountry2IdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `passport` being updated. */
export type UpdatePassportOnPassportForPassportCountry2IdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  countryOfIssue?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  expiry?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['String']>;
  travellerId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkPassportTravellerTravellerIdInput>;
  countryToCountryId?: Maybe<PassportCountry2IdFkeyInput>;
};

/** Input for the nested mutation of `country` in the `PassportInput` mutation. */
export type PassportCountry2IdFkeyInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: Maybe<CountryPkCountryConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectByNodeId?: Maybe<CountryNodeIdConnect>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: Maybe<CountryPkCountryDelete>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteByNodeId?: Maybe<CountryNodeIdDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: Maybe<CountryOnPassportForPassportCountry2IdFkeyUsingPkCountryUpdate>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateByNodeId?: Maybe<PassportOnPassportForPassportCountry2IdFkeyNodeIdUpdate>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: Maybe<PassportCountry2IdFkeyCountryCreateInput>;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnPassportForPassportCountry2IdFkeyUsingPkCountryUpdate = {
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnPassportForPassportCountry2IdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnPassportForPassportCountry2IdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** Input for the nested mutation of `property` in the `CountryInput` mutation. */
export type FkPropertyCountryCountryIdInverseInput = {
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: Maybe<Array<PropertyPkPropertyConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PropertyNodeIdConnect>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: Maybe<Array<PropertyPkPropertyDelete>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PropertyNodeIdDelete>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: Maybe<Array<PropertyOnPropertyForFkPropertyCountryCountryIdUsingPkPropertyUpdate>>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<CountryOnPropertyForFkPropertyCountryCountryIdNodeIdUpdate>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkPropertyCountryCountryIdPropertyCreateInput>>;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyCountryCountryIdUsingPkPropertyUpdate = {
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyCountryCountryIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyCountryCountryIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `PropertyInput` mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdInverseInput = {
  /** Flag indicating whether all other `quoteAccommodationDetail` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteAccommodationDetailNodeIdConnect>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteAccommodationDetailNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkQuoteAccommodationDetailUpdate>>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdNodeIdUpdate>>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteAccommodationDetailPropertyPropertyIdQuoteAccommodationDetailCreateInput>>;
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkQuoteAccommodationDetailUpdate = {
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  nights?: Maybe<Scalars['Int']>;
  notes?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteAccommodationDetailInput` mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `email` in the `QuoteInput` mutation. */
export type FkEmailQuoteQuoteIdInverseInput = {
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: Maybe<Array<EmailPkEmailConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EmailNodeIdConnect>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: Maybe<Array<EmailPkEmailDelete>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EmailNodeIdDelete>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: Maybe<Array<EmailOnEmailForFkEmailQuoteQuoteIdUsingPkEmailUpdate>>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnEmailForFkEmailQuoteQuoteIdNodeIdUpdate>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkEmailQuoteQuoteIdEmailCreateInput>>;
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailQuoteQuoteIdUsingPkEmailUpdate = {
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** Input for the nested mutation of `quote` in the `EmailInput` mutation. */
export type FkEmailQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnEmailForFkEmailQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<EmailOnEmailForFkEmailQuoteQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkEmailQuoteQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnEmailForFkEmailQuoteQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnEmailForFkEmailQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnEmailForFkEmailQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `quoteView` in the `QuoteInput` mutation. */
export type FkQuoteViewQuoteQuoteIdInverseInput = {
  /** Flag indicating whether all other `quoteView` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteView` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteViewPkQuoteViewConnect>>;
  /** The primary key(s) for `quoteView` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteViewNodeIdConnect>>;
  /** The primary key(s) for `quoteView` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteViewPkQuoteViewDelete>>;
  /** The primary key(s) for `quoteView` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteViewNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteView` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteViewUpdate>>;
  /** The primary key(s) and patch data for `quoteView` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdNodeIdUpdate>>;
  /** A `QuoteViewInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteViewQuoteQuoteIdQuoteViewCreateInput>>;
};

/** The fields on `quoteView` to look up the row to connect. */
export type QuoteViewPkQuoteViewConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteViewNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quoteView` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteView` to look up the row to delete. */
export type QuoteViewPkQuoteViewDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteViewNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quoteView` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteView` to look up the row to update. */
export type QuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteViewUpdate = {
  /** An object where the defined keys will be set on the `quoteView` being updated. */
  patch: UpdateQuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteView` being updated. */
export type UpdateQuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  timezone?: Maybe<Scalars['String']>;
  userIp?: Maybe<Scalars['String']>;
  viewType?: Maybe<Scalars['String']>;
  quoteToQuoteId?: Maybe<FkQuoteViewQuoteQuoteIdInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteViewInput` mutation. */
export type FkQuoteViewQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteViewQuoteQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `QuoteInput` mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdInverseInput = {
  /** Flag indicating whether all other `quoteAccommodationDetail` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteAccommodationDetailNodeIdConnect>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteAccommodationDetailNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteAccommodationDetailUpdate>>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdNodeIdUpdate>>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteAccommodationDetailQuoteQuoteIdQuoteAccommodationDetailCreateInput>>;
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteAccommodationDetailUpdate = {
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  nights?: Maybe<Scalars['Int']>;
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** Input for the nested mutation of `quotePublic` in the `QuoteAccommodationDetailInput` mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0Input = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: Maybe<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuotePublicNodeIdConnect>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: Maybe<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuotePublicNodeIdDelete>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: Maybe<QuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0NodeIdUpdate>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0QuotePublicCreateInput>;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch;
  key: Scalars['String'];
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  key?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** Input for the nested mutation of `quoteDay` in the `QuotePublicInput` mutation. */
export type FakePublicQuoteDayForeignKey0InverseInput = {
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteDayNodeIdConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteDayNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0UsingPkQuoteDayUpdate>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0NodeIdUpdate>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicQuoteDayForeignKey0QuoteDayCreateInput>>;
};

/** The fields on `quoteDay` to look up the row to connect. */
export type QuoteDayPkQuoteDayConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteDayNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quoteDay` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteDay` to look up the row to delete. */
export type QuoteDayPkQuoteDayDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteDayNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quoteDay` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0UsingPkQuoteDayUpdate = {
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0Patch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `QuoteDayInput` mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdInput = {
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: Maybe<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteAccommodationDetailNodeIdConnect>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: Maybe<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteAccommodationDetailNodeIdDelete>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: Maybe<QuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteAccommodationDetailUpdate>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdNodeIdUpdate>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteAccommodationDetailCreateInput>;
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteAccommodationDetailUpdate = {
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  nights?: Maybe<Scalars['Int']>;
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** Input for the nested mutation of `quoteDay` in the `QuoteAccommodationDetailInput` mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput = {
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteDayNodeIdConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteDayNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteDayUpdate>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdNodeIdUpdate>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteDayCreateInput>>;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteDayUpdate = {
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteDayInput` mutation. */
export type FkQuoteDayQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteDayQuoteQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `quoteCurrency` in the `QuoteInput` mutation. */
export type FkQuoteCurrencyQuoteQuoteIdInverseInput = {
  /** Flag indicating whether all other `quoteCurrency` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteCurrency` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteCurrencyPkQuoteCurrencyConnect>>;
  /** The primary key(s) for `quoteCurrency` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteCurrencyNodeIdConnect>>;
  /** The primary key(s) for `quoteCurrency` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteCurrencyPkQuoteCurrencyDelete>>;
  /** The primary key(s) for `quoteCurrency` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteCurrencyNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteCurrency` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteCurrencyUpdate>>;
  /** The primary key(s) and patch data for `quoteCurrency` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdNodeIdUpdate>>;
  /** A `QuoteCurrencyInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteCurrencyQuoteQuoteIdQuoteCurrencyCreateInput>>;
};

/** The fields on `quoteCurrency` to look up the row to connect. */
export type QuoteCurrencyPkQuoteCurrencyConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteCurrencyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quoteCurrency` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteCurrency` to look up the row to delete. */
export type QuoteCurrencyPkQuoteCurrencyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteCurrencyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quoteCurrency` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteCurrency` to look up the row to update. */
export type QuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteCurrencyUpdate = {
  /** An object where the defined keys will be set on the `quoteCurrency` being updated. */
  patch: UpdateQuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteCurrency` being updated. */
export type UpdateQuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  code?: Maybe<Scalars['String']>;
  rate?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteCurrencyInput` mutation. */
export type FkQuoteCurrencyQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteCurrencyQuoteQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `quoteDay` in the `QuoteInput` mutation. */
export type FkQuoteDayQuoteQuoteIdInverseInput = {
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteDayNodeIdConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteDayNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteDayUpdate>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdNodeIdUpdate>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteDayQuoteQuoteIdQuoteDayCreateInput>>;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteDayUpdate = {
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** Input for the nested mutation of `property` in the `QuoteDayInput` mutation. */
export type QuoteDayPropertyIdFkeyInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: Maybe<PropertyPkPropertyConnect>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectByNodeId?: Maybe<PropertyNodeIdConnect>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: Maybe<PropertyPkPropertyDelete>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PropertyNodeIdDelete>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: Maybe<PropertyOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkPropertyUpdate>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyNodeIdUpdate>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: Maybe<QuoteDayPropertyIdFkeyPropertyCreateInput>;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkPropertyUpdate = {
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnQuoteDayForQuoteDayPropertyIdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnQuoteDayForQuoteDayPropertyIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** Input for the nested mutation of `quoteDay` in the `PropertyInput` mutation. */
export type QuoteDayPropertyIdFkeyInverseInput = {
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteDayNodeIdConnect>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteDayNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkQuoteDayUpdate>>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PropertyOnQuoteDayForQuoteDayPropertyIdFkeyNodeIdUpdate>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: Maybe<Array<QuoteDayPropertyIdFkeyQuoteDayCreateInput>>;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkQuoteDayUpdate = {
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** Input for the nested mutation of `quotePublic` in the `QuoteDayInput` mutation. */
export type FakePublicQuoteDayForeignKey0Input = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: Maybe<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuotePublicNodeIdConnect>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: Maybe<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuotePublicNodeIdDelete>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: Maybe<QuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0NodeIdUpdate>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicQuoteDayForeignKey0QuotePublicCreateInput>;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0Patch;
  key: Scalars['String'];
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  key?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quotePublic` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: QuotePublicPatch;
};

/** Represents an update to a `QuotePublic`. Fields that are set will be updated. */
export type QuotePublicPatch = {
  id?: Maybe<Scalars['UUID']>;
  key?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuoteDayForeignKey0QuotePublicCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  key: Scalars['String'];
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** Input for the nested mutation of `quoteDayDestination` in the `QuoteDayInput` mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdInverseInput = {
  /** Flag indicating whether all other `quoteDayDestination` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteDayDestinationPkQuoteDayDestinationConnect>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteDayDestinationNodeIdConnect>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteDayDestinationPkQuoteDayDestinationDelete>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteDayDestinationNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteDayDestination` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayDestinationUpdate>>;
  /** The primary key(s) and patch data for `quoteDayDestination` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdNodeIdUpdate>>;
  /** A `QuoteDayDestinationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteDayDestinationQuoteDayDayIdQuoteDayDestinationCreateInput>>;
};

/** The fields on `quoteDayDestination` to look up the row to connect. */
export type QuoteDayDestinationPkQuoteDayDestinationConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteDayDestinationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quoteDayDestination` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteDayDestination` to look up the row to delete. */
export type QuoteDayDestinationPkQuoteDayDestinationDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteDayDestinationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quoteDayDestination` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteDayDestination` to look up the row to update. */
export type QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayDestinationUpdate = {
  /** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
  patch: UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
export type UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  destinationId?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  destinationToDestinationId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  quoteDayToDayId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
};

/** Input for the nested mutation of `destination` in the `QuoteDayDestinationInput` mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: Maybe<DestinationPkDestinationConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByNodeId?: Maybe<DestinationNodeIdConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: Maybe<DestinationPkDestinationDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<DestinationNodeIdDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: Maybe<DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkDestinationUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdNodeIdUpdate>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteDayDestinationDestinationDestinationIdDestinationCreateInput>;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkDestinationUpdate = {
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `destinationGuide` in the `DestinationInput` mutation. */
export type FkDestinationGuideDestinationDestinationIdInverseInput = {
  /** Flag indicating whether all other `destinationGuide` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `destinationGuide` for the far side of the relationship. */
  connectById?: Maybe<Array<DestinationGuidePkDestinationGuideConnect>>;
  /** The primary key(s) for `destinationGuide` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<DestinationGuideNodeIdConnect>>;
  /** The primary key(s) for `destinationGuide` for the far side of the relationship. */
  deleteById?: Maybe<Array<DestinationGuidePkDestinationGuideDelete>>;
  /** The primary key(s) for `destinationGuide` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<DestinationGuideNodeIdDelete>>;
  /** The primary key(s) and patch data for `destinationGuide` for the far side of the relationship. */
  updateById?: Maybe<Array<DestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationGuideUpdate>>;
  /** The primary key(s) and patch data for `destinationGuide` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdNodeIdUpdate>>;
  /** A `DestinationGuideInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkDestinationGuideDestinationDestinationIdDestinationGuideCreateInput>>;
};

/** The fields on `destinationGuide` to look up the row to connect. */
export type DestinationGuidePkDestinationGuideConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type DestinationGuideNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `destinationGuide` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `destinationGuide` to look up the row to delete. */
export type DestinationGuidePkDestinationGuideDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DestinationGuideNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `destinationGuide` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `destinationGuide` to look up the row to update. */
export type DestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationGuideUpdate = {
  /** An object where the defined keys will be set on the `destinationGuide` being updated. */
  patch: UpdateDestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destinationGuide` being updated. */
export type UpdateDestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationGuideDestinationDestinationIdInput>;
};

/** Input for the nested mutation of `destination` in the `DestinationGuideInput` mutation. */
export type FkDestinationGuideDestinationDestinationIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: Maybe<DestinationPkDestinationConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByNodeId?: Maybe<DestinationNodeIdConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: Maybe<DestinationPkDestinationDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<DestinationNodeIdDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: Maybe<DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByNodeId?: Maybe<DestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdNodeIdUpdate>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: Maybe<FkDestinationGuideDestinationDestinationIdDestinationCreateInput>;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationUpdate = {
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `quoteDayDestination` in the `DestinationInput` mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdInverseInput = {
  /** Flag indicating whether all other `quoteDayDestination` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteDayDestinationPkQuoteDayDestinationConnect>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteDayDestinationNodeIdConnect>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteDayDestinationPkQuoteDayDestinationDelete>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteDayDestinationNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteDayDestination` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkQuoteDayDestinationUpdate>>;
  /** The primary key(s) and patch data for `quoteDayDestination` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdNodeIdUpdate>>;
  /** A `QuoteDayDestinationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteDayDestinationDestinationDestinationIdQuoteDayDestinationCreateInput>>;
};

/** The fields on `quoteDayDestination` to look up the row to update. */
export type QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkQuoteDayDestinationUpdate = {
  /** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
  patch: UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
export type UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  dayId?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  destinationToDestinationId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  quoteDayToDayId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
};

/** Input for the nested mutation of `quoteDay` in the `QuoteDayDestinationInput` mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdInput = {
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: Maybe<QuoteDayPkQuoteDayConnect>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteDayNodeIdConnect>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: Maybe<QuoteDayPkQuoteDayDelete>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteDayNodeIdDelete>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: Maybe<QuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayUpdate>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdNodeIdUpdate>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteDayDestinationQuoteDayDayIdQuoteDayCreateInput>;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayUpdate = {
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteDay` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: QuoteDayPatch;
};

/** Represents an update to a `QuoteDay`. Fields that are set will be updated. */
export type QuoteDayPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** The `quoteDay` to be created by this mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdQuoteDayCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteDayDestination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
  patch: QuoteDayDestinationPatch;
};

/** Represents an update to a `QuoteDayDestination`. Fields that are set will be updated. */
export type QuoteDayDestinationPatch = {
  id?: Maybe<Scalars['UUID']>;
  destinationId?: Maybe<Scalars['UUID']>;
  dayId?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  destinationToDestinationId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  quoteDayToDayId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
};

/** The `quoteDayDestination` to be created by this mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdQuoteDayDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  dayId?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  destinationToDestinationId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  quoteDayToDayId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: DestinationPatch;
};

/** Represents an update to a `Destination`. Fields that are set will be updated. */
export type DestinationPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationGuideDestinationDestinationIdDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destinationGuide` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destinationGuide` being updated. */
  patch: DestinationGuidePatch;
};

/** Represents an update to a `DestinationGuide`. Fields that are set will be updated. */
export type DestinationGuidePatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  destinationId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationGuideDestinationDestinationIdInput>;
};

/** The `destinationGuide` to be created by this mutation. */
export type FkDestinationGuideDestinationDestinationIdDestinationGuideCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationGuideDestinationDestinationIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: DestinationPatch;
};

/** The `destination` to be created by this mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteDayDestination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
  patch: QuoteDayDestinationPatch;
};

/** The `quoteDayDestination` to be created by this mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdQuoteDayDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  destinationId?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  destinationToDestinationId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  quoteDayToDayId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PropertyOnQuoteDayForQuoteDayPropertyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteDay` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: QuoteDayPatch;
};

/** The `quoteDay` to be created by this mutation. */
export type QuoteDayPropertyIdFkeyQuoteDayCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `property` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: PropertyPatch;
};

/** Represents an update to a `Property`. Fields that are set will be updated. */
export type PropertyPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The `property` to be created by this mutation. */
export type QuoteDayPropertyIdFkeyPropertyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteDay` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: QuoteDayPatch;
};

/** The `quoteDay` to be created by this mutation. */
export type FkQuoteDayQuoteQuoteIdQuoteDayCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** Input for the nested mutation of `quoteFinanceLineItem` in the `QuoteInput` mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdInverseInput = {
  /** Flag indicating whether all other `quoteFinanceLineItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemConnect>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteFinanceLineItemNodeIdConnect>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemDelete>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteFinanceLineItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteFinanceLineItem` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteFinanceLineItemUpdate>>;
  /** The primary key(s) and patch data for `quoteFinanceLineItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdNodeIdUpdate>>;
  /** A `QuoteFinanceLineItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteFinanceLineItemQuoteQuoteIdQuoteFinanceLineItemCreateInput>>;
};

/** The fields on `quoteFinanceLineItem` to look up the row to connect. */
export type QuoteFinanceLineItemPkQuoteFinanceLineItemConnect = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type QuoteFinanceLineItemNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `quoteFinanceLineItem` to be connected. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteFinanceLineItem` to look up the row to delete. */
export type QuoteFinanceLineItemPkQuoteFinanceLineItemDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type QuoteFinanceLineItemNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `quoteFinanceLineItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `quoteFinanceLineItem` to look up the row to update. */
export type QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteFinanceLineItemUpdate = {
  /** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
  patch: UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
export type UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  confirmation?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  excludeMargin?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  marginOverride?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  supplierToSupplierId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteFinanceLineItemInput` mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: Maybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByNodeId?: Maybe<QuoteNodeIdConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: Maybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByNodeId?: Maybe<QuoteNodeIdDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: Maybe<QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdNodeIdUpdate>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdQuoteCreateInput>;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteUpdate = {
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** Represents an update to a `Quote`. Fields that are set will be updated. */
export type QuotePatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** Input for the nested mutation of `supplier` in the `QuoteFinanceLineItemInput` mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: Maybe<SupplierPkSupplierConnect>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectByNodeId?: Maybe<SupplierNodeIdConnect>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: Maybe<SupplierPkSupplierDelete>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteByNodeId?: Maybe<SupplierNodeIdDelete>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: Maybe<SupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkSupplierUpdate>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateByNodeId?: Maybe<QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdNodeIdUpdate>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdSupplierCreateInput>;
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkSupplierUpdate = {
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** Input for the nested mutation of `quoteFinanceLineItem` in the `SupplierInput` mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdInverseInput = {
  /** Flag indicating whether all other `quoteFinanceLineItem` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  connectById?: Maybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemConnect>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<QuoteFinanceLineItemNodeIdConnect>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  deleteById?: Maybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemDelete>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<QuoteFinanceLineItemNodeIdDelete>>;
  /** The primary key(s) and patch data for `quoteFinanceLineItem` for the far side of the relationship. */
  updateById?: Maybe<Array<QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkQuoteFinanceLineItemUpdate>>;
  /** The primary key(s) and patch data for `quoteFinanceLineItem` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<SupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdNodeIdUpdate>>;
  /** A `QuoteFinanceLineItemInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkQuoteFinanceLineItemSupplierSupplierIdQuoteFinanceLineItemCreateInput>>;
};

/** The fields on `quoteFinanceLineItem` to look up the row to update. */
export type QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkQuoteFinanceLineItemUpdate = {
  /** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
  patch: UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
export type UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  confirmation?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  excludeMargin?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  marginOverride?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  supplierToSupplierId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteFinanceLineItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
  patch: QuoteFinanceLineItemPatch;
};

/** Represents an update to a `QuoteFinanceLineItem`. Fields that are set will be updated. */
export type QuoteFinanceLineItemPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  supplierId?: Maybe<Scalars['UUID']>;
  confirmation?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  excludeMargin?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  order?: Maybe<Scalars['Int']>;
  marginOverride?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  supplierToSupplierId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The `quoteFinanceLineItem` to be created by this mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdQuoteFinanceLineItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  currency?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  confirmation?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  excludeMargin?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  order: Scalars['Int'];
  marginOverride?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  supplierToSupplierId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplier` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: SupplierPatch;
};

/** Represents an update to a `Supplier`. Fields that are set will be updated. */
export type SupplierPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** The `supplier` to be created by this mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdSupplierCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteFinanceLineItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
  patch: QuoteFinanceLineItemPatch;
};

/** The `quoteFinanceLineItem` to be created by this mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdQuoteFinanceLineItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  currency?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  confirmation?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  excludeMargin?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  order: Scalars['Int'];
  marginOverride?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  supplierToSupplierId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteCurrencyQuoteQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteCurrency` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteCurrency` being updated. */
  patch: QuoteCurrencyPatch;
};

/** Represents an update to a `QuoteCurrency`. Fields that are set will be updated. */
export type QuoteCurrencyPatch = {
  id?: Maybe<Scalars['UUID']>;
  code?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  rate?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInput>;
};

/** The `quoteCurrency` to be created by this mutation. */
export type FkQuoteCurrencyQuoteQuoteIdQuoteCurrencyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  code?: Maybe<Scalars['String']>;
  rate: Scalars['BigFloat'];
  quoteToQuoteId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteDayQuoteQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteDay` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: QuoteDayPatch;
};

/** The `quoteDay` to be created by this mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteDayCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteAccommodationDetail` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: QuoteAccommodationDetailPatch;
};

/** Represents an update to a `QuoteAccommodationDetail`. Fields that are set will be updated. */
export type QuoteAccommodationDetailPatch = {
  id?: Maybe<Scalars['UUID']>;
  order?: Maybe<Scalars['Int']>;
  nights?: Maybe<Scalars['Int']>;
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteAccommodationDetailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  nights: Scalars['Int'];
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteDay` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: QuoteDayPatch;
};

/** The `quoteDay` to be created by this mutation. */
export type FakePublicQuoteDayForeignKey0QuoteDayCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quotePublic` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: QuotePublicPatch;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0QuotePublicCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  key: Scalars['String'];
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteAccommodationDetail` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: QuoteAccommodationDetailPatch;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdQuoteAccommodationDetailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  nights: Scalars['Int'];
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteViewQuoteQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteView` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteView` being updated. */
  patch: QuoteViewPatch;
};

/** Represents an update to a `QuoteView`. Fields that are set will be updated. */
export type QuoteViewPatch = {
  id?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  quoteId?: Maybe<Scalars['UUID']>;
  timezone?: Maybe<Scalars['String']>;
  userIp?: Maybe<Scalars['String']>;
  viewType?: Maybe<Scalars['String']>;
  quoteToQuoteId?: Maybe<FkQuoteViewQuoteQuoteIdInput>;
};

/** The `quoteView` to be created by this mutation. */
export type FkQuoteViewQuoteQuoteIdQuoteViewCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  timezone?: Maybe<Scalars['String']>;
  userIp?: Maybe<Scalars['String']>;
  viewType?: Maybe<Scalars['String']>;
  quoteToQuoteId?: Maybe<FkQuoteViewQuoteQuoteIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type EmailOnEmailForFkEmailQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkEmailQuoteQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnEmailForFkEmailQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `email` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: EmailPatch;
};

/** Represents an update to a `Email`. Fields that are set will be updated. */
export type EmailPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** The `email` to be created by this mutation. */
export type FkEmailQuoteQuoteIdEmailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteAccommodationDetail` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: QuoteAccommodationDetailPatch;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdQuoteAccommodationDetailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  nights: Scalars['Int'];
  notes?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnPropertyForFkPropertyCountryCountryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `property` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: PropertyPatch;
};

/** The `property` to be created by this mutation. */
export type FkPropertyCountryCountryIdPropertyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PassportOnPassportForPassportCountry2IdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** Represents an update to a `Country`. Fields that are set will be updated. */
export type CountryPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The `country` to be created by this mutation. */
export type PassportCountry2IdFkeyCountryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnPassportForPassportCountry2IdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `passport` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `passport` being updated. */
  patch: PassportPatch;
};

/** Represents an update to a `Passport`. Fields that are set will be updated. */
export type PassportPatch = {
  id?: Maybe<Scalars['UUID']>;
  countryOfIssue?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  expiry?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['String']>;
  travellerId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkPassportTravellerTravellerIdInput>;
  countryToCountryId?: Maybe<PassportCountry2IdFkeyInput>;
};

/** The `passport` to be created by this mutation. */
export type PassportCountry2IdFkeyPassportCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  countryOfIssue?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  expiry: Scalars['Datetime'];
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['String']>;
  travellerId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkPassportTravellerTravellerIdInput>;
  countryToCountryId?: Maybe<PassportCountry2IdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PropertyOnPropertyForFkPropertyCountryCountryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** The `country` to be created by this mutation. */
export type FkPropertyCountryCountryIdCountryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MapPointOnPropertyForFkPropertyMapPointMapPointIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `property` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: PropertyPatch;
};

/** The `property` to be created by this mutation. */
export type FkPropertyMapPointMapPointIdPropertyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PropertyOnPropertyForFkPropertyMapPointMapPointIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mapPoint` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mapPoint` being updated. */
  patch: MapPointPatch;
};

/** Represents an update to a `MapPoint`. Fields that are set will be updated. */
export type MapPointPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  propertiesUsingId?: Maybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** The `mapPoint` to be created by this mutation. */
export type FkPropertyMapPointMapPointIdMapPointCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  propertiesUsingId?: Maybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `property` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: PropertyPatch;
};

/** The `property` to be created by this mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdPropertyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteAccommodationDetail` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: QuoteAccommodationDetailPatch;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0QuoteAccommodationDetailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  nights: Scalars['Int'];
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quotePublic` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: QuotePublicPatch;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey1QuotePublicCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  key: Scalars['String'];
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteHero` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: QuoteHeroPatch;
};

/** Represents an update to a `QuoteHero`. Fields that are set will be updated. */
export type QuoteHeroPatch = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  imageId?: Maybe<Scalars['UUID']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** The `quoteHero` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey1QuoteHeroCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  imageId?: Maybe<Scalars['UUID']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnQuotePublicForFakePublicQuotePublicForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quotePublic` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: QuotePublicPatch;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey0QuotePublicCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  key: Scalars['String'];
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripFlightOnTripFlightForFkTripFlightTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** Represents an update to a `Trip`. Fields that are set will be updated. */
export type TripPatch = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The `trip` to be created by this mutation. */
export type FkTripFlightTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `airport` in the `TripFlightInput` mutation. */
export type TripFlightDepartureAirport2IdFkeyInput = {
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectById?: Maybe<AirportPkAirportConnect>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectByNodeId?: Maybe<AirportNodeIdConnect>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteById?: Maybe<AirportPkAirportDelete>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AirportNodeIdDelete>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateById?: Maybe<AirportOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkAirportUpdate>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyNodeIdUpdate>;
  /** A `AirportInput` object that will be created and connected to this object. */
  create?: Maybe<TripFlightDepartureAirport2IdFkeyAirportCreateInput>;
};

/** The fields on `airport` to look up the row to update. */
export type AirportOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkAirportUpdate = {
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: UpdateAirportOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `airport` being updated. */
export type UpdateAirportOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  countryId?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** Input for the nested mutation of `tripFlight` in the `AirportInput` mutation. */
export type TripFlightDepartureAirport2IdFkeyInverseInput = {
  /** Flag indicating whether all other `tripFlight` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectById?: Maybe<Array<TripFlightPkTripFlightConnect>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripFlightNodeIdConnect>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripFlightPkTripFlightDelete>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripFlightNodeIdDelete>>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateById?: Maybe<Array<TripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkTripFlightUpdate>>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AirportOnTripFlightForTripFlightDepartureAirport2IdFkeyNodeIdUpdate>>;
  /** A `TripFlightInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TripFlightDepartureAirport2IdFkeyTripFlightCreateInput>>;
};

/** The fields on `tripFlight` to look up the row to update. */
export type TripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkTripFlightUpdate = {
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: UpdateTripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `tripFlight` being updated. */
export type UpdateTripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  arrival?: Maybe<Scalars['Datetime']>;
  carrier?: Maybe<Scalars['String']>;
  departure?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  arrivalAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** Input for the nested mutation of `airport` in the `TripFlightInput` mutation. */
export type TripFlightArrivalAirport2IdFkeyInput = {
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectById?: Maybe<AirportPkAirportConnect>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectByNodeId?: Maybe<AirportNodeIdConnect>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteById?: Maybe<AirportPkAirportDelete>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AirportNodeIdDelete>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateById?: Maybe<AirportOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkAirportUpdate>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateByNodeId?: Maybe<TripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyNodeIdUpdate>;
  /** A `AirportInput` object that will be created and connected to this object. */
  create?: Maybe<TripFlightArrivalAirport2IdFkeyAirportCreateInput>;
};

/** The fields on `airport` to look up the row to update. */
export type AirportOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkAirportUpdate = {
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: UpdateAirportOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `airport` being updated. */
export type UpdateAirportOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  countryId?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** Input for the nested mutation of `tripFlight` in the `AirportInput` mutation. */
export type TripFlightArrivalAirport2IdFkeyInverseInput = {
  /** Flag indicating whether all other `tripFlight` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectById?: Maybe<Array<TripFlightPkTripFlightConnect>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TripFlightNodeIdConnect>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteById?: Maybe<Array<TripFlightPkTripFlightDelete>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TripFlightNodeIdDelete>>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateById?: Maybe<Array<TripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkTripFlightUpdate>>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AirportOnTripFlightForTripFlightArrivalAirport2IdFkeyNodeIdUpdate>>;
  /** A `TripFlightInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TripFlightArrivalAirport2IdFkeyTripFlightCreateInput>>;
};

/** The fields on `tripFlight` to look up the row to update. */
export type TripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkTripFlightUpdate = {
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: UpdateTripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `tripFlight` being updated. */
export type UpdateTripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  arrival?: Maybe<Scalars['Datetime']>;
  carrier?: Maybe<Scalars['String']>;
  departure?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  departureAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AirportOnTripFlightForTripFlightArrivalAirport2IdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tripFlight` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: TripFlightPatch;
};

/** Represents an update to a `TripFlight`. Fields that are set will be updated. */
export type TripFlightPatch = {
  id?: Maybe<Scalars['UUID']>;
  arrival?: Maybe<Scalars['Datetime']>;
  carrier?: Maybe<Scalars['String']>;
  departure?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  departureAirportId?: Maybe<Scalars['UUID']>;
  arrivalAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** The `tripFlight` to be created by this mutation. */
export type TripFlightArrivalAirport2IdFkeyTripFlightCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  arrival: Scalars['Datetime'];
  carrier?: Maybe<Scalars['String']>;
  departure: Scalars['Datetime'];
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  departureAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `airport` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: AirportPatch;
};

/** Represents an update to a `Airport`. Fields that are set will be updated. */
export type AirportPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  countryId?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** The `airport` to be created by this mutation. */
export type TripFlightArrivalAirport2IdFkeyAirportCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  countryId?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AirportOnTripFlightForTripFlightDepartureAirport2IdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tripFlight` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: TripFlightPatch;
};

/** The `tripFlight` to be created by this mutation. */
export type TripFlightDepartureAirport2IdFkeyTripFlightCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  arrival: Scalars['Datetime'];
  carrier?: Maybe<Scalars['String']>;
  departure: Scalars['Datetime'];
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  arrivalAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `airport` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: AirportPatch;
};

/** The `airport` to be created by this mutation. */
export type TripFlightDepartureAirport2IdFkeyAirportCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  countryId?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripFlightForFkTripFlightTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tripFlight` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: TripFlightPatch;
};

/** The `tripFlight` to be created by this mutation. */
export type FkTripFlightTripTripIdTripFlightCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  arrival: Scalars['Datetime'];
  carrier?: Maybe<Scalars['String']>;
  departure: Scalars['Datetime'];
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  departureAirportId?: Maybe<Scalars['UUID']>;
  arrivalAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripTravellerOnTripTravellerForFkTripTravellerTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTripTravellerTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tripTraveller` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `tripTraveller` being updated. */
  patch: TripTravellerPatch;
};

/** Represents an update to a `TripTraveller`. Fields that are set will be updated. */
export type TripTravellerPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: Maybe<FkTripTravellerTripTripIdInput>;
};

/** The `tripTraveller` to be created by this mutation. */
export type FkTripTravellerTravellerTravellerIdTripTravellerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: Maybe<FkTripTravellerTripTripIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PassportOnPassportForFkPassportTravellerTravellerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `traveller` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: TravellerPatch;
};

/** Represents an update to a `Traveller`. Fields that are set will be updated. */
export type TravellerPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** The `traveller` to be created by this mutation. */
export type FkPassportTravellerTravellerIdTravellerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TravellerOnPassportForFkPassportTravellerTravellerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `passport` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `passport` being updated. */
  patch: PassportPatch;
};

/** The `passport` to be created by this mutation. */
export type FkPassportTravellerTravellerIdPassportCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  countryOfIssue?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  expiry: Scalars['Datetime'];
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkPassportTravellerTravellerIdInput>;
  countryToCountryId?: Maybe<PassportCountry2IdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `traveller` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: TravellerPatch;
};

/** The `traveller` to be created by this mutation. */
export type FkCustomerTravellerTravellerTravellerIdTravellerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerTraveller` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerTraveller` being updated. */
  patch: CustomerTravellerPatch;
};

/** Represents an update to a `CustomerTraveller`. Fields that are set will be updated. */
export type CustomerTravellerPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkCustomerTravellerCustomerCustomerIdInput>;
  travellerToTravellerId?: Maybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** The `customerTraveller` to be created by this mutation. */
export type FkCustomerTravellerTravellerTravellerIdCustomerTravellerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkCustomerTravellerCustomerCustomerIdInput>;
  travellerToTravellerId?: Maybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `traveller` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: TravellerPatch;
};

/** The `traveller` to be created by this mutation. */
export type FkTripTravellerTravellerTravellerIdTravellerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripTravellerForFkTripTravellerTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tripTraveller` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `tripTraveller` being updated. */
  patch: TripTravellerPatch;
};

/** The `tripTraveller` to be created by this mutation. */
export type FkTripTravellerTripTripIdTripTravellerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: Maybe<FkTripTravellerTripTripIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TestimonialOnTestimonialForFkTestimonialTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTestimonialTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTestimonialForFkTestimonialTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `testimonial` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `testimonial` being updated. */
  patch: TestimonialPatch;
};

/** Represents an update to a `Testimonial`. Fields that are set will be updated. */
export type TestimonialPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  guestName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTestimonialTripTripIdInput>;
};

/** The `testimonial` to be created by this mutation. */
export type FkTestimonialTripTripIdTestimonialCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  guestName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkTestimonialTripTripIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnTripForFkTripQuoteActiveQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTripQuoteActiveQuoteIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnQuoteForFkQuoteTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteTripTripIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey0TripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnQuotePublicForFakePublicQuotePublicForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quotePublic` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: QuotePublicPatch;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey2QuotePublicCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  key: Scalars['String'];
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ReminderOnReminderForFkReminderUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type FkReminderUserUserIdUserCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReminderForFkReminderUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reminder` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reminder` being updated. */
  patch: ReminderPatch;
};

/** Represents an update to a `Reminder`. Fields that are set will be updated. */
export type ReminderPatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  userToUserId?: Maybe<FkReminderUserUserIdInput>;
};

/** The `reminder` to be created by this mutation. */
export type FkReminderUserUserIdReminderCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  userToUserId?: Maybe<FkReminderUserUserIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type NoteOnNoteForFkNoteUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type FkNoteUserUserIdUserCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnNoteForFkNoteTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `note` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `note` being updated. */
  patch: NotePatch;
};

/** Represents an update to a `Note`. Fields that are set will be updated. */
export type NotePatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  tripToTripId?: Maybe<FkNoteTripTripIdInput>;
  userToUserId?: Maybe<FkNoteUserUserIdInput>;
};

/** The `note` to be created by this mutation. */
export type FkNoteTripTripIdNoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  tripToTripId?: Maybe<FkNoteTripTripIdInput>;
  userToUserId?: Maybe<FkNoteUserUserIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type EnquiryOnEnquiryForFkEnquiryTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkEnquiryTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnEnquiryForFkEnquiryCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `enquiry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `enquiry` being updated. */
  patch: EnquiryPatch;
};

/** Represents an update to a `Enquiry`. Fields that are set will be updated. */
export type EnquiryPatch = {
  id?: Maybe<Scalars['UUID']>;
  comments?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  dates?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  travellers?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  archived?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkEnquiryCustomerCustomerIdInput>;
  tripToTripId?: Maybe<FkEnquiryTripTripIdInput>;
};

/** The `enquiry` to be created by this mutation. */
export type FkEnquiryCustomerCustomerIdEnquiryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  comments?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  dates?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  travellers?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  archived?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkEnquiryCustomerCustomerIdInput>;
  tripToTripId?: Maybe<FkEnquiryTripTripIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type EmailOnEmailForFkEmailCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** Represents an update to a `Customer`. Fields that are set will be updated. */
export type CustomerPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** The `customer` to be created by this mutation. */
export type FkEmailCustomerCustomerIdCustomerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnEmailForFkEmailCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `email` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: EmailPatch;
};

/** The `email` to be created by this mutation. */
export type FkEmailCustomerCustomerIdEmailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type EnquiryOnEnquiryForFkEnquiryCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The `customer` to be created by this mutation. */
export type FkEnquiryCustomerCustomerIdCustomerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnEnquiryForFkEnquiryTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `enquiry` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `enquiry` being updated. */
  patch: EnquiryPatch;
};

/** The `enquiry` to be created by this mutation. */
export type FkEnquiryTripTripIdEnquiryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  comments?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  dates?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  travellers?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkEnquiryCustomerCustomerIdInput>;
  tripToTripId?: Maybe<FkEnquiryTripTripIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PaymentOnPaymentForFkPaymentTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkPaymentTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** Input for the nested mutation of `transactionLink` in the `PaymentInput` mutation. */
export type FkTransactionLinkPaymentPaymentIdInverseInput = {
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionLinkNodeIdConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionLinkNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkTransactionLinkUpdate>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdNodeIdUpdate>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionLinkPaymentPaymentIdTransactionLinkCreateInput>>;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkTransactionLinkUpdate = {
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** Input for the nested mutation of `invoice` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkInvoiceInvoiceIdInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: Maybe<InvoicePkInvoiceConnect>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<InvoiceNodeIdConnect>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: Maybe<InvoicePkInvoiceDelete>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<InvoiceNodeIdDelete>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: Maybe<InvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkInvoiceUpdate>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdNodeIdUpdate>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionLinkInvoiceInvoiceIdInvoiceCreateInput>;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkInvoiceUpdate = {
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `transactionLink` in the `InvoiceInput` mutation. */
export type FkTransactionLinkInvoiceInvoiceIdInverseInput = {
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionLinkNodeIdConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionLinkNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkTransactionLinkUpdate>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<InvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdNodeIdUpdate>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionLinkInvoiceInvoiceIdTransactionLinkCreateInput>>;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkTransactionLinkUpdate = {
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: Maybe<SupplierInvoicePkSupplierInvoiceConnect>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectByNodeId?: Maybe<SupplierInvoiceNodeIdConnect>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: Maybe<SupplierInvoicePkSupplierInvoiceDelete>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteByNodeId?: Maybe<SupplierInvoiceNodeIdDelete>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: Maybe<SupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdNodeIdUpdate>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput>;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate = {
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** Input for the nested mutation of `transactionLink` in the `SupplierInvoiceInput` mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput = {
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionLinkNodeIdConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionLinkNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkTransactionLinkUpdate>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<SupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdNodeIdUpdate>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdTransactionLinkCreateInput>>;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkTransactionLinkUpdate = {
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** Input for the nested mutation of `payment` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkPaymentPaymentIdInput = {
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: Maybe<PaymentPkPaymentConnect>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectByNodeId?: Maybe<PaymentNodeIdConnect>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: Maybe<PaymentPkPaymentDelete>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PaymentNodeIdDelete>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: Maybe<PaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkPaymentUpdate>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdNodeIdUpdate>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionLinkPaymentPaymentIdPaymentCreateInput>;
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkPaymentUpdate = {
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `payment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: PaymentPatch;
};

/** Represents an update to a `Payment`. Fields that are set will be updated. */
export type PaymentPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** The `payment` to be created by this mutation. */
export type FkTransactionLinkPaymentPaymentIdPaymentCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** Input for the nested mutation of `expense` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkExpenseExpenseIdInput = {
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: Maybe<ExpensePkExpenseConnect>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectByNodeId?: Maybe<ExpenseNodeIdConnect>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: Maybe<ExpensePkExpenseDelete>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ExpenseNodeIdDelete>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: Maybe<ExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkExpenseUpdate>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateByNodeId?: Maybe<TransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdNodeIdUpdate>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: Maybe<FkTransactionLinkExpenseExpenseIdExpenseCreateInput>;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkExpenseUpdate = {
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** Input for the nested mutation of `transactionLink` in the `ExpenseInput` mutation. */
export type FkTransactionLinkExpenseExpenseIdInverseInput = {
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: Maybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TransactionLinkNodeIdConnect>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: Maybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TransactionLinkNodeIdDelete>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: Maybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkTransactionLinkUpdate>>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdNodeIdUpdate>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FkTransactionLinkExpenseExpenseIdTransactionLinkCreateInput>>;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkTransactionLinkUpdate = {
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch;
  id: Scalars['UUID'];
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionLink` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: TransactionLinkPatch;
};

/** Represents an update to a `TransactionLink`. Fields that are set will be updated. */
export type TransactionLinkPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkExpenseExpenseIdTransactionLinkCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `expense` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: ExpensePatch;
};

/** Represents an update to a `Expense`. Fields that are set will be updated. */
export type ExpensePatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The `expense` to be created by this mutation. */
export type FkTransactionLinkExpenseExpenseIdExpenseCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionLink` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: TransactionLinkPatch;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdTransactionLinkCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** Represents an update to a `SupplierInvoice`. Fields that are set will be updated. */
export type SupplierInvoicePatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionLink` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: TransactionLinkPatch;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkInvoiceInvoiceIdTransactionLinkCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** Represents an update to a `Invoice`. Fields that are set will be updated. */
export type InvoicePatch = {
  id?: Maybe<Scalars['UUID']>;
  amount?: Maybe<Scalars['BigFloat']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due?: Maybe<Scalars['Datetime']>;
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The `invoice` to be created by this mutation. */
export type FkTransactionLinkInvoiceInvoiceIdInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionLink` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: TransactionLinkPatch;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkPaymentPaymentIdTransactionLinkCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnPaymentForFkPaymentInvoiceInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `payment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: PaymentPatch;
};

/** The `payment` to be created by this mutation. */
export type FkPaymentInvoiceInvoiceIdPaymentCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnInvoiceForFkInvoiceQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** The `invoice` to be created by this mutation. */
export type FkInvoiceQuoteQuoteIdInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnQuoteForFkQuoteUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteUserUserIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type EmailOnEmailForFkEmailUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type FkEmailUserUserIdUserCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnEmailForFkEmailTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `email` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: EmailPatch;
};

/** The `email` to be created by this mutation. */
export type FkEmailTripTripIdEmailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ExpenseOnExpenseForFkExpenseTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkExpenseTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `expense` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: ExpensePatch;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdExpenseCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceTripTripIdSupplierInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type NoteOnNoteForFkNoteTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkNoteTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnNoteForFkNoteUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `note` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `note` being updated. */
  patch: NotePatch;
};

/** The `note` to be created by this mutation. */
export type FkNoteUserUserIdNoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  tripToTripId?: Maybe<FkNoteTripTripIdInput>;
  userToUserId?: Maybe<FkNoteUserUserIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type FkTransactionNoteUserUserIdUserCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionNote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionNote` being updated. */
  patch: TransactionNotePatch;
};

/** The `transactionNote` to be created by this mutation. */
export type FkTransactionNoteTransactionTransactionIdTransactionNoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  message?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<FkTransactionNoteUserUserIdInput>;
  transactionToTransactionId?: Maybe<FkTransactionNoteTransactionTransactionIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transaction` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: TransactionPatch;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionLinkTransactionTransactionIdTransactionCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionLink` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: TransactionLinkPatch;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkTransactionTransactionIdTransactionLinkCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type FinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transaction` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: TransactionPatch;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionFinanceCategoryCategoryIdTransactionCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `financeCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: FinanceCategoryPatch;
};

/** Represents an update to a `FinanceCategory`. Fields that are set will be updated. */
export type FinanceCategoryPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** The `financeCategory` to be created by this mutation. */
export type FkPaymentFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnPaymentForFkPaymentTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `payment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: PaymentPatch;
};

/** The `payment` to be created by this mutation. */
export type FkPaymentTripTripIdPaymentCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type EmailOnEmailForFkEmailTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkEmailTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnEmailForFkEmailUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `email` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: EmailPatch;
};

/** The `email` to be created by this mutation. */
export type FkEmailUserUserIdEmailCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteForFkQuoteUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type FkQuoteUserUserIdUserCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteQuoteHeroHeroIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteHero` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: QuoteHeroPatch;
};

/** The `quoteHero` to be created by this mutation. */
export type FkQuoteHeroMediaItemImageIdQuoteHeroCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: MediaItemPatch;
};

/** Represents an update to a `MediaItem`. Fields that are set will be updated. */
export type MediaItemPatch = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The `mediaItem` to be created by this mutation. */
export type FkQuoteHeroMediaItemImageIdMediaItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteForFkQuoteQuoteHeroHeroIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quoteHero` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: QuoteHeroPatch;
};

/** The `quoteHero` to be created by this mutation. */
export type FkQuoteQuoteHeroHeroIdQuoteHeroCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  imageId?: Maybe<Scalars['UUID']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaItemOnQuoteForFkQuoteMediaItemHeroImageIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteMediaItemHeroImageIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PropertyOnPropertyForFkPropertyMediaItemHeroMediaIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The `mediaItem` to be created by this mutation. */
export type FkPropertyMediaItemHeroMediaIdMediaItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `property` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: PropertyPatch;
};

/** The `property` to be created by this mutation. */
export type FkPropertyMediaItemHeroMediaIdPropertyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The `mediaItem` to be created by this mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdMediaItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGalleryItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
  patch: MediaGalleryItemPatch;
};

/** Represents an update to a `MediaGalleryItem`. Fields that are set will be updated. */
export type MediaGalleryItemPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  isHero?: Maybe<Scalars['Boolean']>;
  mediaGalleryToMediaGalleryId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
};

/** The `mediaGalleryItem` to be created by this mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdMediaGalleryItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  isHero?: Maybe<Scalars['Boolean']>;
  mediaGalleryToMediaGalleryId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The `mediaItem` to be created by this mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdMediaItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnExpenseForFkExpenseInvoiceInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `expense` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: ExpensePatch;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseInvoiceInvoiceIdExpenseCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnInvoiceForFkInvoiceTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** The `invoice` to be created by this mutation. */
export type FkInvoiceTripTripIdInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkSupplierInvoiceTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceSupplierSupplierIdSupplierInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplier` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: SupplierPatch;
};

/** The `supplier` to be created by this mutation. */
export type FkSupplierInvoiceSupplierSupplierIdSupplierCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type FinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdSupplierInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `financeCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: FinanceCategoryPatch;
};

/** The `financeCategory` to be created by this mutation. */
export type FkExpenseFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierOnExpenseForFkExpenseSupplierSupplierIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `expense` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: ExpensePatch;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseSupplierSupplierIdExpenseCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplier` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: SupplierPatch;
};

/** The `supplier` to be created by this mutation. */
export type FkSupplierMediaGalleryGalleryIdSupplierCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PropertyOnPropertyForFkPropertyMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** Represents an update to a `MediaGallery`. Fields that are set will be updated. */
export type MediaGalleryPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkPropertyMediaGalleryGalleryIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `property` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: PropertyPatch;
};

/** The `property` to be created by this mutation. */
export type FkPropertyMediaGalleryGalleryIdPropertyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGalleryItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
  patch: MediaGalleryItemPatch;
};

/** The `mediaGalleryItem` to be created by this mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  isHero?: Maybe<Scalars['Boolean']>;
  mediaGalleryToMediaGalleryId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type FeatureOnFeatureForFkFeatureMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkFeatureMediaGalleryGalleryIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `feature` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `feature` being updated. */
  patch: FeaturePatch;
};

/** Represents an update to a `Feature`. Fields that are set will be updated. */
export type FeaturePatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkFeatureMediaGalleryGalleryIdInput>;
};

/** The `feature` to be created by this mutation. */
export type FkFeatureMediaGalleryGalleryIdFeatureCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkFeatureMediaGalleryGalleryIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destinationFeature` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destinationFeature` being updated. */
  patch: DestinationFeaturePatch;
};

/** Represents an update to a `DestinationFeature`. Fields that are set will be updated. */
export type DestinationFeaturePatch = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  destinationId?: Maybe<Scalars['UUID']>;
  galleryId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationFeatureDestinationDestinationIdInput>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
};

/** The `destinationFeature` to be created by this mutation. */
export type FkDestinationFeatureDestinationDestinationIdDestinationFeatureCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  galleryId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationFeatureDestinationDestinationIdInput>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaItemOnDestinationForDestinationHeroMediaIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: DestinationPatch;
};

/** The `destination` to be created by this mutation. */
export type DestinationHeroMediaIdFkeyDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationOnDestinationForDestinationHeroMediaIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The `mediaItem` to be created by this mutation. */
export type DestinationHeroMediaIdFkeyMediaItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnDestinationForFkDestinationCountryCountryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: DestinationPatch;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationCountryCountryIdDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AirportOnAirportForFkAirportCountryCountryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** The `country` to be created by this mutation. */
export type FkAirportCountryCountryIdCountryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CountryOnAirportForFkAirportCountryCountryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `airport` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: AirportPatch;
};

/** The `airport` to be created by this mutation. */
export type FkAirportCountryCountryIdAirportCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationOnDestinationForFkDestinationCountryCountryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `country` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: CountryPatch;
};

/** The `country` to be created by this mutation. */
export type FkDestinationCountryCountryIdCountryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationOnDestinationForFkDestinationDestinationParentIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: DestinationPatch;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationDestinationParentIdDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: DestinationPatch;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationFeatureDestinationDestinationIdDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destinationFeature` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destinationFeature` being updated. */
  patch: DestinationFeaturePatch;
};

/** The `destinationFeature` to be created by this mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdDestinationFeatureCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  destinationId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationFeatureDestinationDestinationIdInput>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkDestinationMediaGalleryGalleryIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `destination` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: DestinationPatch;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationMediaGalleryGalleryIdDestinationCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierOnSupplierForFkSupplierMediaGalleryGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkSupplierMediaGalleryGalleryIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ExpenseOnExpenseForFkExpenseSupplierSupplierIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplier` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: SupplierPatch;
};

/** The `supplier` to be created by this mutation. */
export type FkExpenseSupplierSupplierIdSupplierCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnExpenseForFkExpenseTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `expense` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: ExpensePatch;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseTripTripIdExpenseCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTripAgencyMemberAgencyMemberIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripForFkTripAgencyMemberAgencyMemberIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `agencyMember` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `agencyMember` being updated. */
  patch: AgencyMemberPatch;
};

/** Represents an update to a `AgencyMember`. Fields that are set will be updated. */
export type AgencyMemberPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  genderPreposition?: Maybe<Scalars['String']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyToAgencyId?: Maybe<FkAgencyMemberAgencyAgencyIdInput>;
  tripsUsingId?: Maybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** The `agencyMember` to be created by this mutation. */
export type FkTripAgencyMemberAgencyMemberIdAgencyMemberCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  genderPreposition?: Maybe<Scalars['String']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyToAgencyId?: Maybe<FkAgencyMemberAgencyAgencyIdInput>;
  tripsUsingId?: Maybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AgencyOnTripForFkTripAgencyAgencyIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTripAgencyAgencyIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `agency` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: AgencyPatch;
};

/** Represents an update to a `Agency`. Fields that are set will be updated. */
export type AgencyPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  logoId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** The `agency` to be created by this mutation. */
export type FkAgencyMemberAgencyAgencyIdAgencyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  logoId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `agencyMember` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `agencyMember` being updated. */
  patch: AgencyMemberPatch;
};

/** The `agencyMember` to be created by this mutation. */
export type FkAgencyMemberAgencyAgencyIdAgencyMemberCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  genderPreposition?: Maybe<Scalars['String']>;
  agencyToAgencyId?: Maybe<FkAgencyMemberAgencyAgencyIdInput>;
  tripsUsingId?: Maybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripForFkTripAgencyAgencyIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `agency` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: AgencyPatch;
};

/** The `agency` to be created by this mutation. */
export type FkTripAgencyAgencyIdAgencyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  logoId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnInvoiceForFkInvoiceTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkInvoiceTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type PaymentOnPaymentForFkPaymentInvoiceInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** The `invoice` to be created by this mutation. */
export type FkPaymentInvoiceInvoiceIdInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type FinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `payment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: PaymentPatch;
};

/** The `payment` to be created by this mutation. */
export type FkPaymentFinanceCategoryCategoryIdPaymentCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `financeCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: FinanceCategoryPatch;
};

/** The `financeCategory` to be created by this mutation. */
export type FkInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type FinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** The `invoice` to be created by this mutation. */
export type FkInvoiceFinanceCategoryCategoryIdInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `financeCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: FinanceCategoryPatch;
};

/** The `financeCategory` to be created by this mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `supplierInvoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdSupplierInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AgencyOnAgencyForFkAgencyMediaItemLogoIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The `mediaItem` to be created by this mutation. */
export type FkAgencyMediaItemLogoIdMediaItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaItemOnAgencyForFkAgencyMediaItemLogoIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `agency` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: AgencyPatch;
};

/** The `agency` to be created by this mutation. */
export type FkAgencyMediaItemLogoIdAgencyCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteForFkQuoteMediaItemHeroImageIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaItem` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The `mediaItem` to be created by this mutation. */
export type FkQuoteMediaItemHeroImageIdMediaItemCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripForFkTripQuoteActiveQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkTripQuoteActiveQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTripMediaGalleryMediaGalleryIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type MediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkMediaGalleryMediaGalleryParentIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripForFkTripMediaGalleryMediaGalleryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `mediaGallery` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkTripMediaGalleryMediaGalleryIdMediaGalleryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnTripForFkTripUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTripUserUserIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripForFkTripUserUserIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The `user` to be created by this mutation. */
export type FkTripUserUserIdUserCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnTripForFkTripCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkTripCustomerCustomerIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The `customer` to be created by this mutation. */
export type FkCustomerTravellerCustomerCustomerIdCustomerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type CustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customerTraveller` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customerTraveller` being updated. */
  patch: CustomerTravellerPatch;
};

/** The `customerTraveller` to be created by this mutation. */
export type FkCustomerTravellerCustomerCustomerIdCustomerTravellerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkCustomerTravellerCustomerCustomerIdInput>;
  travellerToTravellerId?: Maybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TripOnTripForFkTripCustomerCustomerIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `customer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: CustomerPatch;
};

/** The `customer` to be created by this mutation. */
export type FkTripCustomerCustomerIdCustomerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type QuoteOnQuoteForFkQuoteTripTripIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `trip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: TripPatch;
};

/** The `trip` to be created by this mutation. */
export type FkQuoteTripTripIdTripCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type InvoiceOnInvoiceForFkInvoiceQuoteQuoteIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `quote` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: QuotePatch;
};

/** The `quote` to be created by this mutation. */
export type FkInvoiceQuoteQuoteIdQuoteCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ExpenseOnExpenseForFkExpenseInvoiceInvoiceIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `invoice` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: InvoicePatch;
};

/** The `invoice` to be created by this mutation. */
export type FkExpenseInvoiceInvoiceIdInvoiceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type FinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `expense` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: ExpensePatch;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseFinanceCategoryCategoryIdExpenseCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `financeCategory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: FinanceCategoryPatch;
};

/** The `financeCategory` to be created by this mutation. */
export type FkTransactionFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionOnTransactionForFkTransactionTransactionReverseTransactionIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transaction` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: TransactionPatch;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionTransactionReverseTransactionIdTransactionCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transaction` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: TransactionPatch;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transactionImportBatch` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
  patch: TransactionImportBatchPatch;
};

/** The `transactionImportBatch` to be created by this mutation. */
export type FkTransactionImportBatchAccountAccountIdTransactionImportBatchCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  dateRangeMin: Scalars['Datetime'];
  dateRangeMax: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionImportBatchAccountAccountIdInput>;
  transactionsUsingId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type TransactionOnTransactionForFkTransactionAccountAccountIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `account` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `account` being updated. */
  patch: AccountPatch;
};

/** The `account` to be created by this mutation. */
export type FkTransactionAccountAccountIdAccountCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  institution?: Maybe<Scalars['String']>;
  details?: Maybe<Scalars['String']>;
  transactionsUsingId?: Maybe<FkTransactionAccountAccountIdInverseInput>;
  transactionImportBatchesUsingId?: Maybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type AccountOnTransactionForFkTransactionAccountAccountIdNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `transaction` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: TransactionPatch;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionAccountAccountIdTransactionCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The output of our create `Account` mutation. */
export type CreateAccountPayload = {
  __typename?: 'CreateAccountPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was created by this mutation. */
  account?: Maybe<Account>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our create `Account` mutation. */
export type CreateAccountPayloadAccountEdgeArgs = {
  orderBy?: Maybe<Array<AccountsOrderBy>>;
};

/** All input for the create `Agency` mutation. */
export type CreateAgencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agency` to be created by this mutation. */
  agency: AgencyInput;
};

/** An input for mutations affecting `Agency` */
export type AgencyInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  logoId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  mediaItemToLogoId?: Maybe<FkAgencyMediaItemLogoIdInput>;
  agencyMembersUsingId?: Maybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  tripsUsingId?: Maybe<FkTripAgencyAgencyIdInverseInput>;
};

/** The output of our create `Agency` mutation. */
export type CreateAgencyPayload = {
  __typename?: 'CreateAgencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agency` that was created by this mutation. */
  agency?: Maybe<Agency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  /** An edge for our `Agency`. May be used by Relay 1. */
  agencyEdge?: Maybe<AgenciesEdge>;
};


/** The output of our create `Agency` mutation. */
export type CreateAgencyPayloadAgencyEdgeArgs = {
  orderBy?: Maybe<Array<AgenciesOrderBy>>;
};

/** All input for the create `AgencyMember` mutation. */
export type CreateAgencyMemberInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgencyMember` to be created by this mutation. */
  agencyMember: AgencyMemberInput;
};

/** An input for mutations affecting `AgencyMember` */
export type AgencyMemberInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  genderPreposition?: Maybe<Scalars['String']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyToAgencyId?: Maybe<FkAgencyMemberAgencyAgencyIdInput>;
  tripsUsingId?: Maybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** The output of our create `AgencyMember` mutation. */
export type CreateAgencyMemberPayload = {
  __typename?: 'CreateAgencyMemberPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgencyMember` that was created by this mutation. */
  agencyMember?: Maybe<AgencyMember>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  /** An edge for our `AgencyMember`. May be used by Relay 1. */
  agencyMemberEdge?: Maybe<AgencyMembersEdge>;
};


/** The output of our create `AgencyMember` mutation. */
export type CreateAgencyMemberPayloadAgencyMemberEdgeArgs = {
  orderBy?: Maybe<Array<AgencyMembersOrderBy>>;
};

/** All input for the create `Airport` mutation. */
export type CreateAirportInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Airport` to be created by this mutation. */
  airport: AirportInput;
};

/** An input for mutations affecting `Airport` */
export type AirportInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iata?: Maybe<Scalars['String']>;
  icao?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  countryId?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  timezone?: Maybe<Scalars['String']>;
  countryToCountryId?: Maybe<FkAirportCountryCountryIdInput>;
  tripFlightsToDepartureAirportIdUsingId?: Maybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
  tripFlightsToArrivalAirportIdUsingId?: Maybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
};

/** The output of our create `Airport` mutation. */
export type CreateAirportPayload = {
  __typename?: 'CreateAirportPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Airport` that was created by this mutation. */
  airport?: Maybe<Airport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  /** An edge for our `Airport`. May be used by Relay 1. */
  airportEdge?: Maybe<AirportsEdge>;
};


/** The output of our create `Airport` mutation. */
export type CreateAirportPayloadAirportEdgeArgs = {
  orderBy?: Maybe<Array<AirportsOrderBy>>;
};

/** All input for the create `Country` mutation. */
export type CreateCountryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` to be created by this mutation. */
  country: CountryInput;
};

/** An input for mutations affecting `Country` */
export type CountryInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  iso2?: Maybe<Scalars['String']>;
  iso3?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  airportsUsingId?: Maybe<FkAirportCountryCountryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationCountryCountryIdInverseInput>;
  passportsUsingId?: Maybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The output of our create `Country` mutation. */
export type CreateCountryPayload = {
  __typename?: 'CreateCountryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was created by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our create `Country` mutation. */
export type CreateCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the create `Customer` mutation. */
export type CreateCustomerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` to be created by this mutation. */
  customer: CustomerInput;
};

/** An input for mutations affecting `Customer` */
export type CustomerInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  tripsUsingId?: Maybe<FkTripCustomerCustomerIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryCustomerCustomerIdInverseInput>;
};

/** The output of our create `Customer` mutation. */
export type CreateCustomerPayload = {
  __typename?: 'CreateCustomerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was created by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our create `Customer` mutation. */
export type CreateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the create `CustomerTraveller` mutation. */
export type CreateCustomerTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerTraveller` to be created by this mutation. */
  customerTraveller: CustomerTravellerInput;
};

/** An input for mutations affecting `CustomerTraveller` */
export type CustomerTravellerInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkCustomerTravellerCustomerCustomerIdInput>;
  travellerToTravellerId?: Maybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** The output of our create `CustomerTraveller` mutation. */
export type CreateCustomerTravellerPayload = {
  __typename?: 'CreateCustomerTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerTraveller` that was created by this mutation. */
  customerTraveller?: Maybe<CustomerTraveller>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
  /** An edge for our `CustomerTraveller`. May be used by Relay 1. */
  customerTravellerEdge?: Maybe<CustomerTravellersEdge>;
};


/** The output of our create `CustomerTraveller` mutation. */
export type CreateCustomerTravellerPayloadCustomerTravellerEdgeArgs = {
  orderBy?: Maybe<Array<CustomerTravellersOrderBy>>;
};

/** All input for the create `Destination` mutation. */
export type CreateDestinationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Destination` to be created by this mutation. */
  destination: DestinationInput;
};

/** An input for mutations affecting `Destination` */
export type DestinationInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  body?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  parentId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationMediaGalleryGalleryIdInput>;
  destinationToParentId?: Maybe<FkDestinationDestinationParentIdInput>;
  countryToCountryId?: Maybe<FkDestinationCountryCountryIdInput>;
  mediaItemToHeroMediaId?: Maybe<DestinationHeroMediaIdFkeyInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: Maybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The output of our create `Destination` mutation. */
export type CreateDestinationPayload = {
  __typename?: 'CreateDestinationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Destination` that was created by this mutation. */
  destination?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  /** An edge for our `Destination`. May be used by Relay 1. */
  destinationEdge?: Maybe<DestinationsEdge>;
};


/** The output of our create `Destination` mutation. */
export type CreateDestinationPayloadDestinationEdgeArgs = {
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
};

/** All input for the create `DestinationFeature` mutation. */
export type CreateDestinationFeatureInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationFeature` to be created by this mutation. */
  destinationFeature: DestinationFeatureInput;
};

/** An input for mutations affecting `DestinationFeature` */
export type DestinationFeatureInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  destinationId?: Maybe<Scalars['UUID']>;
  galleryId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationFeatureDestinationDestinationIdInput>;
  mediaGalleryToGalleryId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
};

/** The output of our create `DestinationFeature` mutation. */
export type CreateDestinationFeaturePayload = {
  __typename?: 'CreateDestinationFeaturePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationFeature` that was created by this mutation. */
  destinationFeature?: Maybe<DestinationFeature>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `DestinationFeature`. May be used by Relay 1. */
  destinationFeatureEdge?: Maybe<DestinationFeaturesEdge>;
};


/** The output of our create `DestinationFeature` mutation. */
export type CreateDestinationFeaturePayloadDestinationFeatureEdgeArgs = {
  orderBy?: Maybe<Array<DestinationFeaturesOrderBy>>;
};

/** All input for the create `DestinationGuide` mutation. */
export type CreateDestinationGuideInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationGuide` to be created by this mutation. */
  destinationGuide: DestinationGuideInput;
};

/** An input for mutations affecting `DestinationGuide` */
export type DestinationGuideInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  destinationId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  destinationToDestinationId?: Maybe<FkDestinationGuideDestinationDestinationIdInput>;
};

/** The output of our create `DestinationGuide` mutation. */
export type CreateDestinationGuidePayload = {
  __typename?: 'CreateDestinationGuidePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationGuide` that was created by this mutation. */
  destinationGuide?: Maybe<DestinationGuide>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
  /** An edge for our `DestinationGuide`. May be used by Relay 1. */
  destinationGuideEdge?: Maybe<DestinationGuidesEdge>;
};


/** The output of our create `DestinationGuide` mutation. */
export type CreateDestinationGuidePayloadDestinationGuideEdgeArgs = {
  orderBy?: Maybe<Array<DestinationGuidesOrderBy>>;
};

/** All input for the create `Email` mutation. */
export type CreateEmailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` to be created by this mutation. */
  email: EmailInput;
};

/** An input for mutations affecting `Email` */
export type EmailInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  notes?: Maybe<Scalars['String']>;
  recipients?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkEmailTripTripIdInput>;
  userToUserId?: Maybe<FkEmailUserUserIdInput>;
  customerToCustomerId?: Maybe<FkEmailCustomerCustomerIdInput>;
  quoteToQuoteId?: Maybe<FkEmailQuoteQuoteIdInput>;
};

/** The output of our create `Email` mutation. */
export type CreateEmailPayload = {
  __typename?: 'CreateEmailPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was created by this mutation. */
  email?: Maybe<Email>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our create `Email` mutation. */
export type CreateEmailPayloadEmailEdgeArgs = {
  orderBy?: Maybe<Array<EmailsOrderBy>>;
};

/** All input for the create `Enquiry` mutation. */
export type CreateEnquiryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Enquiry` to be created by this mutation. */
  enquiry: EnquiryInput;
};

/** An input for mutations affecting `Enquiry` */
export type EnquiryInput = {
  id?: Maybe<Scalars['UUID']>;
  comments?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  customerId?: Maybe<Scalars['UUID']>;
  dates?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  travellers?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  archived?: Maybe<Scalars['Datetime']>;
  customerToCustomerId?: Maybe<FkEnquiryCustomerCustomerIdInput>;
  tripToTripId?: Maybe<FkEnquiryTripTripIdInput>;
};

/** The output of our create `Enquiry` mutation. */
export type CreateEnquiryPayload = {
  __typename?: 'CreateEnquiryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Enquiry` that was created by this mutation. */
  enquiry?: Maybe<Enquiry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Enquiry`. May be used by Relay 1. */
  enquiryEdge?: Maybe<EnquiriesEdge>;
};


/** The output of our create `Enquiry` mutation. */
export type CreateEnquiryPayloadEnquiryEdgeArgs = {
  orderBy?: Maybe<Array<EnquiriesOrderBy>>;
};

/** All input for the create `Expense` mutation. */
export type CreateExpenseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Expense` to be created by this mutation. */
  expense: ExpenseInput;
};

/** An input for mutations affecting `Expense` */
export type ExpenseInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  reference?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  invoiceToInvoiceId?: Maybe<FkExpenseInvoiceInvoiceIdInput>;
  supplierToSupplierId?: Maybe<FkExpenseSupplierSupplierIdInput>;
  financeCategoryToCategoryId?: Maybe<FkExpenseFinanceCategoryCategoryIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  tripToTripId?: Maybe<FkExpenseTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
};

/** The output of our create `Expense` mutation. */
export type CreateExpensePayload = {
  __typename?: 'CreateExpensePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Expense` that was created by this mutation. */
  expense?: Maybe<Expense>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Expense`. May be used by Relay 1. */
  expenseEdge?: Maybe<ExpensesEdge>;
};


/** The output of our create `Expense` mutation. */
export type CreateExpensePayloadExpenseEdgeArgs = {
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
};

/** All input for the create `Feature` mutation. */
export type CreateFeatureInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Feature` to be created by this mutation. */
  feature: FeatureInput;
};

/** An input for mutations affecting `Feature` */
export type FeatureInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkFeatureMediaGalleryGalleryIdInput>;
};

/** The output of our create `Feature` mutation. */
export type CreateFeaturePayload = {
  __typename?: 'CreateFeaturePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Feature` that was created by this mutation. */
  feature?: Maybe<Feature>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `Feature`. May be used by Relay 1. */
  featureEdge?: Maybe<FeaturesEdge>;
};


/** The output of our create `Feature` mutation. */
export type CreateFeaturePayloadFeatureEdgeArgs = {
  orderBy?: Maybe<Array<FeaturesOrderBy>>;
};

/** All input for the create `FinanceCategory` mutation. */
export type CreateFinanceCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FinanceCategory` to be created by this mutation. */
  financeCategory: FinanceCategoryInput;
};

/** An input for mutations affecting `FinanceCategory` */
export type FinanceCategoryInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  expensesUsingId?: Maybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: Maybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
};

/** The output of our create `FinanceCategory` mutation. */
export type CreateFinanceCategoryPayload = {
  __typename?: 'CreateFinanceCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FinanceCategory` that was created by this mutation. */
  financeCategory?: Maybe<FinanceCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `FinanceCategory`. May be used by Relay 1. */
  financeCategoryEdge?: Maybe<FinanceCategoriesEdge>;
};


/** The output of our create `FinanceCategory` mutation. */
export type CreateFinanceCategoryPayloadFinanceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<FinanceCategoriesOrderBy>>;
};

/** All input for the create `Invoice` mutation. */
export type CreateInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` to be created by this mutation. */
  invoice: InvoiceInput;
};

/** An input for mutations affecting `Invoice` */
export type InvoiceInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  summary?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['Int']>;
  quoteId?: Maybe<Scalars['UUID']>;
  voided?: Maybe<Scalars['Datetime']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  paid?: Maybe<Scalars['Datetime']>;
  note?: Maybe<Scalars['String']>;
  invoiced?: Maybe<Scalars['Datetime']>;
  locked?: Maybe<Scalars['Datetime']>;
  quoteToQuoteId?: Maybe<FkInvoiceQuoteQuoteIdInput>;
  financeCategoryToCategoryId?: Maybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkInvoiceTripTripIdInput>;
  expensesUsingId?: Maybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
};

/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayload = {
  __typename?: 'CreateInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was created by this mutation. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
};

/** All input for the create `MapPoint` mutation. */
export type CreateMapPointInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MapPoint` to be created by this mutation. */
  mapPoint: MapPointInput;
};

/** An input for mutations affecting `MapPoint` */
export type MapPointInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  propertiesUsingId?: Maybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** The output of our create `MapPoint` mutation. */
export type CreateMapPointPayload = {
  __typename?: 'CreateMapPointPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MapPoint` that was created by this mutation. */
  mapPoint?: Maybe<MapPoint>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `MapPoint`. May be used by Relay 1. */
  mapPointEdge?: Maybe<MapPointsEdge>;
};


/** The output of our create `MapPoint` mutation. */
export type CreateMapPointPayloadMapPointEdgeArgs = {
  orderBy?: Maybe<Array<MapPointsOrderBy>>;
};

/** All input for the create `MediaGallery` mutation. */
export type CreateMediaGalleryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGallery` to be created by this mutation. */
  mediaGallery: MediaGalleryInput;
};

/** An input for mutations affecting `MediaGallery` */
export type MediaGalleryInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['UUID']>;
  isProtected?: Maybe<Scalars['Boolean']>;
  mediaGalleryToParentId?: Maybe<FkMediaGalleryMediaGalleryParentIdInput>;
  tripsUsingId?: Maybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
  destinationsUsingId?: Maybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  destinationFeaturesUsingId?: Maybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: Maybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: Maybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
};

/** The output of our create `MediaGallery` mutation. */
export type CreateMediaGalleryPayload = {
  __typename?: 'CreateMediaGalleryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGallery` that was created by this mutation. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  /** An edge for our `MediaGallery`. May be used by Relay 1. */
  mediaGalleryEdge?: Maybe<MediaGalleriesEdge>;
};


/** The output of our create `MediaGallery` mutation. */
export type CreateMediaGalleryPayloadMediaGalleryEdgeArgs = {
  orderBy?: Maybe<Array<MediaGalleriesOrderBy>>;
};

/** All input for the create `MediaGalleryItem` mutation. */
export type CreateMediaGalleryItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGalleryItem` to be created by this mutation. */
  mediaGalleryItem: MediaGalleryItemInput;
};

/** An input for mutations affecting `MediaGalleryItem` */
export type MediaGalleryItemInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  isHero?: Maybe<Scalars['Boolean']>;
  mediaGalleryToMediaGalleryId?: Maybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
};

/** The output of our create `MediaGalleryItem` mutation. */
export type CreateMediaGalleryItemPayload = {
  __typename?: 'CreateMediaGalleryItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGalleryItem` that was created by this mutation. */
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `MediaGalleryItem`. May be used by Relay 1. */
  mediaGalleryItemEdge?: Maybe<MediaGalleryItemsEdge>;
};


/** The output of our create `MediaGalleryItem` mutation. */
export type CreateMediaGalleryItemPayloadMediaGalleryItemEdgeArgs = {
  orderBy?: Maybe<Array<MediaGalleryItemsOrderBy>>;
};

/** All input for the create `MediaItem` mutation. */
export type CreateMediaItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaItem` to be created by this mutation. */
  mediaItem: MediaItemInput;
};

/** An input for mutations affecting `MediaItem` */
export type MediaItemInput = {
  id?: Maybe<Scalars['UUID']>;
  contentType?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  fileName?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  hash?: Maybe<Scalars['String']>;
  agenciesUsingId?: Maybe<FkAgencyMediaItemLogoIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
  destinationsUsingId?: Maybe<DestinationHeroMediaIdFkeyInverseInput>;
  mediaGalleryItemsUsingId?: Maybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  propertiesUsingId?: Maybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  quoteHeroesUsingId?: Maybe<FkQuoteHeroMediaItemImageIdInverseInput>;
};

/** The output of our create `MediaItem` mutation. */
export type CreateMediaItemPayload = {
  __typename?: 'CreateMediaItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaItem` that was created by this mutation. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `MediaItem`. May be used by Relay 1. */
  mediaItemEdge?: Maybe<MediaItemsEdge>;
};


/** The output of our create `MediaItem` mutation. */
export type CreateMediaItemPayloadMediaItemEdgeArgs = {
  orderBy?: Maybe<Array<MediaItemsOrderBy>>;
};

/** All input for the create `Note` mutation. */
export type CreateNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Note` to be created by this mutation. */
  note: NoteInput;
};

/** An input for mutations affecting `Note` */
export type NoteInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  title?: Maybe<Scalars['String']>;
  tripToTripId?: Maybe<FkNoteTripTripIdInput>;
  userToUserId?: Maybe<FkNoteUserUserIdInput>;
};

/** The output of our create `Note` mutation. */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Note` that was created by this mutation. */
  note?: Maybe<Note>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
  /** An edge for our `Note`. May be used by Relay 1. */
  noteEdge?: Maybe<NotesEdge>;
};


/** The output of our create `Note` mutation. */
export type CreateNotePayloadNoteEdgeArgs = {
  orderBy?: Maybe<Array<NotesOrderBy>>;
};

/** All input for the create `Passport` mutation. */
export type CreatePassportInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Passport` to be created by this mutation. */
  passport: PassportInput;
};

/** An input for mutations affecting `Passport` */
export type PassportInput = {
  id?: Maybe<Scalars['UUID']>;
  countryOfIssue?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  expiry: Scalars['Datetime'];
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['String']>;
  travellerId?: Maybe<Scalars['UUID']>;
  countryId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkPassportTravellerTravellerIdInput>;
  countryToCountryId?: Maybe<PassportCountry2IdFkeyInput>;
};

/** The output of our create `Passport` mutation. */
export type CreatePassportPayload = {
  __typename?: 'CreatePassportPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Passport` that was created by this mutation. */
  passport?: Maybe<Passport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
  /** An edge for our `Passport`. May be used by Relay 1. */
  passportEdge?: Maybe<PassportsEdge>;
};


/** The output of our create `Passport` mutation. */
export type CreatePassportPayloadPassportEdgeArgs = {
  orderBy?: Maybe<Array<PassportsOrderBy>>;
};

/** All input for the create `Payment` mutation. */
export type CreatePaymentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` to be created by this mutation. */
  payment: PaymentInput;
};

/** An input for mutations affecting `Payment` */
export type PaymentInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  amountActual: Scalars['BigFloat'];
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  modified?: Maybe<Scalars['Datetime']>;
  paid: Scalars['Datetime'];
  reference?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['Int']>;
  invoiceToInvoiceId?: Maybe<FkPaymentInvoiceInvoiceIdInput>;
  financeCategoryToCategoryId?: Maybe<FkPaymentFinanceCategoryCategoryIdInput>;
  tripToTripId?: Maybe<FkPaymentTripTripIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
};

/** The output of our create `Payment` mutation. */
export type CreatePaymentPayload = {
  __typename?: 'CreatePaymentPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was created by this mutation. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our create `Payment` mutation. */
export type CreatePaymentPayloadPaymentEdgeArgs = {
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
};

/** All input for the create `Property` mutation. */
export type CreatePropertyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Property` to be created by this mutation. */
  property: PropertyInput;
};

/** An input for mutations affecting `Property` */
export type PropertyInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  latitude?: Maybe<Scalars['Float']>;
  longitude?: Maybe<Scalars['Float']>;
  nearestAirport?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  externalReference?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  heroMediaId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mapPointId?: Maybe<Scalars['UUID']>;
  plusCode?: Maybe<Scalars['String']>;
  countryId?: Maybe<Scalars['UUID']>;
  featured?: Maybe<Scalars['Datetime']>;
  featureCopy?: Maybe<Scalars['String']>;
  mediaGalleryToGalleryId?: Maybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: Maybe<FkPropertyMediaItemHeroMediaIdInput>;
  mapPointToMapPointId?: Maybe<FkPropertyMapPointMapPointIdInput>;
  countryToCountryId?: Maybe<FkPropertyCountryCountryIdInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: Maybe<QuoteDayPropertyIdFkeyInverseInput>;
};

/** The output of our create `Property` mutation. */
export type CreatePropertyPayload = {
  __typename?: 'CreatePropertyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Property` that was created by this mutation. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
};


/** The output of our create `Property` mutation. */
export type CreatePropertyPayloadPropertyEdgeArgs = {
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
};

/** All input for the create `Quote` mutation. */
export type CreateQuoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` to be created by this mutation. */
  quote: QuoteInput;
};

/** An input for mutations affecting `Quote` */
export type QuoteInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  duration: Scalars['Int'];
  modified?: Maybe<Scalars['Datetime']>;
  start?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  deposit?: Maybe<Scalars['BigFloat']>;
  margin?: Maybe<Scalars['BigFloat']>;
  key?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  total?: Maybe<Scalars['BigFloat']>;
  adjustment?: Maybe<Scalars['BigFloat']>;
  baseCurrency?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  heroImageId?: Maybe<Scalars['UUID']>;
  exclusions?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  agentMargin?: Maybe<Scalars['BigFloat']>;
  travellerCount?: Maybe<Scalars['Int']>;
  archived?: Maybe<Scalars['Datetime']>;
  lastViewed?: Maybe<Scalars['Datetime']>;
  heroId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  tripToTripId?: Maybe<FkQuoteTripTripIdInput>;
  mediaItemToHeroImageId?: Maybe<FkQuoteMediaItemHeroImageIdInput>;
  quoteHeroToHeroId?: Maybe<FkQuoteQuoteHeroHeroIdInput>;
  userToUserId?: Maybe<FkQuoteUserUserIdInput>;
  invoicesUsingId?: Maybe<FkInvoiceQuoteQuoteIdInverseInput>;
  tripsUsingId?: Maybe<FkTripQuoteActiveQuoteIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailQuoteQuoteIdInverseInput>;
  quoteViewsUsingId?: Maybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  quoteAccommodationDetailsUsingId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
};

/** The output of our create `Quote` mutation. */
export type CreateQuotePayload = {
  __typename?: 'CreateQuotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was created by this mutation. */
  quote?: Maybe<Quote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our create `Quote` mutation. */
export type CreateQuotePayloadQuoteEdgeArgs = {
  orderBy?: Maybe<Array<QuotesOrderBy>>;
};

/** All input for the create `QuoteView` mutation. */
export type CreateQuoteViewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteView` to be created by this mutation. */
  quoteView: QuoteViewInput;
};

/** An input for mutations affecting `QuoteView` */
export type QuoteViewInput = {
  id?: Maybe<Scalars['UUID']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  quoteId?: Maybe<Scalars['UUID']>;
  timezone?: Maybe<Scalars['String']>;
  userIp?: Maybe<Scalars['String']>;
  viewType?: Maybe<Scalars['String']>;
  quoteToQuoteId?: Maybe<FkQuoteViewQuoteQuoteIdInput>;
};

/** The output of our create `QuoteView` mutation. */
export type CreateQuoteViewPayload = {
  __typename?: 'CreateQuoteViewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteView` that was created by this mutation. */
  quoteView?: Maybe<QuoteView>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
  /** An edge for our `QuoteView`. May be used by Relay 1. */
  quoteViewEdge?: Maybe<QuoteViewsEdge>;
};


/** The output of our create `QuoteView` mutation. */
export type CreateQuoteViewPayloadQuoteViewEdgeArgs = {
  orderBy?: Maybe<Array<QuoteViewsOrderBy>>;
};

/** All input for the create `QuoteAccommodationDetail` mutation. */
export type CreateQuoteAccommodationDetailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteAccommodationDetail` to be created by this mutation. */
  quoteAccommodationDetail: QuoteAccommodationDetailInput;
};

/** An input for mutations affecting `QuoteAccommodationDetail` */
export type QuoteAccommodationDetailInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  nights: Scalars['Int'];
  notes?: Maybe<Scalars['String']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  basis?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  confirmation?: Maybe<Scalars['String']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']>>>;
  roomType?: Maybe<Scalars['String']>;
  propertyToPropertyId?: Maybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  quotePublic?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteDaysUsingId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
};

/** The output of our create `QuoteAccommodationDetail` mutation. */
export type CreateQuoteAccommodationDetailPayload = {
  __typename?: 'CreateQuoteAccommodationDetailPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteAccommodationDetail` that was created by this mutation. */
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuoteAccommodationDetail`. May be used by Relay 1. */
  quoteAccommodationDetailEdge?: Maybe<QuoteAccommodationDetailsEdge>;
};


/** The output of our create `QuoteAccommodationDetail` mutation. */
export type CreateQuoteAccommodationDetailPayloadQuoteAccommodationDetailEdgeArgs = {
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
};

/** All input for the create `QuoteCurrency` mutation. */
export type CreateQuoteCurrencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteCurrency` to be created by this mutation. */
  quoteCurrency: QuoteCurrencyInput;
};

/** An input for mutations affecting `QuoteCurrency` */
export type QuoteCurrencyInput = {
  id?: Maybe<Scalars['UUID']>;
  code?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  rate: Scalars['BigFloat'];
  quoteToQuoteId?: Maybe<FkQuoteCurrencyQuoteQuoteIdInput>;
};

/** The output of our create `QuoteCurrency` mutation. */
export type CreateQuoteCurrencyPayload = {
  __typename?: 'CreateQuoteCurrencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteCurrency` that was created by this mutation. */
  quoteCurrency?: Maybe<QuoteCurrency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
  /** An edge for our `QuoteCurrency`. May be used by Relay 1. */
  quoteCurrencyEdge?: Maybe<QuoteCurrenciesEdge>;
};


/** The output of our create `QuoteCurrency` mutation. */
export type CreateQuoteCurrencyPayloadQuoteCurrencyEdgeArgs = {
  orderBy?: Maybe<Array<QuoteCurrenciesOrderBy>>;
};

/** All input for the create `QuoteDay` mutation. */
export type CreateQuoteDayInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDay` to be created by this mutation. */
  quoteDay: QuoteDayInput;
};

/** An input for mutations affecting `QuoteDay` */
export type QuoteDayInput = {
  id?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  date?: Maybe<Scalars['Datetime']>;
  activitySummary?: Maybe<Scalars['String']>;
  activityDetail?: Maybe<Scalars['String']>;
  accommodationId?: Maybe<Scalars['UUID']>;
  quoteId?: Maybe<Scalars['UUID']>;
  propertyId?: Maybe<Scalars['UUID']>;
  quoteAccommodationDetailToAccommodationId?: Maybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteToQuoteId?: Maybe<FkQuoteDayQuoteQuoteIdInput>;
  propertyToPropertyId?: Maybe<QuoteDayPropertyIdFkeyInput>;
  quotePublic?: Maybe<FakePublicQuoteDayForeignKey0Input>;
  quoteDayDestinationsUsingId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
};

/** The output of our create `QuoteDay` mutation. */
export type CreateQuoteDayPayload = {
  __typename?: 'CreateQuoteDayPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDay` that was created by this mutation. */
  quoteDay?: Maybe<QuoteDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuoteDay`. May be used by Relay 1. */
  quoteDayEdge?: Maybe<QuoteDaysEdge>;
};


/** The output of our create `QuoteDay` mutation. */
export type CreateQuoteDayPayloadQuoteDayEdgeArgs = {
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
};

/** All input for the create `QuoteDayDestination` mutation. */
export type CreateQuoteDayDestinationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDayDestination` to be created by this mutation. */
  quoteDayDestination: QuoteDayDestinationInput;
};

/** An input for mutations affecting `QuoteDayDestination` */
export type QuoteDayDestinationInput = {
  id?: Maybe<Scalars['UUID']>;
  destinationId?: Maybe<Scalars['UUID']>;
  dayId?: Maybe<Scalars['UUID']>;
  order: Scalars['Int'];
  destinationToDestinationId?: Maybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  quoteDayToDayId?: Maybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
};

/** The output of our create `QuoteDayDestination` mutation. */
export type CreateQuoteDayDestinationPayload = {
  __typename?: 'CreateQuoteDayDestinationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDayDestination` that was created by this mutation. */
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
  /** An edge for our `QuoteDayDestination`. May be used by Relay 1. */
  quoteDayDestinationEdge?: Maybe<QuoteDayDestinationsEdge>;
};


/** The output of our create `QuoteDayDestination` mutation. */
export type CreateQuoteDayDestinationPayloadQuoteDayDestinationEdgeArgs = {
  orderBy?: Maybe<Array<QuoteDayDestinationsOrderBy>>;
};

/** All input for the create `QuoteFinanceLineItem` mutation. */
export type CreateQuoteFinanceLineItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteFinanceLineItem` to be created by this mutation. */
  quoteFinanceLineItem: QuoteFinanceLineItemInput;
};

/** An input for mutations affecting `QuoteFinanceLineItem` */
export type QuoteFinanceLineItemInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  currency?: Maybe<Scalars['String']>;
  quoteId?: Maybe<Scalars['UUID']>;
  supplierId?: Maybe<Scalars['UUID']>;
  confirmation?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  excludeMargin?: Maybe<Scalars['Boolean']>;
  notes?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  order: Scalars['Int'];
  marginOverride?: Maybe<Scalars['BigFloat']>;
  quoteToQuoteId?: Maybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  supplierToSupplierId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The output of our create `QuoteFinanceLineItem` mutation. */
export type CreateQuoteFinanceLineItemPayload = {
  __typename?: 'CreateQuoteFinanceLineItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteFinanceLineItem` that was created by this mutation. */
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
  /** An edge for our `QuoteFinanceLineItem`. May be used by Relay 1. */
  quoteFinanceLineItemEdge?: Maybe<QuoteFinanceLineItemsEdge>;
};


/** The output of our create `QuoteFinanceLineItem` mutation. */
export type CreateQuoteFinanceLineItemPayloadQuoteFinanceLineItemEdgeArgs = {
  orderBy?: Maybe<Array<QuoteFinanceLineItemsOrderBy>>;
};

/** All input for the create `QuoteHero` mutation. */
export type CreateQuoteHeroInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteHero` to be created by this mutation. */
  quoteHero: QuoteHeroInput;
};

/** An input for mutations affecting `QuoteHero` */
export type QuoteHeroInput = {
  id?: Maybe<Scalars['UUID']>;
  title?: Maybe<Scalars['String']>;
  subtitle?: Maybe<Scalars['String']>;
  imageId?: Maybe<Scalars['UUID']>;
  style?: Maybe<Scalars['String']>;
  mediaItemToImageId?: Maybe<FkQuoteHeroMediaItemImageIdInput>;
  quotesUsingId?: Maybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey1InverseInput>;
};

/** The output of our create `QuoteHero` mutation. */
export type CreateQuoteHeroPayload = {
  __typename?: 'CreateQuoteHeroPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteHero` that was created by this mutation. */
  quoteHero?: Maybe<QuoteHero>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  /** An edge for our `QuoteHero`. May be used by Relay 1. */
  quoteHeroEdge?: Maybe<QuoteHeroesEdge>;
};


/** The output of our create `QuoteHero` mutation. */
export type CreateQuoteHeroPayloadQuoteHeroEdgeArgs = {
  orderBy?: Maybe<Array<QuoteHeroesOrderBy>>;
};

/** All input for the create `QuotePublic` mutation. */
export type CreateQuotePublicInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuotePublic` to be created by this mutation. */
  quotePublic: QuotePublicInput;
};

/** An input for mutations affecting `QuotePublic` */
export type QuotePublicInput = {
  id?: Maybe<Scalars['UUID']>;
  key: Scalars['String'];
  status?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  duration?: Maybe<Scalars['Int']>;
  travellerCount?: Maybe<Scalars['Int']>;
  total?: Maybe<Scalars['BigFloat']>;
  heroId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  locked?: Maybe<Scalars['Datetime']>;
  baseCurrency?: Maybe<Scalars['String']>;
  inclusions?: Maybe<Scalars['String']>;
  exclusions?: Maybe<Scalars['String']>;
  expires?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FakePublicQuotePublicForeignKey0Input>;
  quoteHeroToHeroId?: Maybe<FakePublicQuotePublicForeignKey1Input>;
  userToUserId?: Maybe<FakePublicQuotePublicForeignKey2Input>;
  quoteAccommodationDetailsUsingId?: Maybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: Maybe<FakePublicQuoteDayForeignKey0InverseInput>;
};

/** The output of our create `QuotePublic` mutation. */
export type CreateQuotePublicPayload = {
  __typename?: 'CreateQuotePublicPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuotePublic` that was created by this mutation. */
  quotePublic?: Maybe<QuotePublic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
  /** An edge for our `QuotePublic`. May be used by Relay 1. */
  quotePublicEdge?: Maybe<QuotePublicsEdge>;
};


/** The output of our create `QuotePublic` mutation. */
export type CreateQuotePublicPayloadQuotePublicEdgeArgs = {
  orderBy?: Maybe<Array<QuotePublicsOrderBy>>;
};

/** All input for the create `Reminder` mutation. */
export type CreateReminderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reminder` to be created by this mutation. */
  reminder: ReminderInput;
};

/** An input for mutations affecting `Reminder` */
export type ReminderInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  userId?: Maybe<Scalars['UUID']>;
  userToUserId?: Maybe<FkReminderUserUserIdInput>;
};

/** The output of our create `Reminder` mutation. */
export type CreateReminderPayload = {
  __typename?: 'CreateReminderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reminder` that was created by this mutation. */
  reminder?: Maybe<Reminder>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
};


/** The output of our create `Reminder` mutation. */
export type CreateReminderPayloadReminderEdgeArgs = {
  orderBy?: Maybe<Array<RemindersOrderBy>>;
};

/** All input for the create `Supplier` mutation. */
export type CreateSupplierInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Supplier` to be created by this mutation. */
  supplier: SupplierInput;
};

/** An input for mutations affecting `Supplier` */
export type SupplierInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  contactEmail?: Maybe<Scalars['String']>;
  contactNumber?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  bankDetails?: Maybe<Scalars['String']>;
  galleryId?: Maybe<Scalars['UUID']>;
  mediaGalleryToGalleryId?: Maybe<FkSupplierMediaGalleryGalleryIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierSupplierIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  quoteFinanceLineItemsUsingId?: Maybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
};

/** The output of our create `Supplier` mutation. */
export type CreateSupplierPayload = {
  __typename?: 'CreateSupplierPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Supplier` that was created by this mutation. */
  supplier?: Maybe<Supplier>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `Supplier`. May be used by Relay 1. */
  supplierEdge?: Maybe<SuppliersEdge>;
};


/** The output of our create `Supplier` mutation. */
export type CreateSupplierPayloadSupplierEdgeArgs = {
  orderBy?: Maybe<Array<SuppliersOrderBy>>;
};

/** All input for the create `SupplierInvoice` mutation. */
export type CreateSupplierInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SupplierInvoice` to be created by this mutation. */
  supplierInvoice: SupplierInvoiceInput;
};

/** An input for mutations affecting `SupplierInvoice` */
export type SupplierInvoiceInput = {
  id?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  categoryId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  currency?: Maybe<Scalars['String']>;
  due: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  number?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  supplierId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  type?: Maybe<Scalars['String']>;
  voided?: Maybe<Scalars['Datetime']>;
  amountActual?: Maybe<Scalars['BigFloat']>;
  paid?: Maybe<Scalars['Datetime']>;
  mediaItemId?: Maybe<Scalars['UUID']>;
  financeCategoryToCategoryId?: Maybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  supplierToSupplierId?: Maybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  tripToTripId?: Maybe<FkSupplierInvoiceTripTripIdInput>;
  mediaItemToMediaItemId?: Maybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  expensesUsingId?: Maybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
};

/** The output of our create `SupplierInvoice` mutation. */
export type CreateSupplierInvoicePayload = {
  __typename?: 'CreateSupplierInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SupplierInvoice` that was created by this mutation. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `SupplierInvoice`. May be used by Relay 1. */
  supplierInvoiceEdge?: Maybe<SupplierInvoicesEdge>;
};


/** The output of our create `SupplierInvoice` mutation. */
export type CreateSupplierInvoicePayloadSupplierInvoiceEdgeArgs = {
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
};

/** All input for the create `Testimonial` mutation. */
export type CreateTestimonialInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Testimonial` to be created by this mutation. */
  testimonial: TestimonialInput;
};

/** An input for mutations affecting `Testimonial` */
export type TestimonialInput = {
  id?: Maybe<Scalars['UUID']>;
  body?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  guestName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  tripId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTestimonialTripTripIdInput>;
};

/** The output of our create `Testimonial` mutation. */
export type CreateTestimonialPayload = {
  __typename?: 'CreateTestimonialPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Testimonial` that was created by this mutation. */
  testimonial?: Maybe<Testimonial>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Testimonial`. May be used by Relay 1. */
  testimonialEdge?: Maybe<TestimonialsEdge>;
};


/** The output of our create `Testimonial` mutation. */
export type CreateTestimonialPayloadTestimonialEdgeArgs = {
  orderBy?: Maybe<Array<TestimonialsOrderBy>>;
};

/** All input for the create `Transaction` mutation. */
export type CreateTransactionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` to be created by this mutation. */
  transaction: TransactionInput;
};

/** An input for mutations affecting `Transaction` */
export type TransactionInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  amount: Scalars['BigFloat'];
  externalId?: Maybe<Scalars['String']>;
  date: Scalars['Datetime'];
  description?: Maybe<Scalars['String']>;
  status: Scalars['Int'];
  reverseTransactionId?: Maybe<Scalars['UUID']>;
  source?: Maybe<Scalars['String']>;
  transactionImportBatchId?: Maybe<Scalars['UUID']>;
  balance?: Maybe<Scalars['BigFloat']>;
  currency?: Maybe<Scalars['String']>;
  categoryId?: Maybe<Scalars['UUID']>;
  accountToAccountId?: Maybe<FkTransactionAccountAccountIdInput>;
  transactionToReverseTransactionId?: Maybe<FkTransactionTransactionReverseTransactionIdInput>;
  transactionImportBatchToTransactionImportBatchId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  financeCategoryToCategoryId?: Maybe<FkTransactionFinanceCategoryCategoryIdInput>;
  transactionLinksUsingId?: Maybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
};

/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayload = {
  __typename?: 'CreateTransactionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was created by this mutation. */
  transaction?: Maybe<Transaction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayloadTransactionEdgeArgs = {
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
};

/** All input for the create `TransactionImportBatch` mutation. */
export type CreateTransactionImportBatchInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionImportBatch` to be created by this mutation. */
  transactionImportBatch: TransactionImportBatchInput;
};

/** An input for mutations affecting `TransactionImportBatch` */
export type TransactionImportBatchInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  accountId?: Maybe<Scalars['UUID']>;
  dateRangeMin: Scalars['Datetime'];
  dateRangeMax: Scalars['Datetime'];
  key?: Maybe<Scalars['String']>;
  accountToAccountId?: Maybe<FkTransactionImportBatchAccountAccountIdInput>;
  transactionsUsingId?: Maybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** The output of our create `TransactionImportBatch` mutation. */
export type CreateTransactionImportBatchPayload = {
  __typename?: 'CreateTransactionImportBatchPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionImportBatch` that was created by this mutation. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  /** An edge for our `TransactionImportBatch`. May be used by Relay 1. */
  transactionImportBatchEdge?: Maybe<TransactionImportBatchesEdge>;
};


/** The output of our create `TransactionImportBatch` mutation. */
export type CreateTransactionImportBatchPayloadTransactionImportBatchEdgeArgs = {
  orderBy?: Maybe<Array<TransactionImportBatchesOrderBy>>;
};

/** All input for the create `TransactionLink` mutation. */
export type CreateTransactionLinkInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionLink` to be created by this mutation. */
  transactionLink: TransactionLinkInput;
};

/** An input for mutations affecting `TransactionLink` */
export type TransactionLinkInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  transactionId?: Maybe<Scalars['UUID']>;
  invoiceId?: Maybe<Scalars['UUID']>;
  supplierInvoiceId?: Maybe<Scalars['UUID']>;
  paymentId?: Maybe<Scalars['UUID']>;
  expenseId?: Maybe<Scalars['UUID']>;
  status?: Maybe<Scalars['Int']>;
  transactionToTransactionId?: Maybe<FkTransactionLinkTransactionTransactionIdInput>;
  invoiceToInvoiceId?: Maybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  supplierInvoiceToSupplierInvoiceId?: Maybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  paymentToPaymentId?: Maybe<FkTransactionLinkPaymentPaymentIdInput>;
  expenseToExpenseId?: Maybe<FkTransactionLinkExpenseExpenseIdInput>;
};

/** The output of our create `TransactionLink` mutation. */
export type CreateTransactionLinkPayload = {
  __typename?: 'CreateTransactionLinkPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionLink` that was created by this mutation. */
  transactionLink?: Maybe<TransactionLink>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
  /** An edge for our `TransactionLink`. May be used by Relay 1. */
  transactionLinkEdge?: Maybe<TransactionLinksEdge>;
};


/** The output of our create `TransactionLink` mutation. */
export type CreateTransactionLinkPayloadTransactionLinkEdgeArgs = {
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
};

/** All input for the create `TransactionNote` mutation. */
export type CreateTransactionNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionNote` to be created by this mutation. */
  transactionNote: TransactionNoteInput;
};

/** An input for mutations affecting `TransactionNote` */
export type TransactionNoteInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  userId?: Maybe<Scalars['UUID']>;
  message?: Maybe<Scalars['String']>;
  transactionId?: Maybe<Scalars['UUID']>;
  userToUserId?: Maybe<FkTransactionNoteUserUserIdInput>;
  transactionToTransactionId?: Maybe<FkTransactionNoteTransactionTransactionIdInput>;
};

/** The output of our create `TransactionNote` mutation. */
export type CreateTransactionNotePayload = {
  __typename?: 'CreateTransactionNotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionNote` that was created by this mutation. */
  transactionNote?: Maybe<TransactionNote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
  /** An edge for our `TransactionNote`. May be used by Relay 1. */
  transactionNoteEdge?: Maybe<TransactionNotesEdge>;
};


/** The output of our create `TransactionNote` mutation. */
export type CreateTransactionNotePayloadTransactionNoteEdgeArgs = {
  orderBy?: Maybe<Array<TransactionNotesOrderBy>>;
};

/** All input for the create `Traveller` mutation. */
export type CreateTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Traveller` to be created by this mutation. */
  traveller: TravellerInput;
};

/** An input for mutations affecting `Traveller` */
export type TravellerInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  dateOfBirth?: Maybe<Scalars['Datetime']>;
  dietaryRequirements?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  medicalConditions?: Maybe<Scalars['String']>;
  middleName?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Datetime']>;
  nationality?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['Int']>;
  emergencyContact?: Maybe<Scalars['String']>;
  insuranceDetails?: Maybe<Scalars['String']>;
  customerTravellersUsingId?: Maybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  passportsUsingId?: Maybe<FkPassportTravellerTravellerIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTravellerTravellerIdInverseInput>;
};

/** The output of our create `Traveller` mutation. */
export type CreateTravellerPayload = {
  __typename?: 'CreateTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Traveller` that was created by this mutation. */
  traveller?: Maybe<Traveller>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Traveller`. May be used by Relay 1. */
  travellerEdge?: Maybe<TravellersEdge>;
};


/** The output of our create `Traveller` mutation. */
export type CreateTravellerPayloadTravellerEdgeArgs = {
  orderBy?: Maybe<Array<TravellersOrderBy>>;
};

/** All input for the create `Trip` mutation. */
export type CreateTripInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Trip` to be created by this mutation. */
  trip: TripInput;
};

/** An input for mutations affecting `Trip` */
export type TripInput = {
  id?: Maybe<Scalars['UUID']>;
  customerId?: Maybe<Scalars['UUID']>;
  userId?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  destination?: Maybe<Scalars['String']>;
  dates?: Maybe<Scalars['String']>;
  archived?: Maybe<Scalars['Datetime']>;
  mediaGalleryId?: Maybe<Scalars['UUID']>;
  activeQuoteId?: Maybe<Scalars['UUID']>;
  baseCurrency?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['Int']>;
  start?: Maybe<Scalars['Datetime']>;
  status?: Maybe<Scalars['Int']>;
  agencyId?: Maybe<Scalars['UUID']>;
  agencyMemberId?: Maybe<Scalars['UUID']>;
  customerToCustomerId?: Maybe<FkTripCustomerCustomerIdInput>;
  userToUserId?: Maybe<FkTripUserUserIdInput>;
  mediaGalleryToMediaGalleryId?: Maybe<FkTripMediaGalleryMediaGalleryIdInput>;
  quoteToActiveQuoteId?: Maybe<FkTripQuoteActiveQuoteIdInput>;
  agencyToAgencyId?: Maybe<FkTripAgencyAgencyIdInput>;
  agencyMemberToAgencyMemberId?: Maybe<FkTripAgencyMemberAgencyMemberIdInput>;
  expensesUsingId?: Maybe<FkExpenseTripTripIdInverseInput>;
  invoicesUsingId?: Maybe<FkInvoiceTripTripIdInverseInput>;
  paymentsUsingId?: Maybe<FkPaymentTripTripIdInverseInput>;
  supplierInvoicesUsingId?: Maybe<FkSupplierInvoiceTripTripIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: Maybe<FkEnquiryTripTripIdInverseInput>;
  notesUsingId?: Maybe<FkNoteTripTripIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteTripTripIdInverseInput>;
  testimonialsUsingId?: Maybe<FkTestimonialTripTripIdInverseInput>;
  tripTravellersUsingId?: Maybe<FkTripTravellerTripTripIdInverseInput>;
  tripFlightsUsingId?: Maybe<FkTripFlightTripTripIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey0InverseInput>;
};

/** The output of our create `Trip` mutation. */
export type CreateTripPayload = {
  __typename?: 'CreateTripPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Trip` that was created by this mutation. */
  trip?: Maybe<Trip>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  /** An edge for our `Trip`. May be used by Relay 1. */
  tripEdge?: Maybe<TripsEdge>;
};


/** The output of our create `Trip` mutation. */
export type CreateTripPayloadTripEdgeArgs = {
  orderBy?: Maybe<Array<TripsOrderBy>>;
};

/** All input for the create `TripTraveller` mutation. */
export type CreateTripTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripTraveller` to be created by this mutation. */
  tripTraveller: TripTravellerInput;
};

/** An input for mutations affecting `TripTraveller` */
export type TripTravellerInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  travellerId?: Maybe<Scalars['UUID']>;
  tripId?: Maybe<Scalars['UUID']>;
  travellerToTravellerId?: Maybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: Maybe<FkTripTravellerTripTripIdInput>;
};

/** The output of our create `TripTraveller` mutation. */
export type CreateTripTravellerPayload = {
  __typename?: 'CreateTripTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripTraveller` that was created by this mutation. */
  tripTraveller?: Maybe<TripTraveller>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
  /** An edge for our `TripTraveller`. May be used by Relay 1. */
  tripTravellerEdge?: Maybe<TripTravellersEdge>;
};


/** The output of our create `TripTraveller` mutation. */
export type CreateTripTravellerPayloadTripTravellerEdgeArgs = {
  orderBy?: Maybe<Array<TripTravellersOrderBy>>;
};

/** All input for the create `TripFlight` mutation. */
export type CreateTripFlightInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripFlight` to be created by this mutation. */
  tripFlight: TripFlightInput;
};

/** An input for mutations affecting `TripFlight` */
export type TripFlightInput = {
  id?: Maybe<Scalars['UUID']>;
  arrival: Scalars['Datetime'];
  carrier?: Maybe<Scalars['String']>;
  departure: Scalars['Datetime'];
  notes?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  tripId?: Maybe<Scalars['UUID']>;
  departureAirportId?: Maybe<Scalars['UUID']>;
  arrivalAirportId?: Maybe<Scalars['UUID']>;
  tripToTripId?: Maybe<FkTripFlightTripTripIdInput>;
  airportToDepartureAirportId?: Maybe<TripFlightDepartureAirport2IdFkeyInput>;
  airportToArrivalAirportId?: Maybe<TripFlightArrivalAirport2IdFkeyInput>;
};

/** The output of our create `TripFlight` mutation. */
export type CreateTripFlightPayload = {
  __typename?: 'CreateTripFlightPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripFlight` that was created by this mutation. */
  tripFlight?: Maybe<TripFlight>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
  /** An edge for our `TripFlight`. May be used by Relay 1. */
  tripFlightEdge?: Maybe<TripFlightsEdge>;
};


/** The output of our create `TripFlight` mutation. */
export type CreateTripFlightPayloadTripFlightEdgeArgs = {
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: Maybe<Scalars['UUID']>;
  email?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  skype?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  genderPreposition?: Maybe<Scalars['String']>;
  externalId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  tripsUsingId?: Maybe<FkTripUserUserIdInverseInput>;
  emailsUsingId?: Maybe<FkEmailUserUserIdInverseInput>;
  notesUsingId?: Maybe<FkNoteUserUserIdInverseInput>;
  quotesUsingId?: Maybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: Maybe<FkReminderUserUserIdInverseInput>;
  transactionNotesUsingId?: Maybe<FkTransactionNoteUserUserIdInverseInput>;
  quotePublicsUsingId?: Maybe<FakePublicQuotePublicForeignKey2InverseInput>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the create `VisaRequirement` mutation. */
export type CreateVisaRequirementInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VisaRequirement` to be created by this mutation. */
  visaRequirement: VisaRequirementInput;
};

/** An input for mutations affecting `VisaRequirement` */
export type VisaRequirementInput = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  lastVerified: Scalars['Datetime'];
  destinationCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  passportCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  detail?: Maybe<Scalars['String']>;
};

/** The output of our create `VisaRequirement` mutation. */
export type CreateVisaRequirementPayload = {
  __typename?: 'CreateVisaRequirementPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VisaRequirement` that was created by this mutation. */
  visaRequirement?: Maybe<VisaRequirement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VisaRequirement`. May be used by Relay 1. */
  visaRequirementEdge?: Maybe<VisaRequirementsEdge>;
};


/** The output of our create `VisaRequirement` mutation. */
export type CreateVisaRequirementPayloadVisaRequirementEdgeArgs = {
  orderBy?: Maybe<Array<VisaRequirementsOrderBy>>;
};

/** All input for the `updateAccountByNodeId` mutation. */
export type UpdateAccountByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Account` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Account` being updated. */
  patch: AccountPatch;
};

/** The output of our update `Account` mutation. */
export type UpdateAccountPayload = {
  __typename?: 'UpdateAccountPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was updated by this mutation. */
  account?: Maybe<Account>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our update `Account` mutation. */
export type UpdateAccountPayloadAccountEdgeArgs = {
  orderBy?: Maybe<Array<AccountsOrderBy>>;
};

/** All input for the `updateAccount` mutation. */
export type UpdateAccountInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Account` being updated. */
  patch: AccountPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateAgencyByNodeId` mutation. */
export type UpdateAgencyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Agency` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Agency` being updated. */
  patch: AgencyPatch;
};

/** The output of our update `Agency` mutation. */
export type UpdateAgencyPayload = {
  __typename?: 'UpdateAgencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agency` that was updated by this mutation. */
  agency?: Maybe<Agency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  /** An edge for our `Agency`. May be used by Relay 1. */
  agencyEdge?: Maybe<AgenciesEdge>;
};


/** The output of our update `Agency` mutation. */
export type UpdateAgencyPayloadAgencyEdgeArgs = {
  orderBy?: Maybe<Array<AgenciesOrderBy>>;
};

/** All input for the `updateAgency` mutation. */
export type UpdateAgencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Agency` being updated. */
  patch: AgencyPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateAgencyMemberByNodeId` mutation. */
export type UpdateAgencyMemberByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AgencyMember` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AgencyMember` being updated. */
  patch: AgencyMemberPatch;
};

/** The output of our update `AgencyMember` mutation. */
export type UpdateAgencyMemberPayload = {
  __typename?: 'UpdateAgencyMemberPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgencyMember` that was updated by this mutation. */
  agencyMember?: Maybe<AgencyMember>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  /** An edge for our `AgencyMember`. May be used by Relay 1. */
  agencyMemberEdge?: Maybe<AgencyMembersEdge>;
};


/** The output of our update `AgencyMember` mutation. */
export type UpdateAgencyMemberPayloadAgencyMemberEdgeArgs = {
  orderBy?: Maybe<Array<AgencyMembersOrderBy>>;
};

/** All input for the `updateAgencyMember` mutation. */
export type UpdateAgencyMemberInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `AgencyMember` being updated. */
  patch: AgencyMemberPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateAirportByNodeId` mutation. */
export type UpdateAirportByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Airport` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Airport` being updated. */
  patch: AirportPatch;
};

/** The output of our update `Airport` mutation. */
export type UpdateAirportPayload = {
  __typename?: 'UpdateAirportPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Airport` that was updated by this mutation. */
  airport?: Maybe<Airport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  /** An edge for our `Airport`. May be used by Relay 1. */
  airportEdge?: Maybe<AirportsEdge>;
};


/** The output of our update `Airport` mutation. */
export type UpdateAirportPayloadAirportEdgeArgs = {
  orderBy?: Maybe<Array<AirportsOrderBy>>;
};

/** All input for the `updateAirport` mutation. */
export type UpdateAirportInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Airport` being updated. */
  patch: AirportPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateCountryByNodeId` mutation. */
export type UpdateCountryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Country` being updated. */
  patch: CountryPatch;
};

/** The output of our update `Country` mutation. */
export type UpdateCountryPayload = {
  __typename?: 'UpdateCountryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was updated by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our update `Country` mutation. */
export type UpdateCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the `updateCountry` mutation. */
export type UpdateCountryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Country` being updated. */
  patch: CountryPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateCustomerByNodeId` mutation. */
export type UpdateCustomerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Customer` being updated. */
  patch: CustomerPatch;
};

/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayload = {
  __typename?: 'UpdateCustomerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was updated by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the `updateCustomer` mutation. */
export type UpdateCustomerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Customer` being updated. */
  patch: CustomerPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateCustomerTravellerByNodeId` mutation. */
export type UpdateCustomerTravellerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerTraveller` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerTraveller` being updated. */
  patch: CustomerTravellerPatch;
};

/** The output of our update `CustomerTraveller` mutation. */
export type UpdateCustomerTravellerPayload = {
  __typename?: 'UpdateCustomerTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerTraveller` that was updated by this mutation. */
  customerTraveller?: Maybe<CustomerTraveller>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
  /** An edge for our `CustomerTraveller`. May be used by Relay 1. */
  customerTravellerEdge?: Maybe<CustomerTravellersEdge>;
};


/** The output of our update `CustomerTraveller` mutation. */
export type UpdateCustomerTravellerPayloadCustomerTravellerEdgeArgs = {
  orderBy?: Maybe<Array<CustomerTravellersOrderBy>>;
};

/** All input for the `updateCustomerTraveller` mutation. */
export type UpdateCustomerTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerTraveller` being updated. */
  patch: CustomerTravellerPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateDestinationByNodeId` mutation. */
export type UpdateDestinationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Destination` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Destination` being updated. */
  patch: DestinationPatch;
};

/** The output of our update `Destination` mutation. */
export type UpdateDestinationPayload = {
  __typename?: 'UpdateDestinationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Destination` that was updated by this mutation. */
  destination?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  /** An edge for our `Destination`. May be used by Relay 1. */
  destinationEdge?: Maybe<DestinationsEdge>;
};


/** The output of our update `Destination` mutation. */
export type UpdateDestinationPayloadDestinationEdgeArgs = {
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
};

/** All input for the `updateDestination` mutation. */
export type UpdateDestinationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Destination` being updated. */
  patch: DestinationPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateDestinationFeatureByNodeId` mutation. */
export type UpdateDestinationFeatureByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `DestinationFeature` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `DestinationFeature` being updated. */
  patch: DestinationFeaturePatch;
};

/** The output of our update `DestinationFeature` mutation. */
export type UpdateDestinationFeaturePayload = {
  __typename?: 'UpdateDestinationFeaturePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationFeature` that was updated by this mutation. */
  destinationFeature?: Maybe<DestinationFeature>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `DestinationFeature`. May be used by Relay 1. */
  destinationFeatureEdge?: Maybe<DestinationFeaturesEdge>;
};


/** The output of our update `DestinationFeature` mutation. */
export type UpdateDestinationFeaturePayloadDestinationFeatureEdgeArgs = {
  orderBy?: Maybe<Array<DestinationFeaturesOrderBy>>;
};

/** All input for the `updateDestinationFeature` mutation. */
export type UpdateDestinationFeatureInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `DestinationFeature` being updated. */
  patch: DestinationFeaturePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateDestinationGuideByNodeId` mutation. */
export type UpdateDestinationGuideByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `DestinationGuide` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `DestinationGuide` being updated. */
  patch: DestinationGuidePatch;
};

/** The output of our update `DestinationGuide` mutation. */
export type UpdateDestinationGuidePayload = {
  __typename?: 'UpdateDestinationGuidePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationGuide` that was updated by this mutation. */
  destinationGuide?: Maybe<DestinationGuide>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
  /** An edge for our `DestinationGuide`. May be used by Relay 1. */
  destinationGuideEdge?: Maybe<DestinationGuidesEdge>;
};


/** The output of our update `DestinationGuide` mutation. */
export type UpdateDestinationGuidePayloadDestinationGuideEdgeArgs = {
  orderBy?: Maybe<Array<DestinationGuidesOrderBy>>;
};

/** All input for the `updateDestinationGuide` mutation. */
export type UpdateDestinationGuideInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `DestinationGuide` being updated. */
  patch: DestinationGuidePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateEmailByNodeId` mutation. */
export type UpdateEmailByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Email` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Email` being updated. */
  patch: EmailPatch;
};

/** The output of our update `Email` mutation. */
export type UpdateEmailPayload = {
  __typename?: 'UpdateEmailPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was updated by this mutation. */
  email?: Maybe<Email>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our update `Email` mutation. */
export type UpdateEmailPayloadEmailEdgeArgs = {
  orderBy?: Maybe<Array<EmailsOrderBy>>;
};

/** All input for the `updateEmail` mutation. */
export type UpdateEmailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Email` being updated. */
  patch: EmailPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateEnquiryByNodeId` mutation. */
export type UpdateEnquiryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Enquiry` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Enquiry` being updated. */
  patch: EnquiryPatch;
};

/** The output of our update `Enquiry` mutation. */
export type UpdateEnquiryPayload = {
  __typename?: 'UpdateEnquiryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Enquiry` that was updated by this mutation. */
  enquiry?: Maybe<Enquiry>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Enquiry`. May be used by Relay 1. */
  enquiryEdge?: Maybe<EnquiriesEdge>;
};


/** The output of our update `Enquiry` mutation. */
export type UpdateEnquiryPayloadEnquiryEdgeArgs = {
  orderBy?: Maybe<Array<EnquiriesOrderBy>>;
};

/** All input for the `updateEnquiry` mutation. */
export type UpdateEnquiryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Enquiry` being updated. */
  patch: EnquiryPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateExpenseByNodeId` mutation. */
export type UpdateExpenseByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Expense` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Expense` being updated. */
  patch: ExpensePatch;
};

/** The output of our update `Expense` mutation. */
export type UpdateExpensePayload = {
  __typename?: 'UpdateExpensePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Expense` that was updated by this mutation. */
  expense?: Maybe<Expense>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Expense`. May be used by Relay 1. */
  expenseEdge?: Maybe<ExpensesEdge>;
};


/** The output of our update `Expense` mutation. */
export type UpdateExpensePayloadExpenseEdgeArgs = {
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
};

/** All input for the `updateExpense` mutation. */
export type UpdateExpenseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Expense` being updated. */
  patch: ExpensePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateFeatureByNodeId` mutation. */
export type UpdateFeatureByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Feature` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Feature` being updated. */
  patch: FeaturePatch;
};

/** The output of our update `Feature` mutation. */
export type UpdateFeaturePayload = {
  __typename?: 'UpdateFeaturePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Feature` that was updated by this mutation. */
  feature?: Maybe<Feature>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `Feature`. May be used by Relay 1. */
  featureEdge?: Maybe<FeaturesEdge>;
};


/** The output of our update `Feature` mutation. */
export type UpdateFeaturePayloadFeatureEdgeArgs = {
  orderBy?: Maybe<Array<FeaturesOrderBy>>;
};

/** All input for the `updateFeature` mutation. */
export type UpdateFeatureInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Feature` being updated. */
  patch: FeaturePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateFinanceCategoryByNodeId` mutation. */
export type UpdateFinanceCategoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FinanceCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `FinanceCategory` being updated. */
  patch: FinanceCategoryPatch;
};

/** The output of our update `FinanceCategory` mutation. */
export type UpdateFinanceCategoryPayload = {
  __typename?: 'UpdateFinanceCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FinanceCategory` that was updated by this mutation. */
  financeCategory?: Maybe<FinanceCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `FinanceCategory`. May be used by Relay 1. */
  financeCategoryEdge?: Maybe<FinanceCategoriesEdge>;
};


/** The output of our update `FinanceCategory` mutation. */
export type UpdateFinanceCategoryPayloadFinanceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<FinanceCategoriesOrderBy>>;
};

/** All input for the `updateFinanceCategory` mutation. */
export type UpdateFinanceCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `FinanceCategory` being updated. */
  patch: FinanceCategoryPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateInvoiceByNodeId` mutation. */
export type UpdateInvoiceByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invoice` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  patch: InvoicePatch;
};

/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayload = {
  __typename?: 'UpdateInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was updated by this mutation. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
};

/** All input for the `updateInvoice` mutation. */
export type UpdateInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  patch: InvoicePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateMapPointByNodeId` mutation. */
export type UpdateMapPointByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MapPoint` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `MapPoint` being updated. */
  patch: MapPointPatch;
};

/** The output of our update `MapPoint` mutation. */
export type UpdateMapPointPayload = {
  __typename?: 'UpdateMapPointPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MapPoint` that was updated by this mutation. */
  mapPoint?: Maybe<MapPoint>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `MapPoint`. May be used by Relay 1. */
  mapPointEdge?: Maybe<MapPointsEdge>;
};


/** The output of our update `MapPoint` mutation. */
export type UpdateMapPointPayloadMapPointEdgeArgs = {
  orderBy?: Maybe<Array<MapPointsOrderBy>>;
};

/** All input for the `updateMapPoint` mutation. */
export type UpdateMapPointInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `MapPoint` being updated. */
  patch: MapPointPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateMediaGalleryByNodeId` mutation. */
export type UpdateMediaGalleryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MediaGallery` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `MediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** The output of our update `MediaGallery` mutation. */
export type UpdateMediaGalleryPayload = {
  __typename?: 'UpdateMediaGalleryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGallery` that was updated by this mutation. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  /** An edge for our `MediaGallery`. May be used by Relay 1. */
  mediaGalleryEdge?: Maybe<MediaGalleriesEdge>;
};


/** The output of our update `MediaGallery` mutation. */
export type UpdateMediaGalleryPayloadMediaGalleryEdgeArgs = {
  orderBy?: Maybe<Array<MediaGalleriesOrderBy>>;
};

/** All input for the `updateMediaGallery` mutation. */
export type UpdateMediaGalleryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `MediaGallery` being updated. */
  patch: MediaGalleryPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateMediaGalleryItemByNodeId` mutation. */
export type UpdateMediaGalleryItemByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MediaGalleryItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `MediaGalleryItem` being updated. */
  patch: MediaGalleryItemPatch;
};

/** The output of our update `MediaGalleryItem` mutation. */
export type UpdateMediaGalleryItemPayload = {
  __typename?: 'UpdateMediaGalleryItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGalleryItem` that was updated by this mutation. */
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `MediaGalleryItem`. May be used by Relay 1. */
  mediaGalleryItemEdge?: Maybe<MediaGalleryItemsEdge>;
};


/** The output of our update `MediaGalleryItem` mutation. */
export type UpdateMediaGalleryItemPayloadMediaGalleryItemEdgeArgs = {
  orderBy?: Maybe<Array<MediaGalleryItemsOrderBy>>;
};

/** All input for the `updateMediaGalleryItem` mutation. */
export type UpdateMediaGalleryItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `MediaGalleryItem` being updated. */
  patch: MediaGalleryItemPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateMediaItemByNodeId` mutation. */
export type UpdateMediaItemByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MediaItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `MediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The output of our update `MediaItem` mutation. */
export type UpdateMediaItemPayload = {
  __typename?: 'UpdateMediaItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaItem` that was updated by this mutation. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `MediaItem`. May be used by Relay 1. */
  mediaItemEdge?: Maybe<MediaItemsEdge>;
};


/** The output of our update `MediaItem` mutation. */
export type UpdateMediaItemPayloadMediaItemEdgeArgs = {
  orderBy?: Maybe<Array<MediaItemsOrderBy>>;
};

/** All input for the `updateMediaItem` mutation. */
export type UpdateMediaItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `MediaItem` being updated. */
  patch: MediaItemPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateNoteByNodeId` mutation. */
export type UpdateNoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Note` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Note` being updated. */
  patch: NotePatch;
};

/** The output of our update `Note` mutation. */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Note` that was updated by this mutation. */
  note?: Maybe<Note>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
  /** An edge for our `Note`. May be used by Relay 1. */
  noteEdge?: Maybe<NotesEdge>;
};


/** The output of our update `Note` mutation. */
export type UpdateNotePayloadNoteEdgeArgs = {
  orderBy?: Maybe<Array<NotesOrderBy>>;
};

/** All input for the `updateNote` mutation. */
export type UpdateNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Note` being updated. */
  patch: NotePatch;
  id: Scalars['UUID'];
};

/** All input for the `updatePassportByNodeId` mutation. */
export type UpdatePassportByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Passport` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Passport` being updated. */
  patch: PassportPatch;
};

/** The output of our update `Passport` mutation. */
export type UpdatePassportPayload = {
  __typename?: 'UpdatePassportPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Passport` that was updated by this mutation. */
  passport?: Maybe<Passport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
  /** An edge for our `Passport`. May be used by Relay 1. */
  passportEdge?: Maybe<PassportsEdge>;
};


/** The output of our update `Passport` mutation. */
export type UpdatePassportPayloadPassportEdgeArgs = {
  orderBy?: Maybe<Array<PassportsOrderBy>>;
};

/** All input for the `updatePassport` mutation. */
export type UpdatePassportInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Passport` being updated. */
  patch: PassportPatch;
  id: Scalars['UUID'];
};

/** All input for the `updatePaymentByNodeId` mutation. */
export type UpdatePaymentByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Payment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Payment` being updated. */
  patch: PaymentPatch;
};

/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayload = {
  __typename?: 'UpdatePaymentPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was updated by this mutation. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayloadPaymentEdgeArgs = {
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
};

/** All input for the `updatePayment` mutation. */
export type UpdatePaymentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Payment` being updated. */
  patch: PaymentPatch;
  id: Scalars['UUID'];
};

/** All input for the `updatePropertyByNodeId` mutation. */
export type UpdatePropertyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Property` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
};

/** The output of our update `Property` mutation. */
export type UpdatePropertyPayload = {
  __typename?: 'UpdatePropertyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Property` that was updated by this mutation. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
};


/** The output of our update `Property` mutation. */
export type UpdatePropertyPayloadPropertyEdgeArgs = {
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
};

/** All input for the `updateProperty` mutation. */
export type UpdatePropertyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteByNodeId` mutation. */
export type UpdateQuoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Quote` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Quote` being updated. */
  patch: QuotePatch;
};

/** The output of our update `Quote` mutation. */
export type UpdateQuotePayload = {
  __typename?: 'UpdateQuotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was updated by this mutation. */
  quote?: Maybe<Quote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our update `Quote` mutation. */
export type UpdateQuotePayloadQuoteEdgeArgs = {
  orderBy?: Maybe<Array<QuotesOrderBy>>;
};

/** All input for the `updateQuote` mutation. */
export type UpdateQuoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Quote` being updated. */
  patch: QuotePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteViewByNodeId` mutation. */
export type UpdateQuoteViewByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteView` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuoteView` being updated. */
  patch: QuoteViewPatch;
};

/** The output of our update `QuoteView` mutation. */
export type UpdateQuoteViewPayload = {
  __typename?: 'UpdateQuoteViewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteView` that was updated by this mutation. */
  quoteView?: Maybe<QuoteView>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
  /** An edge for our `QuoteView`. May be used by Relay 1. */
  quoteViewEdge?: Maybe<QuoteViewsEdge>;
};


/** The output of our update `QuoteView` mutation. */
export type UpdateQuoteViewPayloadQuoteViewEdgeArgs = {
  orderBy?: Maybe<Array<QuoteViewsOrderBy>>;
};

/** All input for the `updateQuoteView` mutation. */
export type UpdateQuoteViewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuoteView` being updated. */
  patch: QuoteViewPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteAccommodationDetailByNodeId` mutation. */
export type UpdateQuoteAccommodationDetailByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteAccommodationDetail` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuoteAccommodationDetail` being updated. */
  patch: QuoteAccommodationDetailPatch;
};

/** The output of our update `QuoteAccommodationDetail` mutation. */
export type UpdateQuoteAccommodationDetailPayload = {
  __typename?: 'UpdateQuoteAccommodationDetailPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteAccommodationDetail` that was updated by this mutation. */
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuoteAccommodationDetail`. May be used by Relay 1. */
  quoteAccommodationDetailEdge?: Maybe<QuoteAccommodationDetailsEdge>;
};


/** The output of our update `QuoteAccommodationDetail` mutation. */
export type UpdateQuoteAccommodationDetailPayloadQuoteAccommodationDetailEdgeArgs = {
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
};

/** All input for the `updateQuoteAccommodationDetail` mutation. */
export type UpdateQuoteAccommodationDetailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuoteAccommodationDetail` being updated. */
  patch: QuoteAccommodationDetailPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteCurrencyByNodeId` mutation. */
export type UpdateQuoteCurrencyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteCurrency` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuoteCurrency` being updated. */
  patch: QuoteCurrencyPatch;
};

/** The output of our update `QuoteCurrency` mutation. */
export type UpdateQuoteCurrencyPayload = {
  __typename?: 'UpdateQuoteCurrencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteCurrency` that was updated by this mutation. */
  quoteCurrency?: Maybe<QuoteCurrency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
  /** An edge for our `QuoteCurrency`. May be used by Relay 1. */
  quoteCurrencyEdge?: Maybe<QuoteCurrenciesEdge>;
};


/** The output of our update `QuoteCurrency` mutation. */
export type UpdateQuoteCurrencyPayloadQuoteCurrencyEdgeArgs = {
  orderBy?: Maybe<Array<QuoteCurrenciesOrderBy>>;
};

/** All input for the `updateQuoteCurrency` mutation. */
export type UpdateQuoteCurrencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuoteCurrency` being updated. */
  patch: QuoteCurrencyPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteDayByNodeId` mutation. */
export type UpdateQuoteDayByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteDay` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuoteDay` being updated. */
  patch: QuoteDayPatch;
};

/** The output of our update `QuoteDay` mutation. */
export type UpdateQuoteDayPayload = {
  __typename?: 'UpdateQuoteDayPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDay` that was updated by this mutation. */
  quoteDay?: Maybe<QuoteDay>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuoteDay`. May be used by Relay 1. */
  quoteDayEdge?: Maybe<QuoteDaysEdge>;
};


/** The output of our update `QuoteDay` mutation. */
export type UpdateQuoteDayPayloadQuoteDayEdgeArgs = {
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
};

/** All input for the `updateQuoteDay` mutation. */
export type UpdateQuoteDayInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuoteDay` being updated. */
  patch: QuoteDayPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteDayDestinationByNodeId` mutation. */
export type UpdateQuoteDayDestinationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteDayDestination` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuoteDayDestination` being updated. */
  patch: QuoteDayDestinationPatch;
};

/** The output of our update `QuoteDayDestination` mutation. */
export type UpdateQuoteDayDestinationPayload = {
  __typename?: 'UpdateQuoteDayDestinationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDayDestination` that was updated by this mutation. */
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
  /** An edge for our `QuoteDayDestination`. May be used by Relay 1. */
  quoteDayDestinationEdge?: Maybe<QuoteDayDestinationsEdge>;
};


/** The output of our update `QuoteDayDestination` mutation. */
export type UpdateQuoteDayDestinationPayloadQuoteDayDestinationEdgeArgs = {
  orderBy?: Maybe<Array<QuoteDayDestinationsOrderBy>>;
};

/** All input for the `updateQuoteDayDestination` mutation. */
export type UpdateQuoteDayDestinationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuoteDayDestination` being updated. */
  patch: QuoteDayDestinationPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteFinanceLineItemByNodeId` mutation. */
export type UpdateQuoteFinanceLineItemByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteFinanceLineItem` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuoteFinanceLineItem` being updated. */
  patch: QuoteFinanceLineItemPatch;
};

/** The output of our update `QuoteFinanceLineItem` mutation. */
export type UpdateQuoteFinanceLineItemPayload = {
  __typename?: 'UpdateQuoteFinanceLineItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteFinanceLineItem` that was updated by this mutation. */
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
  /** An edge for our `QuoteFinanceLineItem`. May be used by Relay 1. */
  quoteFinanceLineItemEdge?: Maybe<QuoteFinanceLineItemsEdge>;
};


/** The output of our update `QuoteFinanceLineItem` mutation. */
export type UpdateQuoteFinanceLineItemPayloadQuoteFinanceLineItemEdgeArgs = {
  orderBy?: Maybe<Array<QuoteFinanceLineItemsOrderBy>>;
};

/** All input for the `updateQuoteFinanceLineItem` mutation. */
export type UpdateQuoteFinanceLineItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuoteFinanceLineItem` being updated. */
  patch: QuoteFinanceLineItemPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuoteHeroByNodeId` mutation. */
export type UpdateQuoteHeroByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteHero` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuoteHero` being updated. */
  patch: QuoteHeroPatch;
};

/** The output of our update `QuoteHero` mutation. */
export type UpdateQuoteHeroPayload = {
  __typename?: 'UpdateQuoteHeroPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteHero` that was updated by this mutation. */
  quoteHero?: Maybe<QuoteHero>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  /** An edge for our `QuoteHero`. May be used by Relay 1. */
  quoteHeroEdge?: Maybe<QuoteHeroesEdge>;
};


/** The output of our update `QuoteHero` mutation. */
export type UpdateQuoteHeroPayloadQuoteHeroEdgeArgs = {
  orderBy?: Maybe<Array<QuoteHeroesOrderBy>>;
};

/** All input for the `updateQuoteHero` mutation. */
export type UpdateQuoteHeroInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuoteHero` being updated. */
  patch: QuoteHeroPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateQuotePublicByNodeId` mutation. */
export type UpdateQuotePublicByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuotePublic` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `QuotePublic` being updated. */
  patch: QuotePublicPatch;
};

/** The output of our update `QuotePublic` mutation. */
export type UpdateQuotePublicPayload = {
  __typename?: 'UpdateQuotePublicPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuotePublic` that was updated by this mutation. */
  quotePublic?: Maybe<QuotePublic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
  /** An edge for our `QuotePublic`. May be used by Relay 1. */
  quotePublicEdge?: Maybe<QuotePublicsEdge>;
};


/** The output of our update `QuotePublic` mutation. */
export type UpdateQuotePublicPayloadQuotePublicEdgeArgs = {
  orderBy?: Maybe<Array<QuotePublicsOrderBy>>;
};

/** All input for the `updateQuotePublic` mutation. */
export type UpdateQuotePublicInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `QuotePublic` being updated. */
  patch: QuotePublicPatch;
  key: Scalars['String'];
};

/** All input for the `updateReminderByNodeId` mutation. */
export type UpdateReminderByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reminder` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Reminder` being updated. */
  patch: ReminderPatch;
};

/** The output of our update `Reminder` mutation. */
export type UpdateReminderPayload = {
  __typename?: 'UpdateReminderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reminder` that was updated by this mutation. */
  reminder?: Maybe<Reminder>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
};


/** The output of our update `Reminder` mutation. */
export type UpdateReminderPayloadReminderEdgeArgs = {
  orderBy?: Maybe<Array<RemindersOrderBy>>;
};

/** All input for the `updateReminder` mutation. */
export type UpdateReminderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Reminder` being updated. */
  patch: ReminderPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateSupplierByNodeId` mutation. */
export type UpdateSupplierByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Supplier` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Supplier` being updated. */
  patch: SupplierPatch;
};

/** The output of our update `Supplier` mutation. */
export type UpdateSupplierPayload = {
  __typename?: 'UpdateSupplierPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Supplier` that was updated by this mutation. */
  supplier?: Maybe<Supplier>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `Supplier`. May be used by Relay 1. */
  supplierEdge?: Maybe<SuppliersEdge>;
};


/** The output of our update `Supplier` mutation. */
export type UpdateSupplierPayloadSupplierEdgeArgs = {
  orderBy?: Maybe<Array<SuppliersOrderBy>>;
};

/** All input for the `updateSupplier` mutation. */
export type UpdateSupplierInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Supplier` being updated. */
  patch: SupplierPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateSupplierInvoiceByNodeId` mutation. */
export type UpdateSupplierInvoiceByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SupplierInvoice` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SupplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** The output of our update `SupplierInvoice` mutation. */
export type UpdateSupplierInvoicePayload = {
  __typename?: 'UpdateSupplierInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SupplierInvoice` that was updated by this mutation. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `SupplierInvoice`. May be used by Relay 1. */
  supplierInvoiceEdge?: Maybe<SupplierInvoicesEdge>;
};


/** The output of our update `SupplierInvoice` mutation. */
export type UpdateSupplierInvoicePayloadSupplierInvoiceEdgeArgs = {
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
};

/** All input for the `updateSupplierInvoice` mutation. */
export type UpdateSupplierInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SupplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTestimonialByNodeId` mutation. */
export type UpdateTestimonialByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Testimonial` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Testimonial` being updated. */
  patch: TestimonialPatch;
};

/** The output of our update `Testimonial` mutation. */
export type UpdateTestimonialPayload = {
  __typename?: 'UpdateTestimonialPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Testimonial` that was updated by this mutation. */
  testimonial?: Maybe<Testimonial>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Testimonial`. May be used by Relay 1. */
  testimonialEdge?: Maybe<TestimonialsEdge>;
};


/** The output of our update `Testimonial` mutation. */
export type UpdateTestimonialPayloadTestimonialEdgeArgs = {
  orderBy?: Maybe<Array<TestimonialsOrderBy>>;
};

/** All input for the `updateTestimonial` mutation. */
export type UpdateTestimonialInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Testimonial` being updated. */
  patch: TestimonialPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTransactionByNodeId` mutation. */
export type UpdateTransactionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Transaction` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Transaction` being updated. */
  patch: TransactionPatch;
};

/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayload = {
  __typename?: 'UpdateTransactionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was updated by this mutation. */
  transaction?: Maybe<Transaction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayloadTransactionEdgeArgs = {
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
};

/** All input for the `updateTransaction` mutation. */
export type UpdateTransactionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Transaction` being updated. */
  patch: TransactionPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTransactionImportBatchByNodeId` mutation. */
export type UpdateTransactionImportBatchByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TransactionImportBatch` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TransactionImportBatch` being updated. */
  patch: TransactionImportBatchPatch;
};

/** The output of our update `TransactionImportBatch` mutation. */
export type UpdateTransactionImportBatchPayload = {
  __typename?: 'UpdateTransactionImportBatchPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionImportBatch` that was updated by this mutation. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  /** An edge for our `TransactionImportBatch`. May be used by Relay 1. */
  transactionImportBatchEdge?: Maybe<TransactionImportBatchesEdge>;
};


/** The output of our update `TransactionImportBatch` mutation. */
export type UpdateTransactionImportBatchPayloadTransactionImportBatchEdgeArgs = {
  orderBy?: Maybe<Array<TransactionImportBatchesOrderBy>>;
};

/** All input for the `updateTransactionImportBatch` mutation. */
export type UpdateTransactionImportBatchInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TransactionImportBatch` being updated. */
  patch: TransactionImportBatchPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTransactionLinkByNodeId` mutation. */
export type UpdateTransactionLinkByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TransactionLink` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TransactionLink` being updated. */
  patch: TransactionLinkPatch;
};

/** The output of our update `TransactionLink` mutation. */
export type UpdateTransactionLinkPayload = {
  __typename?: 'UpdateTransactionLinkPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionLink` that was updated by this mutation. */
  transactionLink?: Maybe<TransactionLink>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
  /** An edge for our `TransactionLink`. May be used by Relay 1. */
  transactionLinkEdge?: Maybe<TransactionLinksEdge>;
};


/** The output of our update `TransactionLink` mutation. */
export type UpdateTransactionLinkPayloadTransactionLinkEdgeArgs = {
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
};

/** All input for the `updateTransactionLink` mutation. */
export type UpdateTransactionLinkInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TransactionLink` being updated. */
  patch: TransactionLinkPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTransactionNoteByNodeId` mutation. */
export type UpdateTransactionNoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TransactionNote` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TransactionNote` being updated. */
  patch: TransactionNotePatch;
};

/** The output of our update `TransactionNote` mutation. */
export type UpdateTransactionNotePayload = {
  __typename?: 'UpdateTransactionNotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionNote` that was updated by this mutation. */
  transactionNote?: Maybe<TransactionNote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
  /** An edge for our `TransactionNote`. May be used by Relay 1. */
  transactionNoteEdge?: Maybe<TransactionNotesEdge>;
};


/** The output of our update `TransactionNote` mutation. */
export type UpdateTransactionNotePayloadTransactionNoteEdgeArgs = {
  orderBy?: Maybe<Array<TransactionNotesOrderBy>>;
};

/** All input for the `updateTransactionNote` mutation. */
export type UpdateTransactionNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TransactionNote` being updated. */
  patch: TransactionNotePatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTravellerByNodeId` mutation. */
export type UpdateTravellerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Traveller` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Traveller` being updated. */
  patch: TravellerPatch;
};

/** The output of our update `Traveller` mutation. */
export type UpdateTravellerPayload = {
  __typename?: 'UpdateTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Traveller` that was updated by this mutation. */
  traveller?: Maybe<Traveller>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Traveller`. May be used by Relay 1. */
  travellerEdge?: Maybe<TravellersEdge>;
};


/** The output of our update `Traveller` mutation. */
export type UpdateTravellerPayloadTravellerEdgeArgs = {
  orderBy?: Maybe<Array<TravellersOrderBy>>;
};

/** All input for the `updateTraveller` mutation. */
export type UpdateTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Traveller` being updated. */
  patch: TravellerPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTripByNodeId` mutation. */
export type UpdateTripByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Trip` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Trip` being updated. */
  patch: TripPatch;
};

/** The output of our update `Trip` mutation. */
export type UpdateTripPayload = {
  __typename?: 'UpdateTripPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Trip` that was updated by this mutation. */
  trip?: Maybe<Trip>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  /** An edge for our `Trip`. May be used by Relay 1. */
  tripEdge?: Maybe<TripsEdge>;
};


/** The output of our update `Trip` mutation. */
export type UpdateTripPayloadTripEdgeArgs = {
  orderBy?: Maybe<Array<TripsOrderBy>>;
};

/** All input for the `updateTrip` mutation. */
export type UpdateTripInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Trip` being updated. */
  patch: TripPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTripTravellerByNodeId` mutation. */
export type UpdateTripTravellerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TripTraveller` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TripTraveller` being updated. */
  patch: TripTravellerPatch;
};

/** The output of our update `TripTraveller` mutation. */
export type UpdateTripTravellerPayload = {
  __typename?: 'UpdateTripTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripTraveller` that was updated by this mutation. */
  tripTraveller?: Maybe<TripTraveller>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
  /** An edge for our `TripTraveller`. May be used by Relay 1. */
  tripTravellerEdge?: Maybe<TripTravellersEdge>;
};


/** The output of our update `TripTraveller` mutation. */
export type UpdateTripTravellerPayloadTripTravellerEdgeArgs = {
  orderBy?: Maybe<Array<TripTravellersOrderBy>>;
};

/** All input for the `updateTripTraveller` mutation. */
export type UpdateTripTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TripTraveller` being updated. */
  patch: TripTravellerPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateTripFlightByNodeId` mutation. */
export type UpdateTripFlightByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TripFlight` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TripFlight` being updated. */
  patch: TripFlightPatch;
};

/** The output of our update `TripFlight` mutation. */
export type UpdateTripFlightPayload = {
  __typename?: 'UpdateTripFlightPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripFlight` that was updated by this mutation. */
  tripFlight?: Maybe<TripFlight>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
  /** An edge for our `TripFlight`. May be used by Relay 1. */
  tripFlightEdge?: Maybe<TripFlightsEdge>;
};


/** The output of our update `TripFlight` mutation. */
export type UpdateTripFlightPayloadTripFlightEdgeArgs = {
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
};

/** All input for the `updateTripFlight` mutation. */
export type UpdateTripFlightInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TripFlight` being updated. */
  patch: TripFlightPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  id: Scalars['UUID'];
};

/** All input for the `updateVisaRequirementByNodeId` mutation. */
export type UpdateVisaRequirementByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VisaRequirement` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `VisaRequirement` being updated. */
  patch: VisaRequirementPatch;
};

/** Represents an update to a `VisaRequirement`. Fields that are set will be updated. */
export type VisaRequirementPatch = {
  id?: Maybe<Scalars['UUID']>;
  created?: Maybe<Scalars['Datetime']>;
  modified?: Maybe<Scalars['Datetime']>;
  lastVerified?: Maybe<Scalars['Datetime']>;
  destinationCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  passportCountries?: Maybe<Array<Maybe<Scalars['String']>>>;
  detail?: Maybe<Scalars['String']>;
};

/** The output of our update `VisaRequirement` mutation. */
export type UpdateVisaRequirementPayload = {
  __typename?: 'UpdateVisaRequirementPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VisaRequirement` that was updated by this mutation. */
  visaRequirement?: Maybe<VisaRequirement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VisaRequirement`. May be used by Relay 1. */
  visaRequirementEdge?: Maybe<VisaRequirementsEdge>;
};


/** The output of our update `VisaRequirement` mutation. */
export type UpdateVisaRequirementPayloadVisaRequirementEdgeArgs = {
  orderBy?: Maybe<Array<VisaRequirementsOrderBy>>;
};

/** All input for the `updateVisaRequirement` mutation. */
export type UpdateVisaRequirementInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `VisaRequirement` being updated. */
  patch: VisaRequirementPatch;
  id: Scalars['UUID'];
};

/** All input for the `deleteAccountByNodeId` mutation. */
export type DeleteAccountByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Account` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Account` mutation. */
export type DeleteAccountPayload = {
  __typename?: 'DeleteAccountPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was deleted by this mutation. */
  account?: Maybe<Account>;
  deletedAccountNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our delete `Account` mutation. */
export type DeleteAccountPayloadAccountEdgeArgs = {
  orderBy?: Maybe<Array<AccountsOrderBy>>;
};

/** All input for the `deleteAccount` mutation. */
export type DeleteAccountInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteAgencyByNodeId` mutation. */
export type DeleteAgencyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Agency` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Agency` mutation. */
export type DeleteAgencyPayload = {
  __typename?: 'DeleteAgencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agency` that was deleted by this mutation. */
  agency?: Maybe<Agency>;
  deletedAgencyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  /** An edge for our `Agency`. May be used by Relay 1. */
  agencyEdge?: Maybe<AgenciesEdge>;
};


/** The output of our delete `Agency` mutation. */
export type DeleteAgencyPayloadAgencyEdgeArgs = {
  orderBy?: Maybe<Array<AgenciesOrderBy>>;
};

/** All input for the `deleteAgency` mutation. */
export type DeleteAgencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteAgencyMemberByNodeId` mutation. */
export type DeleteAgencyMemberByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AgencyMember` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `AgencyMember` mutation. */
export type DeleteAgencyMemberPayload = {
  __typename?: 'DeleteAgencyMemberPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AgencyMember` that was deleted by this mutation. */
  agencyMember?: Maybe<AgencyMember>;
  deletedAgencyMemberNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  /** An edge for our `AgencyMember`. May be used by Relay 1. */
  agencyMemberEdge?: Maybe<AgencyMembersEdge>;
};


/** The output of our delete `AgencyMember` mutation. */
export type DeleteAgencyMemberPayloadAgencyMemberEdgeArgs = {
  orderBy?: Maybe<Array<AgencyMembersOrderBy>>;
};

/** All input for the `deleteAgencyMember` mutation. */
export type DeleteAgencyMemberInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteAirportByNodeId` mutation. */
export type DeleteAirportByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Airport` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Airport` mutation. */
export type DeleteAirportPayload = {
  __typename?: 'DeleteAirportPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Airport` that was deleted by this mutation. */
  airport?: Maybe<Airport>;
  deletedAirportNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  /** An edge for our `Airport`. May be used by Relay 1. */
  airportEdge?: Maybe<AirportsEdge>;
};


/** The output of our delete `Airport` mutation. */
export type DeleteAirportPayloadAirportEdgeArgs = {
  orderBy?: Maybe<Array<AirportsOrderBy>>;
};

/** All input for the `deleteAirport` mutation. */
export type DeleteAirportInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteCountryByNodeId` mutation. */
export type DeleteCountryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Country` mutation. */
export type DeleteCountryPayload = {
  __typename?: 'DeleteCountryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was deleted by this mutation. */
  country?: Maybe<Country>;
  deletedCountryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our delete `Country` mutation. */
export type DeleteCountryPayloadCountryEdgeArgs = {
  orderBy?: Maybe<Array<CountriesOrderBy>>;
};

/** All input for the `deleteCountry` mutation. */
export type DeleteCountryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteCustomerByNodeId` mutation. */
export type DeleteCustomerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayload = {
  __typename?: 'DeleteCustomerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was deleted by this mutation. */
  customer?: Maybe<Customer>;
  deletedCustomerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayloadCustomerEdgeArgs = {
  orderBy?: Maybe<Array<CustomersOrderBy>>;
};

/** All input for the `deleteCustomer` mutation. */
export type DeleteCustomerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteCustomerTravellerByNodeId` mutation. */
export type DeleteCustomerTravellerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerTraveller` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `CustomerTraveller` mutation. */
export type DeleteCustomerTravellerPayload = {
  __typename?: 'DeleteCustomerTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerTraveller` that was deleted by this mutation. */
  customerTraveller?: Maybe<CustomerTraveller>;
  deletedCustomerTravellerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
  /** An edge for our `CustomerTraveller`. May be used by Relay 1. */
  customerTravellerEdge?: Maybe<CustomerTravellersEdge>;
};


/** The output of our delete `CustomerTraveller` mutation. */
export type DeleteCustomerTravellerPayloadCustomerTravellerEdgeArgs = {
  orderBy?: Maybe<Array<CustomerTravellersOrderBy>>;
};

/** All input for the `deleteCustomerTraveller` mutation. */
export type DeleteCustomerTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteDestinationByNodeId` mutation. */
export type DeleteDestinationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Destination` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Destination` mutation. */
export type DeleteDestinationPayload = {
  __typename?: 'DeleteDestinationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Destination` that was deleted by this mutation. */
  destination?: Maybe<Destination>;
  deletedDestinationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  /** An edge for our `Destination`. May be used by Relay 1. */
  destinationEdge?: Maybe<DestinationsEdge>;
};


/** The output of our delete `Destination` mutation. */
export type DeleteDestinationPayloadDestinationEdgeArgs = {
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
};

/** All input for the `deleteDestination` mutation. */
export type DeleteDestinationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteDestinationFeatureByNodeId` mutation. */
export type DeleteDestinationFeatureByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `DestinationFeature` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `DestinationFeature` mutation. */
export type DeleteDestinationFeaturePayload = {
  __typename?: 'DeleteDestinationFeaturePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationFeature` that was deleted by this mutation. */
  destinationFeature?: Maybe<DestinationFeature>;
  deletedDestinationFeatureNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `DestinationFeature`. May be used by Relay 1. */
  destinationFeatureEdge?: Maybe<DestinationFeaturesEdge>;
};


/** The output of our delete `DestinationFeature` mutation. */
export type DeleteDestinationFeaturePayloadDestinationFeatureEdgeArgs = {
  orderBy?: Maybe<Array<DestinationFeaturesOrderBy>>;
};

/** All input for the `deleteDestinationFeature` mutation. */
export type DeleteDestinationFeatureInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteDestinationGuideByNodeId` mutation. */
export type DeleteDestinationGuideByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `DestinationGuide` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `DestinationGuide` mutation. */
export type DeleteDestinationGuidePayload = {
  __typename?: 'DeleteDestinationGuidePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `DestinationGuide` that was deleted by this mutation. */
  destinationGuide?: Maybe<DestinationGuide>;
  deletedDestinationGuideNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
  /** An edge for our `DestinationGuide`. May be used by Relay 1. */
  destinationGuideEdge?: Maybe<DestinationGuidesEdge>;
};


/** The output of our delete `DestinationGuide` mutation. */
export type DeleteDestinationGuidePayloadDestinationGuideEdgeArgs = {
  orderBy?: Maybe<Array<DestinationGuidesOrderBy>>;
};

/** All input for the `deleteDestinationGuide` mutation. */
export type DeleteDestinationGuideInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteEmailByNodeId` mutation. */
export type DeleteEmailByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Email` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Email` mutation. */
export type DeleteEmailPayload = {
  __typename?: 'DeleteEmailPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was deleted by this mutation. */
  email?: Maybe<Email>;
  deletedEmailNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our delete `Email` mutation. */
export type DeleteEmailPayloadEmailEdgeArgs = {
  orderBy?: Maybe<Array<EmailsOrderBy>>;
};

/** All input for the `deleteEmail` mutation. */
export type DeleteEmailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteEnquiryByNodeId` mutation. */
export type DeleteEnquiryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Enquiry` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Enquiry` mutation. */
export type DeleteEnquiryPayload = {
  __typename?: 'DeleteEnquiryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Enquiry` that was deleted by this mutation. */
  enquiry?: Maybe<Enquiry>;
  deletedEnquiryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Enquiry`. May be used by Relay 1. */
  enquiryEdge?: Maybe<EnquiriesEdge>;
};


/** The output of our delete `Enquiry` mutation. */
export type DeleteEnquiryPayloadEnquiryEdgeArgs = {
  orderBy?: Maybe<Array<EnquiriesOrderBy>>;
};

/** All input for the `deleteEnquiry` mutation. */
export type DeleteEnquiryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteExpenseByNodeId` mutation. */
export type DeleteExpenseByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Expense` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Expense` mutation. */
export type DeleteExpensePayload = {
  __typename?: 'DeleteExpensePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Expense` that was deleted by this mutation. */
  expense?: Maybe<Expense>;
  deletedExpenseNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Expense`. May be used by Relay 1. */
  expenseEdge?: Maybe<ExpensesEdge>;
};


/** The output of our delete `Expense` mutation. */
export type DeleteExpensePayloadExpenseEdgeArgs = {
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
};

/** All input for the `deleteExpense` mutation. */
export type DeleteExpenseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteFeatureByNodeId` mutation. */
export type DeleteFeatureByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Feature` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Feature` mutation. */
export type DeleteFeaturePayload = {
  __typename?: 'DeleteFeaturePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Feature` that was deleted by this mutation. */
  feature?: Maybe<Feature>;
  deletedFeatureNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `Feature`. May be used by Relay 1. */
  featureEdge?: Maybe<FeaturesEdge>;
};


/** The output of our delete `Feature` mutation. */
export type DeleteFeaturePayloadFeatureEdgeArgs = {
  orderBy?: Maybe<Array<FeaturesOrderBy>>;
};

/** All input for the `deleteFeature` mutation. */
export type DeleteFeatureInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteFinanceCategoryByNodeId` mutation. */
export type DeleteFinanceCategoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `FinanceCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `FinanceCategory` mutation. */
export type DeleteFinanceCategoryPayload = {
  __typename?: 'DeleteFinanceCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `FinanceCategory` that was deleted by this mutation. */
  financeCategory?: Maybe<FinanceCategory>;
  deletedFinanceCategoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `FinanceCategory`. May be used by Relay 1. */
  financeCategoryEdge?: Maybe<FinanceCategoriesEdge>;
};


/** The output of our delete `FinanceCategory` mutation. */
export type DeleteFinanceCategoryPayloadFinanceCategoryEdgeArgs = {
  orderBy?: Maybe<Array<FinanceCategoriesOrderBy>>;
};

/** All input for the `deleteFinanceCategory` mutation. */
export type DeleteFinanceCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteInvoiceByNodeId` mutation. */
export type DeleteInvoiceByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invoice` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayload = {
  __typename?: 'DeleteInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was deleted by this mutation. */
  invoice?: Maybe<Invoice>;
  deletedInvoiceNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
};

/** All input for the `deleteInvoice` mutation. */
export type DeleteInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteMapPointByNodeId` mutation. */
export type DeleteMapPointByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MapPoint` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `MapPoint` mutation. */
export type DeleteMapPointPayload = {
  __typename?: 'DeleteMapPointPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MapPoint` that was deleted by this mutation. */
  mapPoint?: Maybe<MapPoint>;
  deletedMapPointNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `MapPoint`. May be used by Relay 1. */
  mapPointEdge?: Maybe<MapPointsEdge>;
};


/** The output of our delete `MapPoint` mutation. */
export type DeleteMapPointPayloadMapPointEdgeArgs = {
  orderBy?: Maybe<Array<MapPointsOrderBy>>;
};

/** All input for the `deleteMapPoint` mutation. */
export type DeleteMapPointInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteMediaGalleryByNodeId` mutation. */
export type DeleteMediaGalleryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MediaGallery` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `MediaGallery` mutation. */
export type DeleteMediaGalleryPayload = {
  __typename?: 'DeleteMediaGalleryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGallery` that was deleted by this mutation. */
  mediaGallery?: Maybe<MediaGallery>;
  deletedMediaGalleryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  /** An edge for our `MediaGallery`. May be used by Relay 1. */
  mediaGalleryEdge?: Maybe<MediaGalleriesEdge>;
};


/** The output of our delete `MediaGallery` mutation. */
export type DeleteMediaGalleryPayloadMediaGalleryEdgeArgs = {
  orderBy?: Maybe<Array<MediaGalleriesOrderBy>>;
};

/** All input for the `deleteMediaGallery` mutation. */
export type DeleteMediaGalleryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteMediaGalleryItemByNodeId` mutation. */
export type DeleteMediaGalleryItemByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MediaGalleryItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `MediaGalleryItem` mutation. */
export type DeleteMediaGalleryItemPayload = {
  __typename?: 'DeleteMediaGalleryItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaGalleryItem` that was deleted by this mutation. */
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  deletedMediaGalleryItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `MediaGalleryItem`. May be used by Relay 1. */
  mediaGalleryItemEdge?: Maybe<MediaGalleryItemsEdge>;
};


/** The output of our delete `MediaGalleryItem` mutation. */
export type DeleteMediaGalleryItemPayloadMediaGalleryItemEdgeArgs = {
  orderBy?: Maybe<Array<MediaGalleryItemsOrderBy>>;
};

/** All input for the `deleteMediaGalleryItem` mutation. */
export type DeleteMediaGalleryItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteMediaItemByNodeId` mutation. */
export type DeleteMediaItemByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `MediaItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `MediaItem` mutation. */
export type DeleteMediaItemPayload = {
  __typename?: 'DeleteMediaItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `MediaItem` that was deleted by this mutation. */
  mediaItem?: Maybe<MediaItem>;
  deletedMediaItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `MediaItem`. May be used by Relay 1. */
  mediaItemEdge?: Maybe<MediaItemsEdge>;
};


/** The output of our delete `MediaItem` mutation. */
export type DeleteMediaItemPayloadMediaItemEdgeArgs = {
  orderBy?: Maybe<Array<MediaItemsOrderBy>>;
};

/** All input for the `deleteMediaItem` mutation. */
export type DeleteMediaItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteNoteByNodeId` mutation. */
export type DeleteNoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Note` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Note` mutation. */
export type DeleteNotePayload = {
  __typename?: 'DeleteNotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Note` that was deleted by this mutation. */
  note?: Maybe<Note>;
  deletedNoteNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
  /** An edge for our `Note`. May be used by Relay 1. */
  noteEdge?: Maybe<NotesEdge>;
};


/** The output of our delete `Note` mutation. */
export type DeleteNotePayloadNoteEdgeArgs = {
  orderBy?: Maybe<Array<NotesOrderBy>>;
};

/** All input for the `deleteNote` mutation. */
export type DeleteNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deletePassportByNodeId` mutation. */
export type DeletePassportByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Passport` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Passport` mutation. */
export type DeletePassportPayload = {
  __typename?: 'DeletePassportPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Passport` that was deleted by this mutation. */
  passport?: Maybe<Passport>;
  deletedPassportNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
  /** An edge for our `Passport`. May be used by Relay 1. */
  passportEdge?: Maybe<PassportsEdge>;
};


/** The output of our delete `Passport` mutation. */
export type DeletePassportPayloadPassportEdgeArgs = {
  orderBy?: Maybe<Array<PassportsOrderBy>>;
};

/** All input for the `deletePassport` mutation. */
export type DeletePassportInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deletePaymentByNodeId` mutation. */
export type DeletePaymentByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Payment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayload = {
  __typename?: 'DeletePaymentPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was deleted by this mutation. */
  payment?: Maybe<Payment>;
  deletedPaymentNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayloadPaymentEdgeArgs = {
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
};

/** All input for the `deletePayment` mutation. */
export type DeletePaymentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deletePropertyByNodeId` mutation. */
export type DeletePropertyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Property` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Property` mutation. */
export type DeletePropertyPayload = {
  __typename?: 'DeletePropertyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Property` that was deleted by this mutation. */
  property?: Maybe<Property>;
  deletedPropertyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
};


/** The output of our delete `Property` mutation. */
export type DeletePropertyPayloadPropertyEdgeArgs = {
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
};

/** All input for the `deleteProperty` mutation. */
export type DeletePropertyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteByNodeId` mutation. */
export type DeleteQuoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Quote` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayload = {
  __typename?: 'DeleteQuotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was deleted by this mutation. */
  quote?: Maybe<Quote>;
  deletedQuoteNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayloadQuoteEdgeArgs = {
  orderBy?: Maybe<Array<QuotesOrderBy>>;
};

/** All input for the `deleteQuote` mutation. */
export type DeleteQuoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteViewByNodeId` mutation. */
export type DeleteQuoteViewByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteView` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuoteView` mutation. */
export type DeleteQuoteViewPayload = {
  __typename?: 'DeleteQuoteViewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteView` that was deleted by this mutation. */
  quoteView?: Maybe<QuoteView>;
  deletedQuoteViewNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
  /** An edge for our `QuoteView`. May be used by Relay 1. */
  quoteViewEdge?: Maybe<QuoteViewsEdge>;
};


/** The output of our delete `QuoteView` mutation. */
export type DeleteQuoteViewPayloadQuoteViewEdgeArgs = {
  orderBy?: Maybe<Array<QuoteViewsOrderBy>>;
};

/** All input for the `deleteQuoteView` mutation. */
export type DeleteQuoteViewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteAccommodationDetailByNodeId` mutation. */
export type DeleteQuoteAccommodationDetailByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteAccommodationDetail` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuoteAccommodationDetail` mutation. */
export type DeleteQuoteAccommodationDetailPayload = {
  __typename?: 'DeleteQuoteAccommodationDetailPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteAccommodationDetail` that was deleted by this mutation. */
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  deletedQuoteAccommodationDetailNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuoteAccommodationDetail`. May be used by Relay 1. */
  quoteAccommodationDetailEdge?: Maybe<QuoteAccommodationDetailsEdge>;
};


/** The output of our delete `QuoteAccommodationDetail` mutation. */
export type DeleteQuoteAccommodationDetailPayloadQuoteAccommodationDetailEdgeArgs = {
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
};

/** All input for the `deleteQuoteAccommodationDetail` mutation. */
export type DeleteQuoteAccommodationDetailInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteCurrencyByNodeId` mutation. */
export type DeleteQuoteCurrencyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteCurrency` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuoteCurrency` mutation. */
export type DeleteQuoteCurrencyPayload = {
  __typename?: 'DeleteQuoteCurrencyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteCurrency` that was deleted by this mutation. */
  quoteCurrency?: Maybe<QuoteCurrency>;
  deletedQuoteCurrencyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
  /** An edge for our `QuoteCurrency`. May be used by Relay 1. */
  quoteCurrencyEdge?: Maybe<QuoteCurrenciesEdge>;
};


/** The output of our delete `QuoteCurrency` mutation. */
export type DeleteQuoteCurrencyPayloadQuoteCurrencyEdgeArgs = {
  orderBy?: Maybe<Array<QuoteCurrenciesOrderBy>>;
};

/** All input for the `deleteQuoteCurrency` mutation. */
export type DeleteQuoteCurrencyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteDayByNodeId` mutation. */
export type DeleteQuoteDayByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteDay` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuoteDay` mutation. */
export type DeleteQuoteDayPayload = {
  __typename?: 'DeleteQuoteDayPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDay` that was deleted by this mutation. */
  quoteDay?: Maybe<QuoteDay>;
  deletedQuoteDayNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuoteDay`. May be used by Relay 1. */
  quoteDayEdge?: Maybe<QuoteDaysEdge>;
};


/** The output of our delete `QuoteDay` mutation. */
export type DeleteQuoteDayPayloadQuoteDayEdgeArgs = {
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
};

/** All input for the `deleteQuoteDay` mutation. */
export type DeleteQuoteDayInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteDayDestinationByNodeId` mutation. */
export type DeleteQuoteDayDestinationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteDayDestination` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuoteDayDestination` mutation. */
export type DeleteQuoteDayDestinationPayload = {
  __typename?: 'DeleteQuoteDayDestinationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteDayDestination` that was deleted by this mutation. */
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  deletedQuoteDayDestinationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
  /** An edge for our `QuoteDayDestination`. May be used by Relay 1. */
  quoteDayDestinationEdge?: Maybe<QuoteDayDestinationsEdge>;
};


/** The output of our delete `QuoteDayDestination` mutation. */
export type DeleteQuoteDayDestinationPayloadQuoteDayDestinationEdgeArgs = {
  orderBy?: Maybe<Array<QuoteDayDestinationsOrderBy>>;
};

/** All input for the `deleteQuoteDayDestination` mutation. */
export type DeleteQuoteDayDestinationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteFinanceLineItemByNodeId` mutation. */
export type DeleteQuoteFinanceLineItemByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteFinanceLineItem` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuoteFinanceLineItem` mutation. */
export type DeleteQuoteFinanceLineItemPayload = {
  __typename?: 'DeleteQuoteFinanceLineItemPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteFinanceLineItem` that was deleted by this mutation. */
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  deletedQuoteFinanceLineItemNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
  /** An edge for our `QuoteFinanceLineItem`. May be used by Relay 1. */
  quoteFinanceLineItemEdge?: Maybe<QuoteFinanceLineItemsEdge>;
};


/** The output of our delete `QuoteFinanceLineItem` mutation. */
export type DeleteQuoteFinanceLineItemPayloadQuoteFinanceLineItemEdgeArgs = {
  orderBy?: Maybe<Array<QuoteFinanceLineItemsOrderBy>>;
};

/** All input for the `deleteQuoteFinanceLineItem` mutation. */
export type DeleteQuoteFinanceLineItemInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuoteHeroByNodeId` mutation. */
export type DeleteQuoteHeroByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuoteHero` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuoteHero` mutation. */
export type DeleteQuoteHeroPayload = {
  __typename?: 'DeleteQuoteHeroPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuoteHero` that was deleted by this mutation. */
  quoteHero?: Maybe<QuoteHero>;
  deletedQuoteHeroNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  /** An edge for our `QuoteHero`. May be used by Relay 1. */
  quoteHeroEdge?: Maybe<QuoteHeroesEdge>;
};


/** The output of our delete `QuoteHero` mutation. */
export type DeleteQuoteHeroPayloadQuoteHeroEdgeArgs = {
  orderBy?: Maybe<Array<QuoteHeroesOrderBy>>;
};

/** All input for the `deleteQuoteHero` mutation. */
export type DeleteQuoteHeroInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteQuotePublicByNodeId` mutation. */
export type DeleteQuotePublicByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `QuotePublic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `QuotePublic` mutation. */
export type DeleteQuotePublicPayload = {
  __typename?: 'DeleteQuotePublicPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `QuotePublic` that was deleted by this mutation. */
  quotePublic?: Maybe<QuotePublic>;
  deletedQuotePublicNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
  /** An edge for our `QuotePublic`. May be used by Relay 1. */
  quotePublicEdge?: Maybe<QuotePublicsEdge>;
};


/** The output of our delete `QuotePublic` mutation. */
export type DeleteQuotePublicPayloadQuotePublicEdgeArgs = {
  orderBy?: Maybe<Array<QuotePublicsOrderBy>>;
};

/** All input for the `deleteQuotePublic` mutation. */
export type DeleteQuotePublicInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  key: Scalars['String'];
};

/** All input for the `deleteReminderByNodeId` mutation. */
export type DeleteReminderByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reminder` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Reminder` mutation. */
export type DeleteReminderPayload = {
  __typename?: 'DeleteReminderPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reminder` that was deleted by this mutation. */
  reminder?: Maybe<Reminder>;
  deletedReminderNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
};


/** The output of our delete `Reminder` mutation. */
export type DeleteReminderPayloadReminderEdgeArgs = {
  orderBy?: Maybe<Array<RemindersOrderBy>>;
};

/** All input for the `deleteReminder` mutation. */
export type DeleteReminderInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteSupplierByNodeId` mutation. */
export type DeleteSupplierByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Supplier` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Supplier` mutation. */
export type DeleteSupplierPayload = {
  __typename?: 'DeleteSupplierPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Supplier` that was deleted by this mutation. */
  supplier?: Maybe<Supplier>;
  deletedSupplierNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  /** An edge for our `Supplier`. May be used by Relay 1. */
  supplierEdge?: Maybe<SuppliersEdge>;
};


/** The output of our delete `Supplier` mutation. */
export type DeleteSupplierPayloadSupplierEdgeArgs = {
  orderBy?: Maybe<Array<SuppliersOrderBy>>;
};

/** All input for the `deleteSupplier` mutation. */
export type DeleteSupplierInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteSupplierInvoiceByNodeId` mutation. */
export type DeleteSupplierInvoiceByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SupplierInvoice` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `SupplierInvoice` mutation. */
export type DeleteSupplierInvoicePayload = {
  __typename?: 'DeleteSupplierInvoicePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SupplierInvoice` that was deleted by this mutation. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  deletedSupplierInvoiceNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `SupplierInvoice`. May be used by Relay 1. */
  supplierInvoiceEdge?: Maybe<SupplierInvoicesEdge>;
};


/** The output of our delete `SupplierInvoice` mutation. */
export type DeleteSupplierInvoicePayloadSupplierInvoiceEdgeArgs = {
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
};

/** All input for the `deleteSupplierInvoice` mutation. */
export type DeleteSupplierInvoiceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTestimonialByNodeId` mutation. */
export type DeleteTestimonialByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Testimonial` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Testimonial` mutation. */
export type DeleteTestimonialPayload = {
  __typename?: 'DeleteTestimonialPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Testimonial` that was deleted by this mutation. */
  testimonial?: Maybe<Testimonial>;
  deletedTestimonialNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
  /** An edge for our `Testimonial`. May be used by Relay 1. */
  testimonialEdge?: Maybe<TestimonialsEdge>;
};


/** The output of our delete `Testimonial` mutation. */
export type DeleteTestimonialPayloadTestimonialEdgeArgs = {
  orderBy?: Maybe<Array<TestimonialsOrderBy>>;
};

/** All input for the `deleteTestimonial` mutation. */
export type DeleteTestimonialInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTransactionByNodeId` mutation. */
export type DeleteTransactionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Transaction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayload = {
  __typename?: 'DeleteTransactionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was deleted by this mutation. */
  transaction?: Maybe<Transaction>;
  deletedTransactionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayloadTransactionEdgeArgs = {
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
};

/** All input for the `deleteTransaction` mutation. */
export type DeleteTransactionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTransactionImportBatchByNodeId` mutation. */
export type DeleteTransactionImportBatchByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TransactionImportBatch` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `TransactionImportBatch` mutation. */
export type DeleteTransactionImportBatchPayload = {
  __typename?: 'DeleteTransactionImportBatchPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionImportBatch` that was deleted by this mutation. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  deletedTransactionImportBatchNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  /** An edge for our `TransactionImportBatch`. May be used by Relay 1. */
  transactionImportBatchEdge?: Maybe<TransactionImportBatchesEdge>;
};


/** The output of our delete `TransactionImportBatch` mutation. */
export type DeleteTransactionImportBatchPayloadTransactionImportBatchEdgeArgs = {
  orderBy?: Maybe<Array<TransactionImportBatchesOrderBy>>;
};

/** All input for the `deleteTransactionImportBatch` mutation. */
export type DeleteTransactionImportBatchInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTransactionLinkByNodeId` mutation. */
export type DeleteTransactionLinkByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TransactionLink` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `TransactionLink` mutation. */
export type DeleteTransactionLinkPayload = {
  __typename?: 'DeleteTransactionLinkPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionLink` that was deleted by this mutation. */
  transactionLink?: Maybe<TransactionLink>;
  deletedTransactionLinkNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
  /** An edge for our `TransactionLink`. May be used by Relay 1. */
  transactionLinkEdge?: Maybe<TransactionLinksEdge>;
};


/** The output of our delete `TransactionLink` mutation. */
export type DeleteTransactionLinkPayloadTransactionLinkEdgeArgs = {
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
};

/** All input for the `deleteTransactionLink` mutation. */
export type DeleteTransactionLinkInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTransactionNoteByNodeId` mutation. */
export type DeleteTransactionNoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TransactionNote` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `TransactionNote` mutation. */
export type DeleteTransactionNotePayload = {
  __typename?: 'DeleteTransactionNotePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TransactionNote` that was deleted by this mutation. */
  transactionNote?: Maybe<TransactionNote>;
  deletedTransactionNoteNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
  /** An edge for our `TransactionNote`. May be used by Relay 1. */
  transactionNoteEdge?: Maybe<TransactionNotesEdge>;
};


/** The output of our delete `TransactionNote` mutation. */
export type DeleteTransactionNotePayloadTransactionNoteEdgeArgs = {
  orderBy?: Maybe<Array<TransactionNotesOrderBy>>;
};

/** All input for the `deleteTransactionNote` mutation. */
export type DeleteTransactionNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTravellerByNodeId` mutation. */
export type DeleteTravellerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Traveller` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Traveller` mutation. */
export type DeleteTravellerPayload = {
  __typename?: 'DeleteTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Traveller` that was deleted by this mutation. */
  traveller?: Maybe<Traveller>;
  deletedTravellerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Traveller`. May be used by Relay 1. */
  travellerEdge?: Maybe<TravellersEdge>;
};


/** The output of our delete `Traveller` mutation. */
export type DeleteTravellerPayloadTravellerEdgeArgs = {
  orderBy?: Maybe<Array<TravellersOrderBy>>;
};

/** All input for the `deleteTraveller` mutation. */
export type DeleteTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTripByNodeId` mutation. */
export type DeleteTripByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Trip` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `Trip` mutation. */
export type DeleteTripPayload = {
  __typename?: 'DeleteTripPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Trip` that was deleted by this mutation. */
  trip?: Maybe<Trip>;
  deletedTripNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  /** An edge for our `Trip`. May be used by Relay 1. */
  tripEdge?: Maybe<TripsEdge>;
};


/** The output of our delete `Trip` mutation. */
export type DeleteTripPayloadTripEdgeArgs = {
  orderBy?: Maybe<Array<TripsOrderBy>>;
};

/** All input for the `deleteTrip` mutation. */
export type DeleteTripInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTripTravellerByNodeId` mutation. */
export type DeleteTripTravellerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TripTraveller` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `TripTraveller` mutation. */
export type DeleteTripTravellerPayload = {
  __typename?: 'DeleteTripTravellerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripTraveller` that was deleted by this mutation. */
  tripTraveller?: Maybe<TripTraveller>;
  deletedTripTravellerNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
  /** An edge for our `TripTraveller`. May be used by Relay 1. */
  tripTravellerEdge?: Maybe<TripTravellersEdge>;
};


/** The output of our delete `TripTraveller` mutation. */
export type DeleteTripTravellerPayloadTripTravellerEdgeArgs = {
  orderBy?: Maybe<Array<TripTravellersOrderBy>>;
};

/** All input for the `deleteTripTraveller` mutation. */
export type DeleteTripTravellerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteTripFlightByNodeId` mutation. */
export type DeleteTripFlightByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TripFlight` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `TripFlight` mutation. */
export type DeleteTripFlightPayload = {
  __typename?: 'DeleteTripFlightPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TripFlight` that was deleted by this mutation. */
  tripFlight?: Maybe<TripFlight>;
  deletedTripFlightNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
  /** An edge for our `TripFlight`. May be used by Relay 1. */
  tripFlightEdge?: Maybe<TripFlightsEdge>;
};


/** The output of our delete `TripFlight` mutation. */
export type DeleteTripFlightPayloadTripFlightEdgeArgs = {
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
};

/** All input for the `deleteTripFlight` mutation. */
export type DeleteTripFlightInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  deletedUserNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `deleteVisaRequirementByNodeId` mutation. */
export type DeleteVisaRequirementByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `VisaRequirement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The output of our delete `VisaRequirement` mutation. */
export type DeleteVisaRequirementPayload = {
  __typename?: 'DeleteVisaRequirementPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `VisaRequirement` that was deleted by this mutation. */
  visaRequirement?: Maybe<VisaRequirement>;
  deletedVisaRequirementNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `VisaRequirement`. May be used by Relay 1. */
  visaRequirementEdge?: Maybe<VisaRequirementsEdge>;
};


/** The output of our delete `VisaRequirement` mutation. */
export type DeleteVisaRequirementPayloadVisaRequirementEdgeArgs = {
  orderBy?: Maybe<Array<VisaRequirementsOrderBy>>;
};

/** All input for the `deleteVisaRequirement` mutation. */
export type DeleteVisaRequirementInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** All input for the `dateWeek` mutation. */
export type DateWeekInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Datetime']>;
};

/** The output of our `dateWeek` mutation. */
export type DateWeekPayload = {
  __typename?: 'DateWeekPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  string?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `randomString` mutation. */
export type RandomStringInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: Maybe<Scalars['String']>;
  len?: Maybe<Scalars['Int']>;
};

/** The output of our `randomString` mutation. */
export type RandomStringPayload = {
  __typename?: 'RandomStringPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']>;
  string?: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type ExecutePaymentInput = {
  token: Scalars['String'];
  invoice: Scalars['UUID'];
  amount?: Maybe<Scalars['BigFloat']>;
};

export type GenericResponse = {
  __typename?: 'GenericResponse';
  success: Scalars['Boolean'];
  message?: Maybe<Scalars['String']>;
};

export type TrackQuoteViewInput = {
  key: Scalars['String'];
  viewType: Scalars['String'];
};

export type GenerateUploadUrlInput = {
  hash: Scalars['String'];
  contentType: Scalars['String'];
  protected: Scalars['Boolean'];
};

/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type Subscription = {
  __typename?: 'Subscription';
  /** Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form. (live) */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live) */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. (live) */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `Account`. (live) */
  accounts?: Maybe<AccountsConnection>;
  /** Reads and enables pagination through a set of `Agency`. (live) */
  agencies?: Maybe<AgenciesConnection>;
  /** Reads and enables pagination through a set of `AgencyMember`. (live) */
  agencyMembers?: Maybe<AgencyMembersConnection>;
  /** Reads and enables pagination through a set of `Airport`. (live) */
  airports?: Maybe<AirportsConnection>;
  /** Reads and enables pagination through a set of `CombinedTransaction`. (live) */
  combinedTransactions?: Maybe<CombinedTransactionsConnection>;
  /** Reads and enables pagination through a set of `Country`. (live) */
  countries?: Maybe<CountriesConnection>;
  /** Reads and enables pagination through a set of `Customer`. (live) */
  customers?: Maybe<CustomersConnection>;
  /** Reads and enables pagination through a set of `CustomerTraveller`. (live) */
  customerTravellers?: Maybe<CustomerTravellersConnection>;
  /** Reads and enables pagination through a set of `DashboardSummary`. (live) */
  dashboardSummaries?: Maybe<DashboardSummariesConnection>;
  /** Reads and enables pagination through a set of `Destination`. (live) */
  destinations?: Maybe<DestinationsConnection>;
  /** Reads and enables pagination through a set of `DestinationFeature`. (live) */
  destinationFeatures?: Maybe<DestinationFeaturesConnection>;
  /** Reads and enables pagination through a set of `DestinationGuide`. (live) */
  destinationGuides?: Maybe<DestinationGuidesConnection>;
  /** Reads and enables pagination through a set of `Email`. (live) */
  emails?: Maybe<EmailsConnection>;
  /** Reads and enables pagination through a set of `Enquiry`. (live) */
  enquiries?: Maybe<EnquiriesConnection>;
  /** Reads and enables pagination through a set of `Expense`. (live) */
  expenses?: Maybe<ExpensesConnection>;
  /** Reads and enables pagination through a set of `Feature`. (live) */
  features?: Maybe<FeaturesConnection>;
  /** Reads and enables pagination through a set of `FinanceCategory`. (live) */
  financeCategories?: Maybe<FinanceCategoriesConnection>;
  /** Reads and enables pagination through a set of `Invoice`. (live) */
  invoices?: Maybe<InvoicesConnection>;
  /** Reads and enables pagination through a set of `InvoiceSummary`. (live) */
  invoiceSummaries?: Maybe<InvoiceSummariesConnection>;
  /** Reads and enables pagination through a set of `MapPoint`. (live) */
  mapPoints?: Maybe<MapPointsConnection>;
  /** Reads and enables pagination through a set of `MediaGallery`. (live) */
  mediaGalleries?: Maybe<MediaGalleriesConnection>;
  /** Reads and enables pagination through a set of `MediaGalleryItem`. (live) */
  mediaGalleryItems?: Maybe<MediaGalleryItemsConnection>;
  /** Reads and enables pagination through a set of `MediaItem`. (live) */
  mediaItems?: Maybe<MediaItemsConnection>;
  /** Reads and enables pagination through a set of `Note`. (live) */
  notes?: Maybe<NotesConnection>;
  /** Reads and enables pagination through a set of `Passport`. (live) */
  passports?: Maybe<PassportsConnection>;
  /** Reads and enables pagination through a set of `Payment`. (live) */
  payments?: Maybe<PaymentsConnection>;
  /** Reads and enables pagination through a set of `Property`. (live) */
  properties?: Maybe<PropertiesConnection>;
  /** Reads and enables pagination through a set of `Quote`. (live) */
  quotes?: Maybe<QuotesConnection>;
  /** Reads and enables pagination through a set of `QuoteView`. (live) */
  quoteViews?: Maybe<QuoteViewsConnection>;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. (live) */
  quoteAccommodationDetails?: Maybe<QuoteAccommodationDetailsConnection>;
  /** Reads and enables pagination through a set of `QuoteCurrency`. (live) */
  quoteCurrencies?: Maybe<QuoteCurrenciesConnection>;
  /** Reads and enables pagination through a set of `QuoteDay`. (live) */
  quoteDays?: Maybe<QuoteDaysConnection>;
  /** Reads and enables pagination through a set of `QuoteDayDestination`. (live) */
  quoteDayDestinations?: Maybe<QuoteDayDestinationsConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItem`. (live) */
  quoteFinanceLineItems?: Maybe<QuoteFinanceLineItemsConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItemSummary`. (live) */
  quoteFinanceLineItemSummaries?: Maybe<QuoteFinanceLineItemSummariesConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceSummary`. (live) */
  quoteFinanceSummaries?: Maybe<QuoteFinanceSummariesConnection>;
  /** Reads and enables pagination through a set of `QuoteHero`. (live) */
  quoteHeroes?: Maybe<QuoteHeroesConnection>;
  /** Reads and enables pagination through a set of `Reminder`. (live) */
  reminders?: Maybe<RemindersConnection>;
  /** Reads and enables pagination through a set of `Supplier`. (live) */
  suppliers?: Maybe<SuppliersConnection>;
  /** Reads and enables pagination through a set of `SupplierInvoice`. (live) */
  supplierInvoices?: Maybe<SupplierInvoicesConnection>;
  /** Reads and enables pagination through a set of `Testimonial`. (live) */
  testimonials?: Maybe<TestimonialsConnection>;
  /** Reads and enables pagination through a set of `Timeline`. (live) */
  timelines?: Maybe<TimelinesConnection>;
  /** Reads and enables pagination through a set of `Transaction`. (live) */
  transactions?: Maybe<TransactionsConnection>;
  /** Reads and enables pagination through a set of `TransactionImportBatch`. (live) */
  transactionImportBatches?: Maybe<TransactionImportBatchesConnection>;
  /** Reads and enables pagination through a set of `TransactionLink`. (live) */
  transactionLinks?: Maybe<TransactionLinksConnection>;
  /** Reads and enables pagination through a set of `TransactionNote`. (live) */
  transactionNotes?: Maybe<TransactionNotesConnection>;
  /** Reads and enables pagination through a set of `Traveller`. (live) */
  travellers?: Maybe<TravellersConnection>;
  /** Reads and enables pagination through a set of `Trip`. (live) */
  trips?: Maybe<TripsConnection>;
  /** Reads and enables pagination through a set of `TripTraveller`. (live) */
  tripTravellers?: Maybe<TripTravellersConnection>;
  /** Reads and enables pagination through a set of `TripFlight`. (live) */
  tripFlights?: Maybe<TripFlightsConnection>;
  /** Reads and enables pagination through a set of `User`. (live) */
  users?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `VirtualTransaction`. (live) */
  virtualTransactions?: Maybe<VirtualTransactionsConnection>;
  /** Reads and enables pagination through a set of `VisaRequirement`. (live) */
  visaRequirements?: Maybe<VisaRequirementsConnection>;
  /**  (live) */
  account?: Maybe<Account>;
  /**  (live) */
  agency?: Maybe<Agency>;
  /**  (live) */
  agencyMember?: Maybe<AgencyMember>;
  /**  (live) */
  airport?: Maybe<Airport>;
  /**  (live) */
  country?: Maybe<Country>;
  /**  (live) */
  customer?: Maybe<Customer>;
  /**  (live) */
  customerTraveller?: Maybe<CustomerTraveller>;
  /**  (live) */
  destination?: Maybe<Destination>;
  /**  (live) */
  destinationFeature?: Maybe<DestinationFeature>;
  /**  (live) */
  destinationGuide?: Maybe<DestinationGuide>;
  /**  (live) */
  email?: Maybe<Email>;
  /**  (live) */
  enquiry?: Maybe<Enquiry>;
  /**  (live) */
  expense?: Maybe<Expense>;
  /**  (live) */
  feature?: Maybe<Feature>;
  /**  (live) */
  financeCategory?: Maybe<FinanceCategory>;
  /**  (live) */
  invoice?: Maybe<Invoice>;
  /**  (live) */
  invoicePublic?: Maybe<InvoicePublic>;
  /**  (live) */
  mapPoint?: Maybe<MapPoint>;
  /**  (live) */
  mediaGallery?: Maybe<MediaGallery>;
  /**  (live) */
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  /**  (live) */
  mediaItem?: Maybe<MediaItem>;
  /**  (live) */
  note?: Maybe<Note>;
  /**  (live) */
  passport?: Maybe<Passport>;
  /**  (live) */
  payment?: Maybe<Payment>;
  /**  (live) */
  property?: Maybe<Property>;
  /**  (live) */
  quote?: Maybe<Quote>;
  /**  (live) */
  quoteView?: Maybe<QuoteView>;
  /**  (live) */
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  /**  (live) */
  quoteCurrency?: Maybe<QuoteCurrency>;
  /**  (live) */
  quoteDay?: Maybe<QuoteDay>;
  /**  (live) */
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  /**  (live) */
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  /**  (live) */
  quoteHero?: Maybe<QuoteHero>;
  /**  (live) */
  quotePublic?: Maybe<QuotePublic>;
  /**  (live) */
  reminder?: Maybe<Reminder>;
  /**  (live) */
  supplier?: Maybe<Supplier>;
  /**  (live) */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /**  (live) */
  testimonial?: Maybe<Testimonial>;
  /**  (live) */
  transaction?: Maybe<Transaction>;
  /**  (live) */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /**  (live) */
  transactionLink?: Maybe<TransactionLink>;
  /**  (live) */
  transactionNote?: Maybe<TransactionNote>;
  /**  (live) */
  traveller?: Maybe<Traveller>;
  /**  (live) */
  trip?: Maybe<Trip>;
  /**  (live) */
  tripTraveller?: Maybe<TripTraveller>;
  /**  (live) */
  tripFlight?: Maybe<TripFlight>;
  /**  (live) */
  user?: Maybe<User>;
  /**  (live) */
  visaRequirement?: Maybe<VisaRequirement>;
  /**  (live) */
  currentUserRoles?: Maybe<Scalars['String']>;
  /**  (live) */
  currentUserSub?: Maybe<Scalars['String']>;
  /**  (live) */
  featuredProperty?: Maybe<Property>;
  /**  (live) */
  userCan?: Maybe<Scalars['Boolean']>;
  /** Reads a single `Account` using its globally unique `ID`. (live) */
  accountByNodeId?: Maybe<Account>;
  /** Reads a single `Agency` using its globally unique `ID`. (live) */
  agencyByNodeId?: Maybe<Agency>;
  /** Reads a single `AgencyMember` using its globally unique `ID`. (live) */
  agencyMemberByNodeId?: Maybe<AgencyMember>;
  /** Reads a single `Airport` using its globally unique `ID`. (live) */
  airportByNodeId?: Maybe<Airport>;
  /** Reads a single `Country` using its globally unique `ID`. (live) */
  countryByNodeId?: Maybe<Country>;
  /** Reads a single `Customer` using its globally unique `ID`. (live) */
  customerByNodeId?: Maybe<Customer>;
  /** Reads a single `CustomerTraveller` using its globally unique `ID`. (live) */
  customerTravellerByNodeId?: Maybe<CustomerTraveller>;
  /** Reads a single `Destination` using its globally unique `ID`. (live) */
  destinationByNodeId?: Maybe<Destination>;
  /** Reads a single `DestinationFeature` using its globally unique `ID`. (live) */
  destinationFeatureByNodeId?: Maybe<DestinationFeature>;
  /** Reads a single `DestinationGuide` using its globally unique `ID`. (live) */
  destinationGuideByNodeId?: Maybe<DestinationGuide>;
  /** Reads a single `Email` using its globally unique `ID`. (live) */
  emailByNodeId?: Maybe<Email>;
  /** Reads a single `Enquiry` using its globally unique `ID`. (live) */
  enquiryByNodeId?: Maybe<Enquiry>;
  /** Reads a single `Expense` using its globally unique `ID`. (live) */
  expenseByNodeId?: Maybe<Expense>;
  /** Reads a single `Feature` using its globally unique `ID`. (live) */
  featureByNodeId?: Maybe<Feature>;
  /** Reads a single `FinanceCategory` using its globally unique `ID`. (live) */
  financeCategoryByNodeId?: Maybe<FinanceCategory>;
  /** Reads a single `Invoice` using its globally unique `ID`. (live) */
  invoiceByNodeId?: Maybe<Invoice>;
  /** Reads a single `InvoicePublic` using its globally unique `ID`. (live) */
  invoicePublicByNodeId?: Maybe<InvoicePublic>;
  /** Reads a single `MapPoint` using its globally unique `ID`. (live) */
  mapPointByNodeId?: Maybe<MapPoint>;
  /** Reads a single `MediaGallery` using its globally unique `ID`. (live) */
  mediaGalleryByNodeId?: Maybe<MediaGallery>;
  /** Reads a single `MediaGalleryItem` using its globally unique `ID`. (live) */
  mediaGalleryItemByNodeId?: Maybe<MediaGalleryItem>;
  /** Reads a single `MediaItem` using its globally unique `ID`. (live) */
  mediaItemByNodeId?: Maybe<MediaItem>;
  /** Reads a single `Note` using its globally unique `ID`. (live) */
  noteByNodeId?: Maybe<Note>;
  /** Reads a single `Passport` using its globally unique `ID`. (live) */
  passportByNodeId?: Maybe<Passport>;
  /** Reads a single `Payment` using its globally unique `ID`. (live) */
  paymentByNodeId?: Maybe<Payment>;
  /** Reads a single `Property` using its globally unique `ID`. (live) */
  propertyByNodeId?: Maybe<Property>;
  /** Reads a single `Quote` using its globally unique `ID`. (live) */
  quoteByNodeId?: Maybe<Quote>;
  /** Reads a single `QuoteView` using its globally unique `ID`. (live) */
  quoteViewByNodeId?: Maybe<QuoteView>;
  /** Reads a single `QuoteAccommodationDetail` using its globally unique `ID`. (live) */
  quoteAccommodationDetailByNodeId?: Maybe<QuoteAccommodationDetail>;
  /** Reads a single `QuoteCurrency` using its globally unique `ID`. (live) */
  quoteCurrencyByNodeId?: Maybe<QuoteCurrency>;
  /** Reads a single `QuoteDay` using its globally unique `ID`. (live) */
  quoteDayByNodeId?: Maybe<QuoteDay>;
  /** Reads a single `QuoteDayDestination` using its globally unique `ID`. (live) */
  quoteDayDestinationByNodeId?: Maybe<QuoteDayDestination>;
  /** Reads a single `QuoteFinanceLineItem` using its globally unique `ID`. (live) */
  quoteFinanceLineItemByNodeId?: Maybe<QuoteFinanceLineItem>;
  /** Reads a single `QuoteHero` using its globally unique `ID`. (live) */
  quoteHeroByNodeId?: Maybe<QuoteHero>;
  /** Reads a single `QuotePublic` using its globally unique `ID`. (live) */
  quotePublicByNodeId?: Maybe<QuotePublic>;
  /** Reads a single `Reminder` using its globally unique `ID`. (live) */
  reminderByNodeId?: Maybe<Reminder>;
  /** Reads a single `Supplier` using its globally unique `ID`. (live) */
  supplierByNodeId?: Maybe<Supplier>;
  /** Reads a single `SupplierInvoice` using its globally unique `ID`. (live) */
  supplierInvoiceByNodeId?: Maybe<SupplierInvoice>;
  /** Reads a single `Testimonial` using its globally unique `ID`. (live) */
  testimonialByNodeId?: Maybe<Testimonial>;
  /** Reads a single `Transaction` using its globally unique `ID`. (live) */
  transactionByNodeId?: Maybe<Transaction>;
  /** Reads a single `TransactionImportBatch` using its globally unique `ID`. (live) */
  transactionImportBatchByNodeId?: Maybe<TransactionImportBatch>;
  /** Reads a single `TransactionLink` using its globally unique `ID`. (live) */
  transactionLinkByNodeId?: Maybe<TransactionLink>;
  /** Reads a single `TransactionNote` using its globally unique `ID`. (live) */
  transactionNoteByNodeId?: Maybe<TransactionNote>;
  /** Reads a single `Traveller` using its globally unique `ID`. (live) */
  travellerByNodeId?: Maybe<Traveller>;
  /** Reads a single `Trip` using its globally unique `ID`. (live) */
  tripByNodeId?: Maybe<Trip>;
  /** Reads a single `TripTraveller` using its globally unique `ID`. (live) */
  tripTravellerByNodeId?: Maybe<TripTraveller>;
  /** Reads a single `TripFlight` using its globally unique `ID`. (live) */
  tripFlightByNodeId?: Maybe<TripFlight>;
  /** Reads a single `User` using its globally unique `ID`. (live) */
  userByNodeId?: Maybe<User>;
  /** Reads a single `VisaRequirement` using its globally unique `ID`. (live) */
  visaRequirementByNodeId?: Maybe<VisaRequirement>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionNodeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAccountsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AccountsOrderBy>>;
  condition?: Maybe<AccountCondition>;
  filter?: Maybe<AccountFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAgenciesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgenciesOrderBy>>;
  condition?: Maybe<AgencyCondition>;
  filter?: Maybe<AgencyFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAgencyMembersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AgencyMembersOrderBy>>;
  condition?: Maybe<AgencyMemberCondition>;
  filter?: Maybe<AgencyMemberFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAirportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AirportsOrderBy>>;
  condition?: Maybe<AirportCondition>;
  filter?: Maybe<AirportFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCombinedTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CombinedTransactionsOrderBy>>;
  condition?: Maybe<CombinedTransactionCondition>;
  filter?: Maybe<CombinedTransactionFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCountriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CountriesOrderBy>>;
  condition?: Maybe<CountryCondition>;
  filter?: Maybe<CountryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCustomersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomersOrderBy>>;
  condition?: Maybe<CustomerCondition>;
  filter?: Maybe<CustomerFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCustomerTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<CustomerTravellersOrderBy>>;
  condition?: Maybe<CustomerTravellerCondition>;
  filter?: Maybe<CustomerTravellerFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDashboardSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DashboardSummariesOrderBy>>;
  condition?: Maybe<DashboardSummaryCondition>;
  filter?: Maybe<DashboardSummaryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationsOrderBy>>;
  condition?: Maybe<DestinationCondition>;
  filter?: Maybe<DestinationFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationFeaturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationFeaturesOrderBy>>;
  condition?: Maybe<DestinationFeatureCondition>;
  filter?: Maybe<DestinationFeatureFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationGuidesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<DestinationGuidesOrderBy>>;
  condition?: Maybe<DestinationGuideCondition>;
  filter?: Maybe<DestinationGuideFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionEmailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EmailsOrderBy>>;
  condition?: Maybe<EmailCondition>;
  filter?: Maybe<EmailFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionEnquiriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<EnquiriesOrderBy>>;
  condition?: Maybe<EnquiryCondition>;
  filter?: Maybe<EnquiryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionExpensesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ExpensesOrderBy>>;
  condition?: Maybe<ExpenseCondition>;
  filter?: Maybe<ExpenseFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFeaturesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FeaturesOrderBy>>;
  condition?: Maybe<FeatureCondition>;
  filter?: Maybe<FeatureFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFinanceCategoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FinanceCategoriesOrderBy>>;
  condition?: Maybe<FinanceCategoryCondition>;
  filter?: Maybe<FinanceCategoryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoicesOrderBy>>;
  condition?: Maybe<InvoiceCondition>;
  filter?: Maybe<InvoiceFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionInvoiceSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<InvoiceSummariesOrderBy>>;
  condition?: Maybe<InvoiceSummaryCondition>;
  filter?: Maybe<InvoiceSummaryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMapPointsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MapPointsOrderBy>>;
  condition?: Maybe<MapPointCondition>;
  filter?: Maybe<MapPointFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaGalleriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaGalleriesOrderBy>>;
  condition?: Maybe<MediaGalleryCondition>;
  filter?: Maybe<MediaGalleryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaGalleryItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaGalleryItemsOrderBy>>;
  condition?: Maybe<MediaGalleryItemCondition>;
  filter?: Maybe<MediaGalleryItemFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<MediaItemsOrderBy>>;
  condition?: Maybe<MediaItemCondition>;
  filter?: Maybe<MediaItemFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotesOrderBy>>;
  condition?: Maybe<NoteCondition>;
  filter?: Maybe<NoteFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPassportsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PassportsOrderBy>>;
  condition?: Maybe<PassportCondition>;
  filter?: Maybe<PassportFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPaymentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PaymentsOrderBy>>;
  condition?: Maybe<PaymentCondition>;
  filter?: Maybe<PaymentFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPropertiesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PropertiesOrderBy>>;
  condition?: Maybe<PropertyCondition>;
  filter?: Maybe<PropertyFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuotesOrderBy>>;
  condition?: Maybe<QuoteCondition>;
  filter?: Maybe<QuoteFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteViewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteViewsOrderBy>>;
  condition?: Maybe<QuoteViewCondition>;
  filter?: Maybe<QuoteViewFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteAccommodationDetailsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteAccommodationDetailsOrderBy>>;
  condition?: Maybe<QuoteAccommodationDetailCondition>;
  filter?: Maybe<QuoteAccommodationDetailFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteCurrenciesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteCurrenciesOrderBy>>;
  condition?: Maybe<QuoteCurrencyCondition>;
  filter?: Maybe<QuoteCurrencyFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteDaysArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDaysOrderBy>>;
  condition?: Maybe<QuoteDayCondition>;
  filter?: Maybe<QuoteDayFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteDayDestinationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteDayDestinationsOrderBy>>;
  condition?: Maybe<QuoteDayDestinationCondition>;
  filter?: Maybe<QuoteDayDestinationFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteFinanceLineItemsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceLineItemsOrderBy>>;
  condition?: Maybe<QuoteFinanceLineItemCondition>;
  filter?: Maybe<QuoteFinanceLineItemFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteFinanceLineItemSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceLineItemSummariesOrderBy>>;
  condition?: Maybe<QuoteFinanceLineItemSummaryCondition>;
  filter?: Maybe<QuoteFinanceLineItemSummaryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteFinanceSummariesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteFinanceSummariesOrderBy>>;
  condition?: Maybe<QuoteFinanceSummaryCondition>;
  filter?: Maybe<QuoteFinanceSummaryFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteHeroesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<QuoteHeroesOrderBy>>;
  condition?: Maybe<QuoteHeroCondition>;
  filter?: Maybe<QuoteHeroFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionRemindersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<RemindersOrderBy>>;
  condition?: Maybe<ReminderCondition>;
  filter?: Maybe<ReminderFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSuppliersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SuppliersOrderBy>>;
  condition?: Maybe<SupplierCondition>;
  filter?: Maybe<SupplierFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSupplierInvoicesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<SupplierInvoicesOrderBy>>;
  condition?: Maybe<SupplierInvoiceCondition>;
  filter?: Maybe<SupplierInvoiceFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTestimonialsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TestimonialsOrderBy>>;
  condition?: Maybe<TestimonialCondition>;
  filter?: Maybe<TestimonialFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTimelinesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TimelinesOrderBy>>;
  condition?: Maybe<TimelineCondition>;
  filter?: Maybe<TimelineFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionsOrderBy>>;
  condition?: Maybe<TransactionCondition>;
  filter?: Maybe<TransactionFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionImportBatchesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionImportBatchesOrderBy>>;
  condition?: Maybe<TransactionImportBatchCondition>;
  filter?: Maybe<TransactionImportBatchFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionLinksArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionLinksOrderBy>>;
  condition?: Maybe<TransactionLinkCondition>;
  filter?: Maybe<TransactionLinkFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionNotesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TransactionNotesOrderBy>>;
  condition?: Maybe<TransactionNoteCondition>;
  filter?: Maybe<TransactionNoteFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TravellersOrderBy>>;
  condition?: Maybe<TravellerCondition>;
  filter?: Maybe<TravellerFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripsOrderBy>>;
  condition?: Maybe<TripCondition>;
  filter?: Maybe<TripFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripTravellersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripTravellersOrderBy>>;
  condition?: Maybe<TripTravellerCondition>;
  filter?: Maybe<TripTravellerFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripFlightsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TripFlightsOrderBy>>;
  condition?: Maybe<TripFlightCondition>;
  filter?: Maybe<TripFlightFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionUsersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVirtualTransactionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VirtualTransactionsOrderBy>>;
  condition?: Maybe<VirtualTransactionCondition>;
  filter?: Maybe<VirtualTransactionFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVisaRequirementsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<VisaRequirementsOrderBy>>;
  condition?: Maybe<VisaRequirementCondition>;
  filter?: Maybe<VisaRequirementFilter>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAccountArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAgencyArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAgencyMemberArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAirportArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCountryArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCustomerArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCustomerTravellerArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationFeatureArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationGuideArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionEmailArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionEnquiryArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionExpenseArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFeatureArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFinanceCategoryArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionInvoiceArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionInvoicePublicArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMapPointArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaGalleryArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaGalleryItemArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaItemArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionNoteArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPassportArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPaymentArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPropertyArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteViewArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteAccommodationDetailArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteCurrencyArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteDayArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteDayDestinationArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteFinanceLineItemArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteHeroArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuotePublicArgs = {
  key: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionReminderArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSupplierArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSupplierInvoiceArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTestimonialArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionImportBatchArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionLinkArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionNoteArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTravellerArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripTravellerArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripFlightArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionUserArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVisaRequirementArgs = {
  id: Scalars['UUID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionUserCanArgs = {
  task?: Maybe<Scalars['String']>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAccountByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAgencyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAgencyMemberByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionAirportByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCountryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCustomerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionCustomerTravellerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationFeatureByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionDestinationGuideByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionEmailByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionEnquiryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionExpenseByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFeatureByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionFinanceCategoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionInvoiceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionInvoicePublicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMapPointByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaGalleryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaGalleryItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionMediaItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionNoteByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPassportByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPaymentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionPropertyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteViewByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteAccommodationDetailByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteCurrencyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteDayByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteDayDestinationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteFinanceLineItemByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuoteHeroByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionQuotePublicByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionReminderByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSupplierByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionSupplierInvoiceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTestimonialByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionImportBatchByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionLinkByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTransactionNoteByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTravellerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripTravellerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionTripFlightByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 * 
 * #### Live Queries
 * 
 * Live query fields are differentiated by containing `(live)` at the end of their description, they are added for each field in the `Query` type. When you subscribe to a live query field, the selection set will be evaluated and sent to the client, and then most things\* that would cause the output of the selection set to change will trigger the selection set to be re-evaluated and the results to be re-sent to the client.
 * 
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 * 
 * Live queries can be very expensive, so try and keep them small and focussed.
 * 
 * #### Events
 * 
 * Event fields will run their selection set when, and only when, the specified server-side event occurs. This makes them a lot more efficient than Live Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionVisaRequirementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

export type PayInvoiceMutationVariables = Exact<{
  invoice: Scalars['UUID'];
  token: Scalars['String'];
  amount?: Maybe<Scalars['BigFloat']>;
}>;


export type PayInvoiceMutation = (
  { __typename?: 'Mutation' }
  & { executePayment?: Maybe<(
    { __typename?: 'GenericResponse' }
    & Pick<GenericResponse, 'success' | 'message'>
  )> }
);

export type GetFeaturedPropertyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetFeaturedPropertyQuery = (
  { __typename?: 'Query' }
  & { featuredProperty?: Maybe<(
    { __typename?: 'Property' }
    & Pick<Property, 'id' | 'name' | 'featureCopy'>
    & { heroMedia?: Maybe<(
      { __typename?: 'MediaItem' }
      & Pick<MediaItem, 'hash' | 'fileName'>
    )> }
  )> }
);

export type TrackQuoteViewMutationVariables = Exact<{
  key: Scalars['String'];
  viewType: Scalars['String'];
}>;


export type TrackQuoteViewMutation = (
  { __typename?: 'Mutation' }
  & { trackQuoteView?: Maybe<(
    { __typename?: 'GenericResponse' }
    & Pick<GenericResponse, 'success'>
  )> }
);

export type GetInvoiceQueryVariables = Exact<{
  id: Scalars['UUID'];
}>;


export type GetInvoiceQuery = (
  { __typename?: 'Query' }
  & { invoice?: Maybe<(
    { __typename?: 'InvoicePublic' }
    & Pick<InvoicePublic, 'amount' | 'amountDue' | 'amountPaid' | 'currency' | 'due' | 'id' | 'invoiced' | 'number' | 'paid' | 'summary' | 'trip'>
  )> }
);

export type GetQuoteQueryVariables = Exact<{
  key: Scalars['String'];
}>;


export type GetQuoteQuery = (
  { __typename?: 'Query' }
  & { quote?: Maybe<(
    { __typename?: 'QuotePublic' }
    & Pick<QuotePublic, 'id' | 'status' | 'start' | 'duration' | 'travellerCount' | 'total' | 'baseCurrency' | 'inclusions' | 'exclusions' | 'expires' | 'locked'>
    & { hero?: Maybe<(
      { __typename?: 'QuoteHero' }
      & Pick<QuoteHero, 'title' | 'subtitle'>
      & { image?: Maybe<(
        { __typename?: 'MediaItem' }
        & Pick<MediaItem, 'hash'>
      )> }
    )>, user?: Maybe<(
      { __typename?: 'User' }
      & Pick<User, 'lastName' | 'firstName' | 'email' | 'phone' | 'genderPreposition'>
    )>, trip?: Maybe<(
      { __typename?: 'Trip' }
      & Pick<Trip, 'name'>
      & { agency?: Maybe<(
        { __typename?: 'Agency' }
        & Pick<Agency, 'name'>
        & { logo?: Maybe<(
          { __typename?: 'MediaItem' }
          & Pick<MediaItem, 'hash'>
        )> }
      )>, agencyMember?: Maybe<(
        { __typename?: 'AgencyMember' }
        & Pick<AgencyMember, 'lastName' | 'firstName' | 'phone' | 'email' | 'genderPreposition'>
      )>, tripFlights: (
        { __typename?: 'TripFlightsConnection' }
        & { nodes: Array<Maybe<(
          { __typename?: 'TripFlight' }
          & Pick<TripFlight, 'id' | 'arrival' | 'carrier' | 'departure' | 'number'>
          & { departureAirport?: Maybe<(
            { __typename?: 'Airport' }
            & Pick<Airport, 'id' | 'latitude' | 'longitude' | 'iata' | 'icao' | 'timezone' | 'city'>
            & { country?: Maybe<(
              { __typename?: 'Country' }
              & Pick<Country, 'name'>
            )> }
          )>, arrivalAirport?: Maybe<(
            { __typename?: 'Airport' }
            & Pick<Airport, 'id' | 'latitude' | 'longitude' | 'iata' | 'icao' | 'timezone' | 'city'>
            & { country?: Maybe<(
              { __typename?: 'Country' }
              & Pick<Country, 'name'>
            )> }
          )> }
        )>> }
      ) }
    )>, days: (
      { __typename?: 'QuoteDaysConnection' }
      & { nodes: Array<Maybe<(
        { __typename?: 'QuoteDay' }
        & Pick<QuoteDay, 'id' | 'date' | 'order' | 'activitySummary' | 'activityDetail' | 'accommodationId'>
        & { quoteDayDestinationsByDayId: (
          { __typename?: 'QuoteDayDestinationsConnection' }
          & { nodes: Array<Maybe<(
            { __typename?: 'QuoteDayDestination' }
            & Pick<QuoteDayDestination, 'order'>
            & { destination?: Maybe<(
              { __typename?: 'Destination' }
              & Pick<Destination, 'id' | 'name'>
            )> }
          )>> }
        ) }
      )>> }
    ), accommodation: (
      { __typename?: 'QuoteAccommodationDetailsConnection' }
      & { nodes: Array<Maybe<(
        { __typename?: 'QuoteAccommodationDetail' }
        & Pick<QuoteAccommodationDetail, 'id' | 'order' | 'basis' | 'confirmation' | 'beverageInclusions' | 'foodInclusions' | 'roomType'>
        & { property?: Maybe<(
          { __typename?: 'Property' }
          & Pick<Property, 'id' | 'name' | 'summary' | 'latitude' | 'longitude'>
          & { heroMedia?: Maybe<(
            { __typename?: 'MediaItem' }
            & Pick<MediaItem, 'hash'>
          )> }
        )> }
      )>> }
    ) }
  )> }
);

export type GetDestinationQueryVariables = Exact<{
  id: Scalars['UUID'];
}>;


export type GetDestinationQuery = (
  { __typename?: 'Query' }
  & { destination?: Maybe<(
    { __typename?: 'Destination' }
    & Pick<Destination, 'id' | 'name' | 'body' | 'latitude' | 'longitude'>
    & { country?: Maybe<(
      { __typename?: 'Country' }
      & Pick<Country, 'id' | 'name'>
    )>, heroMedia?: Maybe<(
      { __typename?: 'MediaItem' }
      & Pick<MediaItem, 'id' | 'hash'>
    )>, gallery?: Maybe<(
      { __typename?: 'MediaGallery' }
      & Pick<MediaGallery, 'id'>
      & { mediaGalleryItems: (
        { __typename?: 'MediaGalleryItemsConnection' }
        & { nodes: Array<Maybe<(
          { __typename?: 'MediaGalleryItem' }
          & Pick<MediaGalleryItem, 'id'>
          & { mediaItem?: Maybe<(
            { __typename?: 'MediaItem' }
            & Pick<MediaItem, 'hash' | 'name'>
          )> }
        )>> }
      ), mediaGalleriesByParentId: (
        { __typename?: 'MediaGalleriesConnection' }
        & { nodes: Array<Maybe<(
          { __typename?: 'MediaGallery' }
          & Pick<MediaGallery, 'id' | 'name'>
          & { mediaGalleryItems: (
            { __typename?: 'MediaGalleryItemsConnection' }
            & { nodes: Array<Maybe<(
              { __typename?: 'MediaGalleryItem' }
              & Pick<MediaGalleryItem, 'id'>
              & { mediaItem?: Maybe<(
                { __typename?: 'MediaItem' }
                & Pick<MediaItem, 'name' | 'hash'>
              )> }
            )>> }
          ) }
        )>> }
      ) }
    )> }
  )> }
);

export type GetPropertyQueryVariables = Exact<{
  id: Scalars['UUID'];
}>;


export type GetPropertyQuery = (
  { __typename?: 'Query' }
  & { property?: Maybe<(
    { __typename?: 'Property' }
    & Pick<Property, 'id' | 'name' | 'city' | 'summary' | 'nearestAirport' | 'latitude' | 'longitude'>
    & { country?: Maybe<(
      { __typename?: 'Country' }
      & Pick<Country, 'id' | 'name'>
    )>, heroMedia?: Maybe<(
      { __typename?: 'MediaItem' }
      & Pick<MediaItem, 'id' | 'hash'>
    )>, gallery?: Maybe<(
      { __typename?: 'MediaGallery' }
      & Pick<MediaGallery, 'id'>
      & { mediaGalleryItems: (
        { __typename?: 'MediaGalleryItemsConnection' }
        & { nodes: Array<Maybe<(
          { __typename?: 'MediaGalleryItem' }
          & Pick<MediaGalleryItem, 'id'>
          & { mediaItem?: Maybe<(
            { __typename?: 'MediaItem' }
            & Pick<MediaItem, 'hash' | 'name'>
          )> }
        )>> }
      ), mediaGalleriesByParentId: (
        { __typename?: 'MediaGalleriesConnection' }
        & { nodes: Array<Maybe<(
          { __typename?: 'MediaGallery' }
          & Pick<MediaGallery, 'id' | 'name'>
          & { mediaGalleryItems: (
            { __typename?: 'MediaGalleryItemsConnection' }
            & { nodes: Array<Maybe<(
              { __typename?: 'MediaGalleryItem' }
              & Pick<MediaGalleryItem, 'id'>
              & { mediaItem?: Maybe<(
                { __typename?: 'MediaItem' }
                & Pick<MediaItem, 'name' | 'hash'>
              )> }
            )>> }
          ) }
        )>> }
      ) }
    )> }
  )> }
);


export const PayInvoiceDocument = gql`
    mutation PayInvoice($invoice: UUID!, $token: String!, $amount: BigFloat) {
  executePayment(input: {invoice: $invoice, token: $token, amount: $amount}) {
    success
    message
  }
}
    `;
export type PayInvoiceMutationFn = Apollo.MutationFunction<PayInvoiceMutation, PayInvoiceMutationVariables>;

/**
 * __usePayInvoiceMutation__
 *
 * To run a mutation, you first call `usePayInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePayInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [payInvoiceMutation, { data, loading, error }] = usePayInvoiceMutation({
 *   variables: {
 *      invoice: // value for 'invoice'
 *      token: // value for 'token'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function usePayInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<PayInvoiceMutation, PayInvoiceMutationVariables>) {
        return Apollo.useMutation<PayInvoiceMutation, PayInvoiceMutationVariables>(PayInvoiceDocument, baseOptions);
      }
export type PayInvoiceMutationHookResult = ReturnType<typeof usePayInvoiceMutation>;
export type PayInvoiceMutationResult = Apollo.MutationResult<PayInvoiceMutation>;
export type PayInvoiceMutationOptions = Apollo.BaseMutationOptions<PayInvoiceMutation, PayInvoiceMutationVariables>;
export const GetFeaturedPropertyDocument = gql`
    query GetFeaturedProperty {
  featuredProperty {
    id
    name
    featureCopy
    heroMedia {
      hash
      fileName
    }
  }
}
    `;

/**
 * __useGetFeaturedPropertyQuery__
 *
 * To run a query within a React component, call `useGetFeaturedPropertyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeaturedPropertyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeaturedPropertyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetFeaturedPropertyQuery(baseOptions?: Apollo.QueryHookOptions<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>) {
        return Apollo.useQuery<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>(GetFeaturedPropertyDocument, baseOptions);
      }
export function useGetFeaturedPropertyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>) {
          return Apollo.useLazyQuery<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>(GetFeaturedPropertyDocument, baseOptions);
        }
export type GetFeaturedPropertyQueryHookResult = ReturnType<typeof useGetFeaturedPropertyQuery>;
export type GetFeaturedPropertyLazyQueryHookResult = ReturnType<typeof useGetFeaturedPropertyLazyQuery>;
export type GetFeaturedPropertyQueryResult = Apollo.QueryResult<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>;
export const TrackQuoteViewDocument = gql`
    mutation TrackQuoteView($key: String!, $viewType: String!) {
  trackQuoteView(input: {key: $key, viewType: $viewType}) {
    success
  }
}
    `;
export type TrackQuoteViewMutationFn = Apollo.MutationFunction<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>;

/**
 * __useTrackQuoteViewMutation__
 *
 * To run a mutation, you first call `useTrackQuoteViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTrackQuoteViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [trackQuoteViewMutation, { data, loading, error }] = useTrackQuoteViewMutation({
 *   variables: {
 *      key: // value for 'key'
 *      viewType: // value for 'viewType'
 *   },
 * });
 */
export function useTrackQuoteViewMutation(baseOptions?: Apollo.MutationHookOptions<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>) {
        return Apollo.useMutation<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>(TrackQuoteViewDocument, baseOptions);
      }
export type TrackQuoteViewMutationHookResult = ReturnType<typeof useTrackQuoteViewMutation>;
export type TrackQuoteViewMutationResult = Apollo.MutationResult<TrackQuoteViewMutation>;
export type TrackQuoteViewMutationOptions = Apollo.BaseMutationOptions<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>;
export const GetInvoiceDocument = gql`
    query GetInvoice($id: UUID!) {
  invoice: invoicePublic(id: $id) {
    amount
    amountDue
    amountPaid
    currency
    due
    id
    invoiced
    number
    paid
    summary
    trip
  }
}
    `;

/**
 * __useGetInvoiceQuery__
 *
 * To run a query within a React component, call `useGetInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceQuery, GetInvoiceQueryVariables>) {
        return Apollo.useQuery<GetInvoiceQuery, GetInvoiceQueryVariables>(GetInvoiceDocument, baseOptions);
      }
export function useGetInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceQuery, GetInvoiceQueryVariables>) {
          return Apollo.useLazyQuery<GetInvoiceQuery, GetInvoiceQueryVariables>(GetInvoiceDocument, baseOptions);
        }
export type GetInvoiceQueryHookResult = ReturnType<typeof useGetInvoiceQuery>;
export type GetInvoiceLazyQueryHookResult = ReturnType<typeof useGetInvoiceLazyQuery>;
export type GetInvoiceQueryResult = Apollo.QueryResult<GetInvoiceQuery, GetInvoiceQueryVariables>;
export const GetQuoteDocument = gql`
    query GetQuote($key: String!) {
  quote: quotePublic(key: $key) {
    id
    status
    start
    duration
    travellerCount
    total
    baseCurrency
    inclusions
    exclusions
    expires
    locked
    hero {
      title
      subtitle
      image {
        hash
      }
    }
    user {
      lastName
      firstName
      email
      phone
      genderPreposition
    }
    trip {
      name
      agency {
        name
        logo {
          hash
        }
      }
      agencyMember {
        lastName
        firstName
        phone
        email
        genderPreposition
      }
      tripFlights(orderBy: DEPARTURE_ASC) {
        nodes {
          id
          arrival
          carrier
          departure
          number
          departureAirport {
            id
            latitude
            longitude
            iata
            icao
            timezone
            city
            country {
              name
            }
          }
          arrivalAirport {
            id
            latitude
            longitude
            iata
            icao
            timezone
            city
            country {
              name
            }
          }
        }
      }
    }
    days: quoteDaysByQuoteId(orderBy: ORDER_ASC) {
      nodes {
        id
        date
        order
        activitySummary
        activityDetail
        accommodationId
        quoteDayDestinationsByDayId(orderBy: ORDER_ASC) {
          nodes {
            order
            destination {
              id
              name
            }
          }
        }
      }
    }
    accommodation: quoteAccommodationDetailsByQuoteId(orderBy: ORDER_ASC) {
      nodes {
        id
        order
        basis
        confirmation
        beverageInclusions
        foodInclusions
        roomType
        property {
          id
          name
          summary
          latitude
          longitude
          heroMedia {
            hash
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetQuoteQuery__
 *
 * To run a query within a React component, call `useGetQuoteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuoteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuoteQuery({
 *   variables: {
 *      key: // value for 'key'
 *   },
 * });
 */
export function useGetQuoteQuery(baseOptions: Apollo.QueryHookOptions<GetQuoteQuery, GetQuoteQueryVariables>) {
        return Apollo.useQuery<GetQuoteQuery, GetQuoteQueryVariables>(GetQuoteDocument, baseOptions);
      }
export function useGetQuoteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQuoteQuery, GetQuoteQueryVariables>) {
          return Apollo.useLazyQuery<GetQuoteQuery, GetQuoteQueryVariables>(GetQuoteDocument, baseOptions);
        }
export type GetQuoteQueryHookResult = ReturnType<typeof useGetQuoteQuery>;
export type GetQuoteLazyQueryHookResult = ReturnType<typeof useGetQuoteLazyQuery>;
export type GetQuoteQueryResult = Apollo.QueryResult<GetQuoteQuery, GetQuoteQueryVariables>;
export const GetDestinationDocument = gql`
    query GetDestination($id: UUID!) {
  destination(id: $id) {
    id
    name
    body
    country {
      id
      name
    }
    latitude
    longitude
    heroMedia {
      id
      hash
    }
    gallery {
      id
      mediaGalleryItems {
        nodes {
          id
          mediaItem {
            hash
            name
          }
        }
      }
      mediaGalleriesByParentId {
        nodes {
          id
          name
          mediaGalleryItems {
            nodes {
              id
              mediaItem {
                name
                hash
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetDestinationQuery__
 *
 * To run a query within a React component, call `useGetDestinationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDestinationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDestinationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetDestinationQuery(baseOptions: Apollo.QueryHookOptions<GetDestinationQuery, GetDestinationQueryVariables>) {
        return Apollo.useQuery<GetDestinationQuery, GetDestinationQueryVariables>(GetDestinationDocument, baseOptions);
      }
export function useGetDestinationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDestinationQuery, GetDestinationQueryVariables>) {
          return Apollo.useLazyQuery<GetDestinationQuery, GetDestinationQueryVariables>(GetDestinationDocument, baseOptions);
        }
export type GetDestinationQueryHookResult = ReturnType<typeof useGetDestinationQuery>;
export type GetDestinationLazyQueryHookResult = ReturnType<typeof useGetDestinationLazyQuery>;
export type GetDestinationQueryResult = Apollo.QueryResult<GetDestinationQuery, GetDestinationQueryVariables>;
export const GetPropertyDocument = gql`
    query GetProperty($id: UUID!) {
  property(id: $id) {
    id
    name
    city
    summary
    nearestAirport
    country {
      id
      name
    }
    latitude
    longitude
    heroMedia {
      id
      hash
    }
    gallery {
      id
      mediaGalleryItems {
        nodes {
          id
          mediaItem {
            hash
            name
          }
        }
      }
      mediaGalleriesByParentId {
        nodes {
          id
          name
          mediaGalleryItems {
            nodes {
              id
              mediaItem {
                name
                hash
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetPropertyQuery__
 *
 * To run a query within a React component, call `useGetPropertyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPropertyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPropertyQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPropertyQuery(baseOptions: Apollo.QueryHookOptions<GetPropertyQuery, GetPropertyQueryVariables>) {
        return Apollo.useQuery<GetPropertyQuery, GetPropertyQueryVariables>(GetPropertyDocument, baseOptions);
      }
export function useGetPropertyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPropertyQuery, GetPropertyQueryVariables>) {
          return Apollo.useLazyQuery<GetPropertyQuery, GetPropertyQueryVariables>(GetPropertyDocument, baseOptions);
        }
export type GetPropertyQueryHookResult = ReturnType<typeof useGetPropertyQuery>;
export type GetPropertyLazyQueryHookResult = ReturnType<typeof useGetPropertyLazyQuery>;
export type GetPropertyQueryResult = Apollo.QueryResult<GetPropertyQuery, GetPropertyQueryVariables>;